#!/bin/bash

# Functions library :: for install scripts
# Author: crims0n. <http://minios.ru>
#

# =================================================================
# =================================================================
# ========================= VARIABLES =============================
# =================================================================
# =================================================================

function common_variables() {
    #
    CONTAINER_TYPE="0"
    set +u
    if [ -z $container ]; then
        container=""
    fi
    if [ -z $MODULE ]; then
        MODULE=""
    fi
    set -u
    : 'if [ -f /.dockerenv ] || [ "$container" = "podman" ]; then
        OUTPUT="/dev/stdout"
        #CONTAINER="docker"
    fi'
    if [[ (-f /.dockerenv || "$container" = "podman") && ! -f /.minios-live-container ]]; then
        CONTAINER_TYPE="1"
    fi
    if [[ (-f /.dockerenv || "$container" = "podman") && -f /.minios-live-container ]]; then
        CONTAINER_TYPE="2"
    fi

    if [ $DISTRIBUTION_ARCH = "amd64" ]; then
        KERNEL_ARCH="amd64"
        #PACKAGE_VARIANT="standard"
    elif [ $DISTRIBUTION_ARCH = "i386" ]; then
        KERNEL_ARCH="686-pae"
        #KERNEL_ARCH="686"
        #PACKAGE_VARIANT="minimum"
    elif [ $DISTRIBUTION_ARCH = "arm64" ]; then
        KERNEL_ARCH="arm64"
    fi

    if [ $DESKTOP_ENVIRONMENT = "slax" ]; then
        PACKAGE_VARIANT="minimum"
    fi

    if [ $DESKTOP_ENVIRONMENT = "cloud" ]; then
        PACKAGE_VARIANT="cloud"
    fi

    if [ $DISTRIBUTION_TYPE = "debian" ]; then
        DISTRIBUTION_URL="http://ftp.debian.org/debian"
    elif [ $DISTRIBUTION_TYPE = "ubuntu" ]; then
        DISTRIBUTION_URL="http://archive.ubuntu.com/ubuntu"
    fi

    if [ $DISTRIBUTION = "kali-rolling" ]; then
        DISTRIBUTION_URL="http://archive.kali.org/kali"
    fi

    if [ $DISTRIBUTION = "orel" ]; then
        DISTRIBUTION_URL="http://mirror.yandex.ru/astra/stable/orel/repository"
    fi

}

# =================================================================
# =================================================================
# ===================== COMMON FUNCTIONS ==========================
# =================================================================
# =================================================================

function current_process() {
    echo -e "${LIGHTYELLOW}=====> running ${CYAN}${CMD[ii]}${ENDCOLOUR}${LIGHTYELLOW} ...${ENDCOLOUR}"
}

# =================================================================
# beautiful console
# красивая консоль
# =================================================================

function console_colours() {
    RED="\e[31m"
    GREEN="\e[32m"
    YELLOW="\e[33m"
    BLUE="\e[34m"
    MAGENTA="\e[35m"
    CYAN="\e[36m"
    LIGHTGRAY="\e[37m"
    DARKGRAY="\e[90m"
    LIGHTRED="\e[91m"
    LIGHTGREEN="\e[92m"
    LIGHTYELLOW="\e[93m"
    LIGHTBLUE="\e[94m"
    LIGHTMAGENTA="\e[95m"
    LIGHTCYAN="\e[96m"
    BOLD="\e[1m"
    DIM="\e[2m"
    UNDERLINED="\e[4m"
    BLINK="\e[5m"
    REVERSE="\e[7m"
    HIDDEN="\e[8m"
    ENDCOLOUR="\e[0m"
}

# =================================================================
# help functions
# функции помощи
# =================================================================

function help() {
    if [ $SCRIPT_DIR != "/usr/bin" ]; then
        # if $1 is set, use $1 as headline message in help()
        if [ -f /etc/default/locale ]; then
            if grep -q 'LANG="ru_RU.UTF-8"' /etc/default/locale >/dev/null 2>&1; then
                if [ -z ${1+x} ]; then
                    echo -e "${LIGHTYELLOW}Этот скрипт собирает загружаемый ISO образ $SYSTEMNAME.${ENDCOLOUR}"
                    echo -e
                else
                    echo -e $1
                    echo
                fi
                echo -e "Поддерживаемые команды : ${CYAN}${CMD[*]}${ENDCOLOUR}"
                echo -e
                echo -e "Синтаксис: ${MAGENTA}$0${ENDCOLOUR} [start_cmd] [-] [end_cmd]"
                if [ -L /usr/bin/$LIVEKITNAME-install ] && [ "$0" != "/usr/bin/$LIVEKITNAME-install" ]; then
                    echo -e "\t${CYAN}$LIVEKITNAME-install${ENDCOLOUR} [start_cmd] [-] [end_cmd]"
                fi
                echo -e "\tзапуск от start_cmd до end_cmd"
                echo -e "\tесли start_cmd опущен, выполняются все команды, начиная с первой"
                echo -e "\tесли end_cmd опущен, выполняются все команды до последней"
                echo -e "\tвведите одну команду, чтобы запустить определенную команду"
                echo -e "\tвведите '-' как единственный аргумент для запуска всех команд"
                echo -e "\t"
                echo -e "\tПримеры:${LIGHTYELLOW}$0 build_bootstrap - build_chroot${ENDCOLOUR}"
                echo -e "\t\t${LIGHTYELLOW}$0 - build_chroot${ENDCOLOUR}"
                echo -e "\t\t${LIGHTYELLOW}$0 build_bootstrap -${ENDCOLOUR}"
                echo -e "\t\t${LIGHTYELLOW}$0 build_iso${ENDCOLOUR}"
                echo -e "\t\t${LIGHTYELLOW}$0 -${ENDCOLOUR}"
                exit 0
            else
                if [ -z ${1+x} ]; then
                    echo -e "${LIGHTYELLOW}This script builds bootable $SYSTEMNAME ISO image.${ENDCOLOUR}"
                    echo -e
                else
                    echo -e $1
                    echo
                fi
                echo -e "Supported commands : ${CYAN}${CMD[*]}${ENDCOLOUR}"
                echo -e
                echo -e "Syntax: ${MAGENTA}$0${ENDCOLOUR} [start_cmd] [-] [end_cmd]"
                if [ -L /usr/bin/$LIVEKITNAME-install ] && [ "$0" != "/usr/bin/$LIVEKITNAME-install" ]; then
                    echo -e "\t${CYAN}$LIVEKITNAME-install${ENDCOLOUR} [start_cmd] [-] [end_cmd]"
                fi
                echo -e "\trun from start_cmd to end_cmd"
                echo -e "\tif start_cmd is omitted, start from first command"
                echo -e "\tif end_cmd is omitted, end with last command"
                echo -e "\tenter single cmd to run the specific command"
                echo -e "\tenter '-' as only argument to run all commands"
                echo -e "\t"
                echo -e "\tExamples:${LIGHTYELLOW}$0 build_bootstrap - build_chroot${ENDCOLOUR}"
                echo -e "\t\t${LIGHTYELLOW}$0 - build_chroot${ENDCOLOUR}"
                echo -e "\t\t${LIGHTYELLOW}$0 build_bootstrap -${ENDCOLOUR}"
                echo -e "\t\t${LIGHTYELLOW}$0 build_iso${ENDCOLOUR}"
                echo -e "\t\t${LIGHTYELLOW}$0 -${ENDCOLOUR}"
                exit 0
            fi
        fi
    else
        # if $1 is set, use $1 as headline message in help()
        if [ -f /etc/default/locale ]; then
            if grep -q 'LANG="ru_RU.UTF-8"' /etc/default/locale >/dev/null 2>&1; then
                if [ -z ${1+x} ]; then
                    echo -e "${LIGHTYELLOW}Этот скрипт собирает модули для $SYSTEMNAME.${ENDCOLOUR}"
                    echo -e
                else
                    echo -e $1
                    echo
                fi
                echo -e "Поддерживаемые команды : ${CYAN}${CMD[*]}${ENDCOLOUR}"
                echo -e
                echo -e "Синтаксис: ${MAGENTA}$0${ENDCOLOUR} [start_cmd] [-] [end_cmd]"
                if [ -L /usr/bin/$LIVEKITNAME-install ] && [ "$0" != "/usr/bin/$LIVEKITNAME-install" ]; then
                    echo -e "\t${CYAN}$LIVEKITNAME-install${ENDCOLOUR} [start_cmd] [-] [end_cmd]"
                fi
                echo -e "\tзапуск от start_cmd до end_cmd"
                echo -e "\tесли start_cmd опущен, выполняются все команды, начиная с первой"
                echo -e "\tесли end_cmd опущен, выполняются все команды до последней"
                echo -e "\tвведите одну команду, чтобы запустить определенную команду"
                echo -e "\tвведите '-' как единственный аргумент для запуска всех команд"
                echo -e "\t"
                echo -e "\tСкрипты установки должны находиться в папке с именем будущего модуля."
                echo -e "\tНапример, чтобы собрать модуль с именем 05-vscode, скрипты сборки"
                echo -e "\tдолжны находиться по следующему пути: ${LIGHTYELLOW}$CURRENT_DIR/modules/05-vscode${ENDCOLOUR}"
                echo -e "\tПримеры:"
                echo -e "\t${LIGHTYELLOW}$0 build_modules${ENDCOLOUR} сборка модулей"
                echo -e "\t${LIGHTYELLOW}$0 repack_modules${ENDCOLOUR} перепаковка системы с типом сжатия, указанным"
                echo -e "\tв /etc/$LIVEKITNAME/config в переменной COMP_TYPE"
                echo -e "\t${LIGHTYELLOW}$0 -${ENDCOLOUR} эта команда запустит обе функции поочерёдно"
                exit 0
            else
                if [ -z ${1+x} ]; then
                    echo -e "${LIGHTYELLOW}This script builds modules for $SYSTEMNAME.${ENDCOLOUR}"
                    echo -e
                else
                    echo -e $1
                    echo
                fi
                echo -e "Supported commands : ${CYAN}${CMD[*]}${ENDCOLOUR}"
                echo -e
                echo -e "Syntax: ${MAGENTA}$0${ENDCOLOUR} [start_cmd] [-] [end_cmd]"
                if [ -L /usr/bin/$LIVEKITNAME-install ] && [ "$0" != "/usr/bin/$LIVEKITNAME-install" ]; then
                    echo -e "\t${CYAN}$LIVEKITNAME-install${ENDCOLOUR} [start_cmd] [-] [end_cmd]"
                fi
                echo -e "\trun from start_cmd to end_cmd"
                echo -e "\tif start_cmd is omitted, start from first command"
                echo -e "\tif end_cmd is omitted, end with last command"
                echo -e "\tenter single cmd to run the specific command"
                echo -e "\tenter '-' as only argument to run all commands"
                echo -e "\t"
                echo -e "\tThe installation scripts must be in the folder with the"
                echo -e "\tname of the future module. For example, to build a module"
                echo -e "\tnamed 05-vscode, build scripts should be in the following"
                echo -e "\tpath: ${LIGHTYELLOW}$CURRENT_DIR/modules/05-vscode${ENDCOLOUR}"
                echo -e "\tExamples:"
                echo -e "\t${LIGHTYELLOW}$0 build_modules ${ENDCOLOUR} build modules"
                echo -e "\t${LIGHTYELLOW}$0 repack_modules ${ENDCOLOUR} repack the system with the"
                echo -e "\tcompression type specified by /etc/$LIVEKITNAME/config in COMP_TYPE variable"
                echo -e "\t${LIGHTYELLOW}$0 - ${ENDCOLOUR} this command will run both functions alternately"
                exit 0
            fi
        fi
    fi

}

# =================================================================
# reading configuration file
# чтение конфигурационного файла
# =================================================================

function read_config() { # read_config file.cfg var_name1 var_name2
    # ref: https://stackoverflow.com/a/20815951

    shopt -s extglob # needed the "one of these"-match below
    local configfile="${1?No configuration file given}"
    local keylist="${@:2}" # positional parameters 2 and following

    if [[ ! -f "$configfile" ]]; then
        echo >&2 "\"$configfile\" is not a file!"
        exit 1
    fi
    if [[ ! -r "$configfile" ]]; then
        echo >&2 "\"$configfile\" is not readable!"
        exit 1
    fi

    keylist="${keylist// /|}" # this will generate a regex 'one of these'

    # lhs : "left hand side" : Everything left of the '='
    # rhs : "right hand side": Everything right of the '='
    #
    # "lhs" will hold the name of the key you want to read.
    # The value of "rhs" will be assigned to that key.
    while IFS='= ' read -r lhs rhs; do
        # IF lhs in keylist
        # AND rhs not empty
        if [[ "$lhs" =~ ^($keylist)$ ]] && [[ -n $rhs ]]; then
            rhs="${rhs%\"*}"   # Del opening string quotes
            rhs="${rhs#\"*}"   # Del closing string quotes
            rhs="${rhs%\'*}"   # Del opening string quotes
            rhs="${rhs#\'*}"   # Del closing string quotes
            eval $lhs=\"$rhs\" # The magic happens here
        fi
        # tr used as a safeguard against dos line endings
    done <<<$(tr -d '\r' <$configfile)

    shopt -u extglob # Switching it back off after use
}

# =================================================================
# parsing input commands
# разбор входных команд
# =================================================================

function find_index() {
    local ret
    local i
    for ((i = 0; i < ${#CMD[*]}; i++)); do
        if [ "${CMD[i]}" == "$1" ]; then
            index=$i
            return
        fi
    done
    help "Command not found : $1"
}

# =================================================================
# creating a symbolic link to the executable file for using
# autocompletion on the command line
# создание символической ссылки на исполняемый файл для
# использования автодополнения в командной строке
# =================================================================

function create_livekitname_install_symlink() {
    if [ -L /usr/bin/$LIVEKITNAME-install ]; then
        if [ "$(readlink /usr/bin/$LIVEKITNAME-install)" != "$SCRIPT_DIR/install" ]; then
            rm -f /usr/bin/$LIVEKITNAME-install
            ln -s $SCRIPT_DIR/install /usr/bin/$LIVEKITNAME-install
            if grep 'LANG="ru_RU.UTF-8"' /etc/default/locale >/dev/null 2>&1; then
                echo -e "Символическая ссылка ${MAGENTA}/usr/bin/$LIVEKITNAME-install${ENDCOLOUR} была обновлена."
                echo -e "Теперь она указывает на ${MAGENTA}$SCRIPT_DIR/install${ENDCOLOUR}."
            else
                echo -e "The ${MAGENTA}/usr/bin/$LIVEKITNAME-install${ENDCOLOUR} symbolic link has been updated."
                echo -e "It now points to ${MAGENTA}$SCRIPT_DIR/install${ENDCOLOUR}."
            fi
        fi
        if [ "$0" != "/usr/bin/$LIVEKITNAME-install" ]; then
            if grep 'LANG="ru_RU.UTF-8"' /etc/default/locale >/dev/null 2>&1; then
                echo -e "Вы можете использовать команду ${CYAN}$LIVEKITNAME-install${ENDCOLOUR} для запуска этой программы."
            else
                echo -e "You can use the ${CYAN}$LIVEKITNAME-install${ENDCOLOUR} command to run this program."
            fi
        fi
    else
        ln -s $SCRIPT_DIR/install /usr/bin/$LIVEKITNAME-install
        if grep 'LANG="ru_RU.UTF-8"' /etc/default/locale >/dev/null 2>&1; then
            echo -e "Символическая ссылка ${MAGENTA}/usr/bin/$LIVEKITNAME-install${ENDCOLOUR} была добавлена"
            echo -e "для ${MAGENTA}$SCRIPT_DIR/install${ENDCOLOUR}."

        else
            echo -e "The ${MAGENTA}/usr/bin/$LIVEKITNAME-install${ENDCOLOUR} symbolic link has been added"
            echo -e "for ${MAGENTA}$SCRIPT_DIR/install${ENDCOLOUR}."
        fi
    fi
    if [ ! -f /usr/bin/minios-modules ]; then
        cp "$SCRIPT_DIR/linux-live/basesystem/01-core/rootcopy-install/usr/bin/minios-modules" /usr/bin/minios-modules
        if [ "$0" != "/usr/bin/minios-modules" ]; then
            if grep 'LANG="ru_RU.UTF-8"' /etc/default/locale >/dev/null 2>&1; then
                echo -e "Вы можете использовать команду ${CYAN}minios-modules${ENDCOLOUR} для запуска программы сборки модулей."
            else
                echo -e "You can use the ${CYAN}minios-modules${ENDCOLOUR} command to run the module build program."
            fi
        fi
    fi
}

# =================================================================
# creating autocompletion on the command line
# создание автодополнения в командной строке
# =================================================================

function create_completion() {
    if [ -d /etc/bash_completion.d ]; then
        if [ ! -f /etc/bash_completion.d/$LIVEKITNAME-install ] || ! grep "${CMD[*]}" /etc/bash_completion.d/$LIVEKITNAME-install >/dev/null 2>&1; then
            cat <<EOF >/etc/bash_completion.d/$LIVEKITNAME-install
#!/usr/bin/env bash
complete -W "${CMD[*]}" $LIVEKITNAME-install
EOF
        fi
        if [ "$0" != "/usr/bin/$LIVEKITNAME-install" ]; then
            if grep 'LANG="ru_RU.UTF-8"' /etc/default/locale >/dev/null 2>&1; then
                echo -e "Дополнение команд работает только при использовании команды ${CYAN}$LIVEKITNAME-install${ENDCOLOUR}."
                echo -e
            else
                echo -e "Command completion only works when using the ${CYAN}$LIVEKITNAME-install${ENDCOLOUR} command."
                echo -e
            fi
        fi
        if [ ! -f /etc/bash_completion.d/minios-modules ] || ! grep "${CMD[*]}" /etc/bash_completion.d/minios-modules >/dev/null 2>&1; then
            cat <<EOF >/etc/bash_completion.d/minios-modules
#!/usr/bin/env bash
complete -W "build_modules repack_modules download_sources" minios-modules
EOF
        fi
        if [ "$0" != "/usr/bin/minios-modules" ]; then
            if grep 'LANG="ru_RU.UTF-8"' /etc/default/locale >/dev/null 2>&1; then
                echo -e "Дополнение команд работает только при использовании команды ${CYAN}minios-modules${ENDCOLOUR}."
                echo -e
            else
                echo -e "Command completion only works when using the ${CYAN}minios-modules${ENDCOLOUR} command."
                echo -e
            fi
        fi
    fi
}

# =================================================================
# only allow 'root' to run the script
# разрешаем запуск скрипта только пользователю 'root'
# =================================================================

function allow_root_only() {
    if [ $(id -u) -ne 0 ]; then
        echo -e "${BOLD}${RED}This script should be run as 'root'!${ENDCOLOUR}"
        exit 1
    fi

    export HOME=/root
    export LC_ALL=C
}

# =================================================================
# check that we are inside chroot
# проверяем, что мы внутри chroot
# =================================================================

function check_is_in_chroot() {
    if [ $(stat -c %i /)="2" ]; then
        echo -e "${BOLD}${RED}This script should be run inside chroot only!${ENDCOLOUR}"
        exit 1
    fi
}

# =================================================================
#
#
# =================================================================

aufs_support() {
    if ! cat /proc/filesystems | grep aufs >/dev/null; then
        UNION_BUILD_TYPE="overlayfs"
    else
        UNION_BUILD_TYPE="aufs"
    fi
}

# =================================================================
# check if filesystems are unmounted inside chroot
# проверяем, размонтированы ли файловые системы внутри chroot
# =================================================================

function check_mounted() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."
    if grep -qs "$INSTALL_DIR/dev" /proc/mounts || grep -qs "$INSTALL_DIR/run" /proc/mounts || grep -qs "$INSTALL_DIR/proc" /proc/mounts || grep -qs "$INSTALL_DIR/sys" /proc/mounts || grep -qs "$INSTALL_DIR/dev/pts" /proc/mounts || grep -qs "$INSTALL_DIR/tmp" /proc/mounts; then
        echo -e "${BOLD}${LIGHTYELLOW}Сhroot contains mounted filesystems.${ENDCOLOUR}"
        if [ "$UNATTENDED" = "true" ]; then
            chroot_umount_fs
        else
            read -r -p "$(echo -e ""Do you want to ${GREEN}unmount them${ENDCOLOUR}? [${BOLD}${GREEN}Y${ENDCOLOUR}/n])" response
            response=${response,,}
            if [[ "$response" =~ ^(no|n)$ ]]; then
                exit 1
            else
                chroot_umount_fs
            fi
        fi
    fi
}

# =================================================================
# check if the folder where the installation will be performed is empty
# проверяем, пуста ли папка, в которую будет производиться установка
# =================================================================

function check_install_dir() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."
    if [ "$UNATTENDED" = "true" ]; then
        #echo -e "${RED}!!!Unattended installation!!!${ENDCOLOUR}"
        #INSTALL_DIR="$BUILD_DIR/$DISTRIBUTION-$DISTRIBUTION_ARCH"
        INSTALL_DIR="$WORK_DIR/basesystem"
        echo -e "The working directory is ${MAGENTA}$INSTALL_DIR${ENDCOLOUR}."
        if [ "$(ls -A $INSTALL_DIR)" != "" ]; then
            cleanup
            check_mounted
        fi
    else
        # ▼ должно быть только перенаправление ошибки!
        if [ "$(ls -A $INSTALL_DIR)" != "" ]; then
            echo -e "${MAGENTA}$INSTALL_DIR${ENDCOLOUR} is not empty."
            cleanup
            check_mounted
            if [ ! -d "$INSTALL_DIR" ]; then
                mkdir -p $INSTALL_DIR
            fi
            INSTALL_DIR="$(
                cd $INSTALL_DIR
                pwd
            )"
            echo $INSTALL_DIR >$SCRIPT_DIR/.install_dir && chmod 644 $SCRIPT_DIR/.install_dir
            echo -e "The working directory is ${MAGENTA}$INSTALL_DIR${ENDCOLOUR}."
        else
            mkdir -p $INSTALL_DIR
            check_mounted
            INSTALL_DIR="$(
                cd $INSTALL_DIR
                pwd
            )"
            echo $INSTALL_DIR >$SCRIPT_DIR/.install_dir && chmod 644 $SCRIPT_DIR/.install_dir
            echo -e "The working directory is ${MAGENTA}$INSTALL_DIR${ENDCOLOUR}."
        fi
    fi
}

# =================================================================
# configure build folder
# настраиваем папку для сборки
# =================================================================

function setup_install_dir() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."
    WORK_DIR="$BUILD_DIR/$DISTRIBUTION-$PACKAGE_VARIANT-$DISTRIBUTION_ARCH"
    if [ "$UNATTENDED" = "true" ] && [ "$INSTALL_DIR" = "" ]; then
        INSTALL_DIR="$WORK_DIR/basesystem"
        check_install_dir
    else
        if [ "$INSTALL_DIR" = "" ]; then
            if [ ! -f "$SCRIPT_DIR/.install_dir" ]; then
                echo "Enter the address of the working directory where we will build the system"
                read -r -p "$(echo -e "(Default is ${MAGENTA}$WORK_DIR/basesystem${ENDCOLOUR}): ")" response
                INSTALL_DIR=${response,,}
                if [ "$INSTALL_DIR" = "" ]; then
                    INSTALL_DIR="$WORK_DIR/basesystem"
                fi
                check_install_dir
            else
                LAST_INSTALL_DIR=$(cat "$SCRIPT_DIR/.install_dir")
                echo -e "Last time you used the build directory ${MAGENTA}$LAST_INSTALL_DIR${ENDCOLOUR}."
                read -r -p "$(echo -e ""Do you want to use it again? [${BOLD}${GREEN}Y${ENDCOLOUR}/n])" response
                response=${response,,}
                if [[ "$response" =~ ^(no|n)$ ]]; then
                    echo "Enter the address of the working directory where we will build the system"
                    read -r -p "$(echo -e "(Default is ${MAGENTA}$WORK_DIR/basesystem${ENDCOLOUR}): ")" response
                    INSTALL_DIR=${response,,}
                    if [ "$INSTALL_DIR" = "" ]; then
                        INSTALL_DIR="$WORK_DIR/basesystem"
                    fi
                    check_install_dir
                else
                    INSTALL_DIR="$LAST_INSTALL_DIR"
                    check_install_dir
                fi
            fi
        fi
    fi
}

# =================================================================
# cleaning the build folder
# очистка папки для сборки
# =================================================================

function cleanup() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."
    if [ "${CMD[ii]}" = "setup_host" ] || [ "${CMD[ii]}" = "build_bootstrap" ] || [ "${CMD[ii]}" = "build_chroot" ]; then
        if [ "$UNATTENDED" = "true" ]; then
            check_mounted
            rm -rf $INSTALL_DIR
            if [ -d "$INSTALL_DIR" ]; then
                cleanup
            fi
        else
            read -r -p "$(echo -e ""Do you want to ${BOLD}${RED}completely remove content${ENDCOLOUR} of ${MAGENTA}$INSTALL_DIR${ENDCOLOUR}? [y/${BOLD}${GREEN}N${ENDCOLOUR}])" response
            response=${response,,}
            if [[ "$response" =~ ^(yes|y)$ ]]; then
                check_mounted
                rm -rf $INSTALL_DIR
                if [ -d "$INSTALL_DIR" ]; then
                    cleanup
                fi
            else
                echo -e "${MAGENTA}$INSTALL_DIR${ENDCOLOUR} should be empty to continue."
                exit 1
            fi
        fi
    elif [ "${CMD[ii]}" = "remove_sources" ]; then
        if [ $REMOVE_SOURCES = "true" ]; then
            if [ "$UNATTENDED" = "true" ]; then
                check_mounted
                rm -rf $WORK_DIR
                if [ -d "$WORK_DIR" ]; then
                    cleanup
                fi
            else
                read -r -p "$(echo -e ""Do you want to ${BOLD}${RED}completely remove content${ENDCOLOUR} of ${MAGENTA}$WORK_DIR{ENDCOLOUR}? [y/${BOLD}${GREEN}N${ENDCOLOUR}])" response
                response=${response,,}
                if [[ "$response" =~ ^(yes|y)$ ]]; then
                    check_mounted
                    rm -rf $WORK_DIR
                    if [ -d "$WORK_DIR" ]; then
                        cleanup
                    fi
                else
                    echo -e "${MAGENTA}$INSTALL_DIR${ENDCOLOUR} should be empty to continue."
                    exit 1
                fi
            fi
        fi
    fi

}

# =================================================================
# mount filesystems inside chroot
# монтируем файловые системы внутри chroot
# =================================================================

function chroot_mount_fs() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."

    check_mounted

    if [ -f /.dockerenv ] || [ "$container" = "podman" ]; then
        if [ -L $INSTALL_DIR/etc/resolv.conf ] || [ $DISTRIBUTION = "stretch" ]; then
            mv $INSTALL_DIR/etc/resolv.conf $INSTALL_DIR/etc/resolv.conf.bak
            echo "nameserver 8.8.8.8" >>$INSTALL_DIR/etc/resolv.conf
        fi
    fi

    mount --bind /dev $INSTALL_DIR/dev
    mount --bind /run $INSTALL_DIR/run
    if [ $DISTRIBUTION = "stretch" ]; then
        mount --bind /proc $INSTALL_DIR/proc
    else
        mount none -t proc $INSTALL_DIR/proc
    fi
    mount none -t sysfs $INSTALL_DIR/sys
    mount none -t devpts $INSTALL_DIR/dev/pts
    mount none -t tmpfs $INSTALL_DIR/tmp
}

# =================================================================
# unmount filesystems inside chroot
# размонтируем файловые системы внутри chroot
# =================================================================

function chroot_umount_fs() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."

    set +e
    if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
        umount $INSTALL_DIR/proc
        umount $INSTALL_DIR/sys
        umount $INSTALL_DIR/dev/pts
        umount $INSTALL_DIR/tmp
        umount $INSTALL_DIR/dev
        umount $INSTALL_DIR/run
    else
        umount $INSTALL_DIR/proc >>$OUTPUT 2>&1
        umount $INSTALL_DIR/sys >>$OUTPUT 2>&1
        umount $INSTALL_DIR/dev/pts >>$OUTPUT 2>&1
        umount $INSTALL_DIR/tmp >>$OUTPUT 2>&1
        umount $INSTALL_DIR/dev >>$OUTPUT 2>&1
        umount $INSTALL_DIR/run >>$OUTPUT 2>&1
    fi
    if [ -f /.dockerenv ] || [ "$container" = "podman" ]; then
        if [ -L $INSTALL_DIR/etc/resolv.conf.bak ] || [ $DISTRIBUTION = "stretch" ]; then
            rm -f $INSTALL_DIR/etc/resolv.conf
            mv $INSTALL_DIR/etc/resolv.conf.bak $INSTALL_DIR/etc/resolv.conf
        elif [ -L $INSTALL_DIR/etc/resolv.conf.bak ] && [ -L $INSTALL_DIR/etc/resolv.conf ]; then
            rm -f $INSTALL_DIR/etc/resolv.conf.bak
        fi
    fi
    set -e

    check_mounted
}

# =================================================================
# delete the log
# удаляем лог
# =================================================================

function remove_log_file() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."
    if [ -f $LOGPATH/$LIVEKITNAME.log ]; then
        rm -f $LOGPATH/$LIVEKITNAME.log
    fi
    if [ -f $INSTALL_DIR/$LIVEKITNAME.log ]; then
        rm -f $INSTALL_DIR/$LIVEKITNAME.log
    fi
}

# =================================================================
# creating a backup of scripts (to run you need to set the variable
# CREATE_BACKUP = "true" in linux-live/buildconfig)
# создание бэкапа скриптов (для запуска необходимо установить
# переменную CREATE_BACKUP="1" в linux-live/buildconfig)
# =================================================================

function create_backup() {
    if [ $CREATE_BACKUP = "true" ]; then
        echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."
        if [ ! -f $SCRIPT_DIR/.script_version ]; then
            cat "1" >$SCRIPT_DIR/.script_version >>$OUTPUT 2>&1
            chmod 644 $SCRIPT_DIR/.script_version >>$OUTPUT 2>&1
        fi
        DATE=$(date +%Y%m%d_%H%M)
        CHANGED="false"
        rm -rf $SCRIPT_DIR/iso >>$OUTPUT 2>&1
        rm -f $SCRIPT_DIR/.install_dir >>$OUTPUT 2>&1
        rm -f $SCRIPT_DIR/*.log >>$OUTPUT 2>&1
        if [ ! -d $BUILD_DIR/minios-live-current ]; then
            CHANGED="true"
            mkdir -p $BUILD_DIR/minios-live-current
            (cd $SCRIPT_DIR && cp --parents -afr * $BUILD_DIR/minios-live-current)
        else
            for file in $(find $SCRIPT_DIR -path $SCRIPT_DIR/.git -prune -false -o -type f | sed "s,$SCRIPT_DIR/,,g" | sed "s,.script_version,,g"); do
                if ! cmp $SCRIPT_DIR/$file $BUILD_DIR/minios-live-current/$file >>$OUTPUT 2>&1; then
                    CHANGED="true"
                    echo -e "$file has been modified since last backup." >>$OUTPUT 2>&1
                    echo -e "Copying $SCRIPT_DIR/$file to $BUILD_DIR/minios-live-current/$file..." >>$OUTPUT 2>&1
                    cp -f "$SCRIPT_DIR/$file" "$BUILD_DIR/minios-live-current/$file" >>$OUTPUT 2>&1
                fi
            done
        fi
        if [ $CHANGED = "true" ]; then
            SCRIPT_VERSION=$(cat $SCRIPT_DIR/.script_version)
            echo $(($SCRIPT_VERSION + 1)) >$SCRIPT_DIR/.script_version
            echo $(($SCRIPT_VERSION + 1)) >$BUILD_DIR/minios-live-current/.script_version
            cd $SCRIPT_DIR >>$OUTPUT 2>&1
            rm -f $BUILD_DIR/minios-live-current.tar.gz
            tar -czf $BUILD_DIR/minios-live-current.tar.gz ./ >>$OUTPUT 2>&1
            cp $BUILD_DIR/minios-live-current.tar.gz $BUILD_DIR/minios-live-v$SCRIPT_VERSION-$DATE.tar.gz >>$OUTPUT 2>&1
        fi
    fi
}

# =================================================================
# Displaying information about the start of the build for a more
# convenient search in the logs
# Отображение информации о старте сборки для более удобного поиска
# в логах
# =================================================================

function new_run() {
    DATE=$(date +"%Y.%m.%d %H:%M")
    echo ""
    echo "=================================================================" >>$OUTPUT 2>&1
    echo "=================================================================" >>$OUTPUT 2>&1
    echo "============================ NEW RUN ============================" >>$OUTPUT 2>&1
    echo "======================== $DATE =======================" >>$OUTPUT 2>&1
    echo "=================================================================" >>$OUTPUT 2>&1
    echo "======= If during the installation you get an error that ========" >>$OUTPUT 2>&1
    echo "=== /dev/stdout is not available, try using a bionic or xenial ==" >>$OUTPUT 2>&1
    echo "================= based container to install. ===================" >>$OUTPUT 2>&1
    echo "=================================================================" >>$OUTPUT 2>&1
    echo "=================================================================" >>$OUTPUT 2>&1
    echo "========== Distributution: $DISTRIBUTION" >>$OUTPUT 2>&1
    echo "========== Desktop Environment: $DESKTOP_ENVIRONMENT" >>$OUTPUT 2>&1
    echo "========== Package Variant: $PACKAGE_VARIANT" >>$OUTPUT 2>&1
    echo "========== Arch: $DISTRIBUTION_ARCH" >>$OUTPUT 2>&1
    echo "========== Compression: $COMP_TYPE" >>$OUTPUT 2>&1
    echo "=================================================================" >>$OUTPUT 2>&1
    echo "=================================================================" >>$OUTPUT 2>&1
    echo ""
}

function add_chroot_configuration_files() {
    cat <<EOF >$1/$LIVEKITNAME.conf
OUTPUT=$OUTPUT
LOGPATH=$LOGPATH
BUILD_TEST_ISO=$BUILD_TEST_ISO
CREATE_BACKUP=$CREATE_BACKUP
DEBIAN_FRONTEND_TYPE=$DEBIAN_FRONTEND_TYPE
APT_CMD=$APT_CMD
APT_OPTIONS=$APT_OPTIONS
DESKTOP_ENVIRONMENT=$DESKTOP_ENVIRONMENT
DISTRIBUTION=$DISTRIBUTION
DISTRIBUTION_TYPE=$DISTRIBUTION_TYPE
PACKAGE_VARIANT=$PACKAGE_VARIANT
COMP_TYPE=$COMP_TYPE
KERNEL_ARCH=$KERNEL_ARCH
KERNEL_TYPE=$KERNEL_TYPE
LIVEKITNAME=$LIVEKITNAME
SYSTEMNAME=$SYSTEMNAME
DISTRIBUTION_ARCH=$DISTRIBUTION_ARCH
MODULE=$MODULE
USER_NAME=$USER_NAME
EOF

    cat <<'EOF' >$1/functions
#!/bin/bash

# =================================================================
# beautiful console
# красивая консоль
# =================================================================
function console_colours() {
    RED="\e[31m"
    GREEN="\e[32m"
    YELLOW="\e[33m"
    BLUE="\e[34m"
    MAGENTA="\e[35m"
    CYAN="\e[36m"
    LIGHTGRAY="\e[37m"
    DARKGRAY="\e[90m"
    LIGHTRED="\e[91m"
    LIGHTGREEN="\e[92m"
    LIGHTYELLOW="\e[93m"
    LIGHTBLUE="\e[94m"
    LIGHTMAGENTA="\e[95m"
    LIGHTCYAN="\e[96m"
    BOLD="\e[1m"
    DIM="\e[2m"
    UNDERLINED="\e[4m"
    BLINK="\e[5m"
    REVERSE="\e[7m"
    HIDDEN="\e[8m"
    ENDCOLOUR="\e[0m"
}

# =================================================================
# reading configuration file
# чтение конфигурационного файла
# =================================================================

function read_config() { # read_config file.cfg var_name1 var_name2
    # ref: https://stackoverflow.com/a/20815951

    shopt -s extglob # needed the "one of these"-match below
    local configfile="${1?No configuration file given}"
    local keylist="${@:2}" # positional parameters 2 and following

    if [[ ! -f "$configfile" ]]; then
        echo >&2 "\"$configfile\" is not a file!"
        exit 1
    fi
    if [[ ! -r "$configfile" ]]; then
        echo >&2 "\"$configfile\" is not readable!"
        exit 1
    fi

    keylist="${keylist// /|}" # this will generate a regex 'one of these'

    # lhs : "left hand side" : Everything left of the '='
    # rhs : "right hand side": Everything right of the '='
    #
    # "lhs" will hold the name of the key you want to read.
    # The value of "rhs" will be assigned to that key.
    while IFS='= ' read -r lhs rhs; do
        # IF lhs in keylist
        # AND rhs not empty
        if [[ "$lhs" =~ ^($keylist)$ ]] && [[ -n $rhs ]]; then
            rhs="${rhs%\"*}"   # Del opening string quotes
            rhs="${rhs#\"*}"   # Del closing string quotes
            rhs="${rhs%\'*}"   # Del opening string quotes
            rhs="${rhs#\'*}"   # Del closing string quotes
            eval $lhs=\"$rhs\" # The magic happens here
        fi
        # tr used as a safeguard against dos line endings
    done <<<$(tr -d '\r' <$configfile)

    shopt -u extglob # Switching it back off after use
}

# Unzip gzipped files (man pages), so LZMA can compress 2times better.
# First we fix symlinks, then uncompress files
# $1 = search directory
uncompress_files() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."
    local LINK LINE

    find "$1" -type l -name "*.gz" | while read LINE; do
        LINK="$(readlink "$LINE" | sed -r 's/.gz$//')"
        FILE="$(echo "$LINE" | sed -r 's/.gz$//')"
        ln -sfn "$LINK" "$FILE"
        rm -f "$LINE"
    done
    find "$1" -type f -name "*.gz" | xargs -r gunzip
}

# remove broken links
# $1 = search directory
remove_broken_links() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."
    find "$1" -type l -exec test ! -e {} \; -print | xargs rm -vf
}
EOF
}

function remove_chroot_configuration_files() {
    rm -f $1/$LIVEKITNAME.conf
    rm -f $1/functions
}

# =================================================================
# =================================================================
# ====================== HOST FUNCTIONS ===========================
# =================================================================
# =================================================================

# =================================================================
# Creating a $PACKAGE_VARIANT list from a template
# Создание списка пакетов из шаблона
# =================================================================

function create_apt_list() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."
    if [ ! -f $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION.list ]; then
        if [ $DISTRIBUTION_TYPE = "debian" ] && [[ $DISTRIBUTION = "stretch" || $DISTRIBUTION = "buster" ]]; then
            cp -f $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION_TYPE-old.list $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION.list
        else
            cp -f $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION_TYPE.list $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION.list
        fi
        sed -i "s,distro,$DISTRIBUTION,g" $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION.list
        sed -i "s,http://archive.ubuntu.com/ubuntu,$DISTRIBUTION_URL,g" $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION.list
    fi
}

function get_vars() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."
    set +u
    add_chroot_configuration_files $1
    . /functions
    read_config /$LIVEKITNAME.conf OUTPUT LOGPATH BUILD_TEST_ISO CREATE_BACKUP DEBIAN_FRONTEND_TYPE APT_CMD APT_OPTIONS DESKTOP_ENVIRONMENT DISTRIBUTION DISTRIBUTION_TYPE PACKAGE_VARIANT COMP_TYPE KERNEL_ARCH KERNEL_TYPE LIVEKITNAME SYSTEMNAME DISTRIBUTION_ARCH MODULE USER_NAME
    export OUTPUT LOGPATH BUILD_TEST_ISO CREATE_BACKUP DEBIAN_FRONTEND_TYPE APT_CMD APT_OPTIONS DESKTOP_ENVIRONMENT DISTRIBUTION DISTRIBUTION_TYPE PACKAGE_VARIANT COMP_TYPE KERNEL_ARCH KERNEL_TYPE LIVEKITNAME SYSTEMNAME DISTRIBUTION_ARCH MODULE USER_NAME
    set -u
}

function chroot_run() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."
    add_chroot_configuration_files $1
    chroot $1 /bin/bash <<EOF
. /functions
read_config /$LIVEKITNAME.conf OUTPUT LOGPATH BUILD_TEST_ISO CREATE_BACKUP DEBIAN_FRONTEND_TYPE APT_CMD APT_OPTIONS DESKTOP_ENVIRONMENT DISTRIBUTION DISTRIBUTION_TYPE PACKAGE_VARIANT COMP_TYPE KERNEL_ARCH KERNEL_TYPE LIVEKITNAME SYSTEMNAME DISTRIBUTION_ARCH MODULE USER_NAME
export OUTPUT LOGPATH BUILD_TEST_ISO CREATE_BACKUP DEBIAN_FRONTEND_TYPE APT_CMD APT_OPTIONS DESKTOP_ENVIRONMENT DISTRIBUTION DISTRIBUTION_TYPE PACKAGE_VARIANT COMP_TYPE KERNEL_ARCH KERNEL_TYPE LIVEKITNAME SYSTEMNAME DISTRIBUTION_ARCH MODULE USER_NAME
${@:2}
EOF
    remove_chroot_configuration_files $1
}

# Unzip gzipped files (man pages), so LZMA can compress 2times better.
# First we fix symlinks, then uncompress files
# $1 = search directory
uncompress_files() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."
    local LINK LINE

    find "$1" -type l -name "*.gz" | while read LINE; do
        LINK="$(readlink "$LINE" | sed -r 's/.gz$//')"
        FILE="$(echo "$LINE" | sed -r 's/.gz$//')"
        ln -sfn "$LINK" "$FILE"
        rm -f "$LINE"
    done
    find "$1" -type f -name "*.gz" | xargs -r gunzip
}

# remove broken links
# $1 = search directory
remove_broken_links() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."
    find "$1" -type l -exec test ! -e {} \; -print | xargs rm -vf
}

# =================================================================
# Installing the base system
# Установка базовой системы
# =================================================================

function build_bootstrap() {
    current_process

    if [ $CONTAINER_TYPE = "1" ]; then
        if [ ! -f /.minios-live ]; then
            setup_host
        fi
    fi
    if [ $USE_ROOTFS = "true" ] && [ ! -f $SCRIPT_DIR/rootfs/$DISTRIBUTION-$DISTRIBUTION_ARCH-rootfs.tar.gz ]; then
        if [ -f $SCRIPT_DIR/rootfs/$DISTRIBUTION-$DISTRIBUTION_ARCH.tar.gz ]; then
            if [ ! -d $INSTALL_DIR ]; then
                mkdir -p $INSTALL_DIR
            fi
            tar -xzf $SCRIPT_DIR/rootfs/$DISTRIBUTION-$DISTRIBUTION_ARCH.tar.gz -C $INSTALL_DIR
        else
            if [ $DISTRIBUTION = "orel" ]; then
                sudo DEBIAN_FRONTEND=$DEBIAN_FRONTEND_TYPE \
                    debootstrap --keyring $SCRIPT_DIR/linux-live/basesystem/gpg/astra-archive.gpg --arch=$DISTRIBUTION_ARCH $DISTRIBUTION $INSTALL_DIR $DISTRIBUTION_URL >>$OUTPUT 2>>$OUTPUT
            else
                sudo DEBIAN_FRONTEND=$DEBIAN_FRONTEND_TYPE \
                    debootstrap --arch=$DISTRIBUTION_ARCH $DISTRIBUTION $INSTALL_DIR $DISTRIBUTION_URL >>$OUTPUT 2>>$OUTPUT
            fi
            #sudo DEBIAN_FRONTEND=$DEBIAN_FRONTEND_TYPE \
            #    debootstrap --arch=$DISTRIBUTION_ARCH --variant=$DISTRIBUTION_VARIANT $DISTRIBUTION $INSTALL_DIR $DISTRIBUTION_URL >>$OUTPUT 2>>$OUTPUT
            if [ ! -d $SCRIPT_DIR/rootfs ]; then
                mkdir -p $SCRIPT_DIR/rootfs
            fi
            tar -czf $SCRIPT_DIR/rootfs/$DISTRIBUTION-$DISTRIBUTION_ARCH.tar.gz -C $INSTALL_DIR .
        fi
    elif [ $USE_ROOTFS = "true" ] && [ -f $SCRIPT_DIR/rootfs/$DISTRIBUTION-$DISTRIBUTION_ARCH-rootfs.tar.gz ]; then
        if [ ! -d $INSTALL_DIR ]; then
            mkdir -p $INSTALL_DIR
        fi
        tar -xzf $SCRIPT_DIR/rootfs/$DISTRIBUTION-$DISTRIBUTION_ARCH-rootfs.tar.gz -C $INSTALL_DIR
    elif [ $USE_ROOTFS != "true" ] && [ $USE_BOOTSTRAP = "true" ]; then
        if [ -f $SCRIPT_DIR/rootfs/$DISTRIBUTION-$DISTRIBUTION_ARCH.tar.gz ]; then
            if [ ! -d $INSTALL_DIR ]; then
                mkdir -p $INSTALL_DIR
            fi
            tar -xzf $SCRIPT_DIR/rootfs/$DISTRIBUTION-$DISTRIBUTION_ARCH.tar.gz -C $INSTALL_DIR
        else
            if [ $DISTRIBUTION = "orel" ]; then
                sudo DEBIAN_FRONTEND=$DEBIAN_FRONTEND_TYPE \
                    debootstrap --keyring $SCRIPT_DIR/linux-live/basesystem/gpg/astra-archive.gpg --arch=$DISTRIBUTION_ARCH $DISTRIBUTION $INSTALL_DIR $DISTRIBUTION_URL >>$OUTPUT 2>>$OUTPUT
            else
                sudo DEBIAN_FRONTEND=$DEBIAN_FRONTEND_TYPE \
                    debootstrap --arch=$DISTRIBUTION_ARCH $DISTRIBUTION $INSTALL_DIR $DISTRIBUTION_URL >>$OUTPUT 2>>$OUTPUT
            fi
            if [ ! -d $SCRIPT_DIR/rootfs ]; then
                mkdir -p $SCRIPT_DIR/rootfs
            fi
            tar -czf $SCRIPT_DIR/rootfs/$DISTRIBUTION-$DISTRIBUTION_ARCH.tar.gz -C $INSTALL_DIR .
        fi
    else
        if [ $DISTRIBUTION = "orel" ]; then
            sudo DEBIAN_FRONTEND=$DEBIAN_FRONTEND_TYPE \
                debootstrap --keyring $SCRIPT_DIR/linux-live/basesystem/gpg/astra-archive.gpg --arch=$DISTRIBUTION_ARCH $DISTRIBUTION $INSTALL_DIR $DISTRIBUTION_URL >>$OUTPUT 2>>$OUTPUT
        else
            sudo DEBIAN_FRONTEND=$DEBIAN_FRONTEND_TYPE \
                debootstrap --arch=$DISTRIBUTION_ARCH $DISTRIBUTION $INSTALL_DIR $DISTRIBUTION_URL >>$OUTPUT 2>>$OUTPUT
        fi
    fi

    build_rootfs

}

function build_rootfs() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."
    #current_process

    if [ $USE_ROOTFS = "true" ]; then
        if [ ! -f $SCRIPT_DIR/rootfs/$DISTRIBUTION-$DISTRIBUTION_ARCH-rootfs.tar.gz ]; then
            if [ $CONTAINER_TYPE = "1" ]; then
                if [ ! -f /.minios-live ]; then
                    setup_host
                fi
            fi

            chroot_mount_fs

            cat <<'EOF' >$INSTALL_DIR/etc/apt/apt.conf.d/000MiniOS
APT::Install-Recommends "0";
APT::Install-Suggests "0";
Acquire::Languages { "none"; }
EOF

            if [ $DISTRIBUTION = "kali-rolling" ]; then
                DISTRIBUTION="testing"
                create_apt_list
                cp -f $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION.list $INSTALL_DIR/etc/apt/sources.list
                if [ -f /.minios-live-container ]; then
                    if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
                        chroot_run $INSTALL_DIR $APT_CMD update $APT_OPTIONS
                        chroot_run $INSTALL_DIR $APT_CMD install $APT_OPTIONS gnupg
                        chroot_run $INSTALL_DIR apt-key adv --keyserver keyserver.ubuntu.com --recv-keys ED444FF07D8D0BF6
                    else
                        chroot_run $INSTALL_DIR $APT_CMD update $APT_OPTIONS >>$OUTPUT 2>&1
                        chroot_run $INSTALL_DIR $APT_CMD install $APT_OPTIONS gnupg >>$OUTPUT 2>&1
                        chroot_run $INSTALL_DIR apt-key adv --keyserver keyserver.ubuntu.com --recv-keys ED444FF07D8D0BF6 >>$OUTPUT 2>&1
                    fi
                else
                    chroot $INSTALL_DIR $APT_CMD update $APT_OPTIONS >>$OUTPUT 2>&1
                    chroot $INSTALL_DIR $APT_CMD install $APT_OPTIONS gnupg >>$OUTPUT 2>&1
                    chroot $INSTALL_DIR apt-key adv --keyserver keyserver.ubuntu.com --recv-keys ED444FF07D8D0BF6 >>$OUTPUT 2>&1
                fi
                DISTRIBUTION="kali-rolling"
            fi

            create_apt_list

            cp -f $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION.list $INSTALL_DIR/etc/apt/sources.list

            if [ -f /.minios-live-container ]; then
                if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
                    chroot_run $INSTALL_DIR $APT_CMD update $APT_OPTIONS
                else
                    chroot_run $INSTALL_DIR $APT_CMD update $APT_OPTIONS >>$OUTPUT 2>&1
                fi
            else
                chroot $INSTALL_DIR $APT_CMD update $APT_OPTIONS >>$OUTPUT 2>&1
            fi

            if [ -f /.minios-live-container ]; then
                if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
                    chroot_run $INSTALL_DIR $APT_CMD upgrade $APT_OPTIONS
                else
                    chroot_run $INSTALL_DIR $APT_CMD upgrade $APT_OPTIONS >>$OUTPUT 2>&1
                fi
            else
                chroot $INSTALL_DIR $APT_CMD upgrade $APT_OPTIONS >>$OUTPUT 2>&1
            fi

            if [ -f $SCRIPT_DIR/linux-live/pkglists/prereq.list ]; then
                if [ -f /.minios-live-container ]; then
                    if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
                        chroot_run $INSTALL_DIR $APT_CMD install $APT_OPTIONS \
                            $(grep -vE "^\s*#" $SCRIPT_DIR/linux-live/pkglists/prereq.list | tr "\n" " ")
                    else
                        chroot_run $INSTALL_DIR $APT_CMD install $APT_OPTIONS \
                            $(grep -vE "^\s*#" $SCRIPT_DIR/linux-live/pkglists/prereq.list | tr "\n" " ") >>$OUTPUT 2>&1
                    fi
                else
                    chroot $INSTALL_DIR $APT_CMD install $APT_OPTIONS \
                        $(grep -vE "^\s*#" $SCRIPT_DIR/linux-live/pkglists/prereq.list | tr "\n" " ") >>$OUTPUT 2>&1
                fi
            fi

            if [ -f /.minios-live-container ]; then
                if [ -f /.minios-live-container ]; then
                    chroot_run $INSTALL_DIR $APT_CMD clean $APT_OPTIONS
                else
                    chroot_run $INSTALL_DIR $APT_CMD clean $APT_OPTIONS >>$OUTPUT 2>&1
                fi
            else
                chroot $INSTALL_DIR $APT_CMD clean $APT_OPTIONS >>$OUTPUT 2>&1
            fi
            chroot_umount_fs

            tar -czf $SCRIPT_DIR/rootfs/$DISTRIBUTION-$DISTRIBUTION_ARCH-rootfs.tar.gz -C $INSTALL_DIR .
        fi
    fi
}

# =================================================================
#
#
# =================================================================
function copy_build_scripts() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."
    if [ ! -d $INSTALL_DIR/linux-live ]; then
        mkdir -p $INSTALL_DIR/linux-live
        (cd $SCRIPT_DIR/linux-live && cp --parents -afr * $INSTALL_DIR/linux-live)
    else
        find $SCRIPT_DIR/linux-live -type f -not -path "*.git/*" -print0 | sed "s,$SCRIPT_DIR/linux-live/,,g" | while IFS= read -r -d '' file; do
            if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
                if ! cmp $SCRIPT_DIR/linux-live/"$file" $INSTALL_DIR/linux-live/"$file"; then
                    echo -e "$file has been modified since last build run."
                    echo -e "Copying $SCRIPT_DIR/linux-live/$file to $INSTALL_DIR/linux-live/$file..."
                    cp -f $SCRIPT_DIR/linux-live/"$file" $INSTALL_DIR/linux-live/"$file"
                fi
            else
                if ! cmp $SCRIPT_DIR/linux-live/"$file" $INSTALL_DIR/linux-live/"$file" >>$OUTPUT 2>&1; then
                    echo -e "$file has been modified since last build run." >>$OUTPUT 2>&1
                    echo -e "Copying $SCRIPT_DIR/linux-live/$file to $INSTALL_DIR/linux-live/$file..." >>$OUTPUT 2>&1
                    cp -f $SCRIPT_DIR/linux-live/"$file" $INSTALL_DIR/linux-live/"$file" >>$OUTPUT 2>&1
                fi
            fi
        done
    fi

    #chmod +x $INSTALL_DIR/linux-live/build
    chmod +x $INSTALL_DIR/linux-live/install_chroot

    if [ "$DEV_SYSTEM" = "true" ]; then
        if [ ! -d $INSTALL_DIR/opt/minios-live ]; then
            mkdir -p $INSTALL_DIR/opt/minios-live
            (cd $SCRIPT_DIR && cp --parents -afr * $INSTALL_DIR/opt/minios-live)
        else
            find $SCRIPT_DIR/linux-live -type f -print0 | sed "s,$SCRIPT_DIR/linux-live/,,g" | while IFS= read -r -d '' file; do
                if ! cmp $SCRIPT_DIR/"$file" $INSTALL_DIR/opt/minios-live/"$file" >>$OUTPUT 2>&1; then
                    echo -e "$file has been modified since last build run." >>$OUTPUT 2>&1
                    echo -e "Copying $SCRIPT_DIR/$file to $INSTALL_DIR/opt/minios-live/$file..." >>$OUTPUT 2>&1
                    cp -f $SCRIPT_DIR/"$file" $INSTALL_DIR/opt/minios-live/"$file" >>$OUTPUT 2>&1
                fi
            done
        fi
    elif [ $DOWNLOAD_SOURCES = "true" ]; then
        if [ ! -d $INSTALL_DIR/opt/minios-live ]; then
            mkdir -p $INSTALL_DIR/opt
            cd $INSTALL_DIR/opt
            git clone --depth=1 https://github.com/minios-linux/minios-live.git >>$OUTPUT 2>&1
            if [ -d $INSTALL_DIR/opt/minios-live/.git ]; then
                rm -rf $INSTALL_DIR/opt/minios-live/.git >>$OUTPUT 2>&1
            fi
            if [ -f $INSTALL_DIR/opt/minios-live/.gitignore ]; then
                rm -f $INSTALL_DIR/opt/minios-live/.gitignore >>$OUTPUT 2>&1
            fi
        fi
    fi

    if [ -d $INSTALL_DIR/opt/minios-live/.git ]; then
        rm -rf $INSTALL_DIR/opt/minios-live/.git >>$OUTPUT 2>&1
    fi
    if [ -f $INSTALL_DIR/opt/minios-live/.gitignore ]; then
        rm -f $INSTALL_DIR/opt/minios-live/.gitignore >>$OUTPUT 2>&1
    fi

}

# =================================================================
#
#
# =================================================================
function build_chroot() {
    current_process

    if [ $CONTAINER_TYPE = "1" ]; then
        if [ ! -f /.minios-live ]; then
            setup_host
        fi
    fi

    chroot_mount_fs

    copy_build_scripts

    create_apt_list

    if [ "$OUTPUT"="$LOGPATH/$LIVEKITNAME.log" ] && [ -f /$LIVEKITNAME.log ]; then
        mv -f /$LIVEKITNAME.log $INSTALL_DIR/$LIVEKITNAME.log
    fi
    if [ "$OUTPUT"="$LOGPATH/$LIVEKITNAME.log" ] && [ -f $INSTALL_DIR/$LIVEKITNAME.log ]; then
        echo "===========================================" >>$INSTALL_DIR/$LIVEKITNAME.log 2>&1
        echo "===========================================" >>$INSTALL_DIR/$LIVEKITNAME.log 2>&1
        echo "=============== CHROOT LOG ================" >>$INSTALL_DIR/$LIVEKITNAME.log 2>&1
        echo "===========================================" >>$INSTALL_DIR/$LIVEKITNAME.log 2>&1
        echo "===========================================" >>$INSTALL_DIR/$LIVEKITNAME.log 2>&1
    fi

    cp -f $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION.list $INSTALL_DIR/etc/apt/sources.list

    if [ $DISTRIBUTION = "orel" ]; then
        cp -f $SCRIPT_DIR/linux-live/aptsources/stretch.list $INSTALL_DIR/etc/apt/sources.list.d/stretch.list
    fi

    if [ -f /.minios-live-container ]; then
        chroot_run $INSTALL_DIR /linux-live/install_chroot -
    else
        chroot $INSTALL_DIR /linux-live/install_chroot -
    fi

    chroot_umount_fs

    if [ "$OUTPUT"="$LOGPATH/$LIVEKITNAME.log" ] && [ -f $INSTALL_DIR/$LIVEKITNAME.log ]; then
        mv -f $INSTALL_DIR/$LIVEKITNAME.log $SCRIPT_DIR/$LIVEKITNAME.log
        if [ -f $SCRIPT_DIR/$LIVEKITNAME.log ]; then
            echo -e "Installation log was saved to ${MAGENTA}$SCRIPT_DIR/$LIVEKITNAME.log${ENDCOLOUR}"
        fi
    fi
}

# =================================================================
#
#
# =================================================================
function build_live() {
    current_process

    if [ $CONTAINER_TYPE = "1" ]; then
        if [ ! -f /.minios-live ]; then
            setup_host
        fi
    fi

    remove_log_file

    copy_build_scripts

    check_install_dir

    rm -rf $WORK_DIR/image
    mkdir -p $WORK_DIR/image/$LIVEKITNAME/{boot,changes,modules}

    build_boot

    if [ $DISTRIBUTION_ARCH = "i386" ]; then
        MKMOD="bin etc home lib opt root sbin srv usr var"
    fi

    # create compressed 01-core.sb
    cd $INSTALL_DIR
    COREFS=""
    for i in $MKMOD; do
        if [ -d /$i ]; then
            COREFS="$COREFS $i"
        fi
    done

    mksquashfs $COREFS $WORK_DIR/image/$LIVEKITNAME/01-core-$COMP_TYPE.$BEXT -comp $COMP_TYPE -b 1024K -always-use-fragments -keep-as-directory -noappend || exit

}

# =================================================================
#
#
# =================================================================
function build_boot() {
    #current_process
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."

    if [ $CONTAINER_TYPE = "1" ]; then
        if [ ! -f /.minios-live ]; then
            setup_host
        fi
    fi

    copy_build_scripts

    check_install_dir

    # initramfs generation
    chroot $INSTALL_DIR mount none -t proc /proc
    chmod +x $INSTALL_DIR/linux-live/initrfs
    chroot $INSTALL_DIR /linux-live/initrfs
    chroot $INSTALL_DIR umount /proc

    # copy boot files
    cp $INSTALL_DIR/boot/vmlinuz-**-**-* $WORK_DIR/image/$LIVEKITNAME/boot/vmlinuz
    cp $INSTALL_DIR/boot/initrfs.img $WORK_DIR/image/$LIVEKITNAME/boot/initrfs.img

    #if [ $CLOUD != "true" ]; then
    cp -r $SCRIPT_DIR/linux-live/bootfiles/* $WORK_DIR/image/$LIVEKITNAME
    #fi

    if [ $DESKTOP_ENVIRONMENT = "cloud" ]; then
        BOOT_TYPE="hybrid"
    fi
    if [ $BOOT_TYPE = "hybrid" ]; then
        cp -r $SCRIPT_DIR/linux-live/bootfiles-grub/* $WORK_DIR/image
        mkdir $WORK_DIR/image/$LIVEKITNAME/boot/grub
        cp -r $SCRIPT_DIR/linux-live/bootfiles-grub/* $WORK_DIR/image/$LIVEKITNAME/boot/grub
        if [ ! -d $WORK_DIR/image/.disk ]; then
            mkdir -p $WORK_DIR/image/.disk
        fi
        echo $SYSTEMNAME >$WORK_DIR/image/.disk/info
    fi

    cat <<EOF >$WORK_DIR/image/README
################################### README ####################################
* To install MiniOS, copy the contents of the ISO to the root of the media,
  then run minios\boot\bootinst.bat on Windows, or minios/boot/bootinst.sh
  on Linux.
* When installed on media with fat32 and ntfs file systems, changes in
  persistent changes mode will be saved in the minios\changes\changes.dat file,
  the file expands dynamically, the maximum file size is 4 GB (can be changed
  with the changes_size parameter in the boot options, for example
  changes_size=2000 will set the maximum file size to 2 GB).
* When installed on media with ext2-ext4, xfs, btrfs file systems, changes in
  the persistent changes mode will be saved in the minios\changes folder with
  no size limit.
###############################################################################
EOF

    if [ $DESKTOP_ENVIRONMENT = "cloud" ] || [ $DESKTOP_ENVIRONMENT = "mediaplayer" ]; then
        cat <<'EOF' | iconv -f 'UTF-8' -t "CP866//TRANSLIT" >$WORK_DIR/image/minios/boot/syslinux.cfg
UI /minios/boot/vesamenu.c32

PROMPT 0
TIMEOUT 40

MENU CLEAR
MENU HIDDEN
MENU HIDDENKEY Enter default
MENU BACKGROUND /minios/boot/bootlogo.png

MENU WIDTH 80
MENU MARGIN 20
MENU ROWS 5
MENU TABMSGROW 9
MENU CMDLINEROW 9
MENU HSHIFT 0
MENU VSHIFT 19

MENU COLOR BORDER  30;40      #00000000 #00000000 none
MENU COLOR SEL     47;30      #FF000000 #FFFFFFFF none
MENU COLOR UNSEL   37;40      #FFFFFFFF #FF000000 none
MENU COLOR TABMSG  32;40      #FF60CA00 #FF000000 none

F1 help.txt /minios/boot/zblack.png

MENU AUTOBOOT Press Esc for options, automatic boot in # second{,s} ...
MENU TABMSG [F1] help                                                        [Tab] cmdline >

LABEL default
MENU LABEL Run MiniOS (Copy to RAM)
KERNEL /minios/boot/vmlinuz
APPEND vga=normal initrd=/minios/boot/initrfs.img load_ramdisk=1 prompt_ramdisk=0 rw printk.time=0 consoleblank=0 apparmor=0 selinux=0 minios.flags=toram net.ifnames=0 biosdevname=0 ssh

EOF
        cat <<'EOF' >$WORK_DIR/image/boot/grub/grub.cfg
set default="0"
set timeout="4"
set hidden_timeout_quiet=false
set gfxmode=auto
insmod efi_gop
insmod efi_uga
insmod gfxterm
terminal_output gfxterm
set color_normal=white/black
set color_highlight=black/white
loadfont /boot/grub/unicode.pf2
#background_image /boot/grub/bootlogo.png

set default_settings="load_ramdisk=1 prompt_ramdisk=0 rw printk.time=0 consoleblank=0 apparmor=0 net.ifnames=0 biosdevname=0 ssh"
set perch_settings="minios.flags=perch"
set live_settings="minios.flags= "
set ram_settings="minios.flags=toram"
set console_settings="console=tty0 console=ttyS0,115200"
set debug_settings="load_ramdisk=1 prompt_ramdisk=0 rw printk.time=0 apparmor=0 debug net.ifnames=0 biosdevname=0 ssh"
set linux_64="/minios/boot/vmlinuz"
set initrd_img="/minios/boot/initrfs.img"
set default=0
set message="Loading kernel and ramdisk..."

menuentry "Run MiniOS (Copy to RAM)"{
    echo $message
    search --set -f $linux_64
    linux $linux_64 $default_settings $ram_settings $console_settings
    initrd $initrd_img
}
EOF
    fi
    if [ $DESKTOP_ENVIRONMENT = "mediaplayer" ]; then
        sed -i "s/ssh/ssh hide_credentials quiet/g" $WORK_DIR/image/minios/boot/syslinux.cfg
        sed -i "s/ssh/ssh hide_credentials quiet/g" $WORK_DIR/image/boot/grub/grub.cfg
    fi

    if [ $PACKAGE_VARIANT = "minimum" ]; then
        sed -i 's/minios.flags=perch/minios.flags=perch,automount/g' $WORK_DIR/image/$LIVEKITNAME/boot/syslinux.cfg
        sed -i 's/minios.flags= /minios.flags=automount /g' $WORK_DIR/image/$LIVEKITNAME/boot/syslinux.cfg
        if [[ $DESKTOP_ENVIRONMENT =~ "slax" ]]; then
            sed -i 's/quiet/quiet user_name=root/g' $WORK_DIR/image/$LIVEKITNAME/boot/syslinux.cfg
        fi
        if [ $BOOT_TYPE = "hybrid" ]; then
            sed -i 's/minios.flags=perch/minios.flags=perch,automount/g' $WORK_DIR/image/boot/grub/grub.cfg
            sed -i 's/minios.flags= /minios.flags=automount /g' $WORK_DIR/image/boot/grub/grub.cfg
            if [[ $DESKTOP_ENVIRONMENT =~ "slax" ]]; then
                sed -i 's/quiet/quiet user_name=root/g' $WORK_DIR/image/boot/grub/grub.cfg
            fi
        fi
    fi

}
# =================================================================
#
#
# =================================================================
function build_iso() {
    current_process

    if [ $CONTAINER_TYPE = "1" ]; then
        if [ ! -f /.minios-live ]; then
            setup_host
        fi
    fi

    check_install_dir

    if [ "$UNATTENDED" = "true" ]; then
        INSTALL_DIR="$WORK_DIR/basesystem"
    fi
    if [ "$INSTALL_DIR" = "" ]; then
        LAST_INSTALL_DIR=$(cat "$SCRIPT_DIR/.install_dir") >>$OUTPUT 2>&1
        INSTALL_DIR=$LAST_INSTALL_DIR
    fi

    cd $WORK_DIR/image
    if [ ! -d $ISO_DIR ]; then
        mkdir -p $ISO_DIR
    fi

    mkdir -p $ISO_DIR >>$OUTPUT 2>&1
    #VER=$SYSTEMVER
    DATE=$(date +%Y%m%d_%H%M)

    DIR=$WORK_DIR/image

    ISO=$ISO_DIR/$LIVEKITNAME-$DISTRIBUTION-$DESKTOP_ENVIRONMENT-$PACKAGE_VARIANT-$DISTRIBUTION_ARCH-$COMP_TYPE-$DATE.iso

    B="-b $LIVEKITNAME/boot/isolinux.bin -c $LIVEKITNAME/boot/isolinux.boot"

    if [ $BOOT_TYPE = "hybrid" ]; then
        C="-no-emul-boot -boot-load-size 4 -boot-info-table -eltorito-alt-boot"
    else
        C="-no-emul-boot -boot-load-size 4 -boot-info-table"
    fi

    # ▼ должно быть только перенаправление ошибки!

    if [ -x "$(which xorriso 2>>$OUTPUT)" ] && [ $BOOT_TYPE = "hybrid" ]; then
        M="xorriso -as mkisofs -isohybrid-mbr $DIR/$LIVEKITNAME/boot/isohdpfx.bin"
        D=" -isohybrid-gpt-basdat -e"
    elif [ -x "$(which genisoimage 2>>$OUTPUT)" ]; then
        M=genisoimage
        if [ $BOOT_TYPE = "hybrid" ]; then
            D="-efi-boot"
        else
            D=""
        fi
    fi
    if [ $BOOT_TYPE = "hybrid" ]; then
        E="EFI/boot/efiboot.img -no-emul-boot"
    else
        E=""
    fi

    #VER="$SYSTEMNAME $VER"
    VER="$SYSTEMNAME"

    if [ $REMOVE_OLD_ISO = "true" ]; then
        set +e
        rm $ISO_DIR/$LIVEKITNAME-$DISTRIBUTION-$DESKTOP_ENVIRONMENT-$PACKAGE_VARIANT-$DISTRIBUTION_ARCH-$COMP_TYPE-*.iso >>$OUTPUT 2>&1
        while [ -f $ISO_DIR/$LIVEKITNAME.iso ]; do
            rm $ISO_DIR/$LIVEKITNAME.iso >>$OUTPUT 2>&1
            sleep 1
        done
        set -e
        #rm -f $ISO_DIR/*
    fi

    if [ $BOOT_TYPE = "hybrid" ]; then
        if
            ! $M -hide-rr-moved -f -r -J -l -V "$VER" -A "$VER" \
                $B $C $D $E -o $ISO $DIR
        then
            exit 1
        fi
    else
        if
            ! $M -f -r -J -l -V "$VER" -A "$VER" \
                $B $C $D $E -o $ISO $DIR
        then
            exit 1
        fi
    fi

    echo ">>> $ISO created"

    if [ $BUILD_TEST_ISO = "true" ]; then
        if [ -L $ISO_DIR/$LIVEKITNAME.iso ]; then
            rm $ISO_DIR/$LIVEKITNAME.iso
        fi
        while [ -f $ISO_DIR/$LIVEKITNAME.iso ]; do
            rm $ISO_DIR/$LIVEKITNAME.iso >>$OUTPUT 2>&1
            sleep 1
        done
        if ln $ISO_DIR/$LIVEKITNAME-$DISTRIBUTION-$DESKTOP_ENVIRONMENT-$PACKAGE_VARIANT-$DISTRIBUTION_ARCH-$COMP_TYPE-$DATE.iso $ISO_DIR/$LIVEKITNAME.iso; then
            echo ">>> $ISO_DIR/$LIVEKITNAME.iso created"
        fi
    fi

    #exit 0
}

function remove_sources() {
    if [ $REMOVE_SOURCES = "true" ]; then
        cleanup
    fi
    exit 0
}

# =================================================================
# =================================================================
# ====================== INSTALL FUNCTIONS ========================
# =================================================================
# =================================================================

# =================================================================
#
#
# =================================================================
function setup_host() {
    if [ $SKIP_SETUP_HOST != "true" ]; then
        current_process

        if [ $CONTAINER_TYPE != "2" ]; then
            hostreq_pkg_list
        fi
    fi
}

# =================================================================
#
#
# =================================================================
function chroot_setup_host() {
    current_process

    echo $LIVEKITNAME >/etc/hostname

    install_prerequesited_packages

    #configure machine id
    dbus-uuidgen >/etc/machine-id >>$OUTPUT 2>&1
    ln -fs /etc/machine-id /var/lib/dbus/machine-id >>$OUTPUT 2>&1

    # don't understand why, but multiple sources indicate this
    dpkg-divert --local --rename --add /sbin/initctl >>$OUTPUT 2>&1
    ln -s /bin/true /sbin/initctl >>$OUTPUT 2>&1

    current_process
}

# =================================================================
#
#
# =================================================================
function chroot_cleanup() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."

    set +eu

    rm -f $1/$LIVEKITNAME.conf
    rm -f $1/functions
    rm -f $1/preinstall
    rm -f $1/install
    rm -f $1/install2
    rm -f $1/cleanup
    rm -f $1/$PACKAGE_VARIANT.list
    rm -f $1/postinstall
    rm -rf $1/rootcopy-install
    rm -rf $1/rootcopy
    rm -rf $1/patches

    rm -f $1/etc/fstab
    rm -f $1/etc/mtab
    rm -f $1/etc/apt/sources.list~
    rm -Rf $1/etc/systemd/system/timers.target.wants
    rm -f $1/etc/systemd/system/multi-user.target.wants/ssh.service
    rm -f $1/etc/systemd/system/multi-user.target.wants/dnsmasq.service

    rm -f $1/etc/ssh/ssh_host*

    rm -f $1/var/backups/*
    rm -f $1/var/cache/ldconfig/*
    rm -f $1/var/cache/debconf/*
    rm -f $1/var/cache/fontconfig/*
    rm -f $1/var/lib/apt/extended_states
    rm -f $1/var/lib/systemd/random-seed
    rm -f $1/var/lib/apt/lists/deb.*
    rm -Rf $1/root/.local/share/mc
    rm -Rf $1/root/.cache
    rm -f $1/root/.wget-hsts

    rm -f $1/var/lib/dpkg/*-old
    rm -f $1/var/log/*
    rm -f $1/var/log/*/*
    rm -f $1/var/log/*/*/*
    rm -f $1/var/cache/apt/archives/*.deb
    rm -f $1/var/cache/apt/*.bin
    rm -f $1/var/cache/debconf/*-old
    rm -f $1/var/lib/dhcp/dhclient.leases
    rm -f $1/root/.bash_history
    rm -f $1/root/.wget-hsts
    rm -Rf $1/usr/share/doc/*
    rm -Rf $1/usr/share/info/*
    rm -f $1/usr/share/images/fluxbox/debian-squared.jpg
    rm -Rf $1/usr/share/fluxbox/nls/??*
    rm -Rf $1/usr/share/gnome/help

    rm -Rf $1/usr/share/locale/??
    rm -Rf $1/usr/share/locale/??_*
    rm -Rf $1/usr/share/locale/??@*
    rm -Rf $1/usr/share/locale/???
    rm -Rf $1/usr/share/i18n/locales/*_*
    rm -Rf $1/usr/share/man/??
    rm -Rf $1/usr/share/man/*_*

    rm -Rf $1/usr/share/icons/elementaryXubuntu-dark
    rm -Rf $1/usr/share/icons/gnome/256x256

    rm $1/usr/share/applications/compton.desktop
    rm $1/usr/share/applications/debian-uxterm.desktop
    rm $1/usr/share/applications/debian-xterm.desktop
    rm $1/usr/share/applications/htop.desktop
    rm $1/usr/share/applications/mc.desktop
    rm $1/usr/share/applications/mcedit.desktop
    rm $1/usr/share/applications/pcmanfm-desktop-pref.desktop
    rm $1/usr/share/applications/python2.7.desktop
    rm $1/usr/share/applications/python3.7.desktop
    rm $1/usr/share/applications/vim.desktop

    if [ -z $1 ]; then
        uncompress_files $1/etc/alternatives
        uncompress_files $1/usr/share/man

        remove_broken_links $1/etc/alternatives
        remove_broken_links $1/usr/share/man
    fi

    set -eu
}

# =================================================================
#
#
# =================================================================
function hostreq_pkg_list() {
    echo -e "${YELLOW}=====> installing required software for host system ...${ENDCOLOUR}"
    $APT_CMD update >>$OUTPUT 2>&1

    if [ -f $SCRIPT_DIR/linux-live/pkglists/hostreq.list ]; then
        $APT_CMD install -y \
            $(grep -vE "^\s*#" $SCRIPT_DIR/linux-live/pkglists/hostreq.list | tr "\n" " ") >>$OUTPUT 2>&1
    else
        $APT_CMD install -y \
            sudo debootstrap genisoimage >>$OUTPUT 2>&1
    fi
    if [ $DISTRIBUTION_ARCH = "arm64" ]; then
        $APT_CMD install -y \
            grub-efi-arm64-bin >>$OUTPUT 2>&1
    else
        $APT_CMD install -y \
            grub-efi-amd64-bin grub-pc-bin >>$OUTPUT 2>&1
    fi
}

# =================================================================
#
#
# =================================================================
function install_prerequesited_packages() {
    echo -e "${YELLOW}=====> installing prerequested software for chroot system ...${ENDCOLOUR}"

    if [ ! -f /etc/apt/apt.conf.d/000MiniOS ]; then
        cat <<'EOF' >/etc/apt/apt.conf.d/000MiniOS
APT::Install-Recommends "0";
APT::Install-Suggests "0";
Acquire::Languages { "none"; }
EOF
    fi
    if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
        if [ -f $SCRIPT_DIR/pkglists/prereq.list ]; then
            $APT_CMD update
            echo -e "${YELLOW}=====> upgrading chroot system ...${ENDCOLOUR}" &&
                $APT_CMD upgrade $APT_OPTIONS >>$OUTPUT 2>&1 &&
                echo -e "${YELLOW}=====> installing packages ...${ENDCOLOUR}" &&
                $APT_CMD install $APT_OPTIONS \
                    $(grep -vE "^\s*#" $SCRIPT_DIR/pkglists/prereq.list | tr "\n" " ")
        fi
    else
        if [ -f $SCRIPT_DIR/pkglists/prereq.list ]; then
            $APT_CMD update >>$OUTPUT 2>&1 &&
                echo -e "${YELLOW}=====> upgrading chroot system ...${ENDCOLOUR}" &&
                $APT_CMD upgrade $APT_OPTIONS >>$OUTPUT 2>&1 &&
                echo -e "${YELLOW}=====> installing packages ...${ENDCOLOUR}" &&
                $APT_CMD install $APT_OPTIONS \
                    $(grep -vE "^\s*#" $SCRIPT_DIR/pkglists/prereq.list | tr "\n" " ") >>$OUTPUT 2>&1
        fi
    fi

}

# =================================================================
#
#
# =================================================================
function install_core_packages() {
    echo -e "${YELLOW}=====> installing main packages for chroot system ...${ENDCOLOUR}"

    get_vars

    if [ -f /linux-live/basesystem/01-core/preinstall ]; then
        chmod +x /linux-live/basesystem/01-core/preinstall
        /linux-live/basesystem/01-core/preinstall
    fi
    : 'if [ "$(ls -A /linux-live/basesystem/01-core/rootcopy-install)" != "" ]; then
        (cd /linux-live/basesystem/01-core/rootcopy-install && cp --parents -afr * /)
    fi'
    if [ -f /linux-live/basesystem/01-core/install ]; then
        chmod +x /linux-live/basesystem/01-core/install
        /linux-live/basesystem/01-core/install
    fi
    if [ -f /linux-live/basesystem/01-core/postinstall ]; then
        chmod +x /linux-live/basesystem/01-core/postinstall
        /linux-live/basesystem/01-core/postinstall
    fi

    chroot_cleanup
}

# =================================================================
#
#
# =================================================================
function build_dkms() {
    echo -e "${YELLOW}=====> building dkms packages for chroot system ...${ENDCOLOUR}"

    local LOWER_DIR MODULE_UPPER_DIR MODULE_WORK_DIR MODULE_MERGED_DIR KERNEL BUILD_DKMS

    LOWER_DIR="$WORK_DIR/basesystem"
    MODULE_UPPER_DIR="$WORK_DIR/modules/01-dkms-upper"
    MODULE_WORK_DIR="$WORK_DIR/modules/01-dkms-work"
    MODULE_MERGED_DIR="$WORK_DIR/modules/01-dkms-merged"
    BUILD_DKMS="true"

    module_check_install_dir

    module_chroot_mount_fs

    # run install script
    if [ -f $SCRIPT_DIR/linux-live/basesystem/01-dkms/install ]; then
        cp $SCRIPT_DIR/linux-live/basesystem/01-dkms/install $MODULE_MERGED_DIR/install
        chmod +x $MODULE_MERGED_DIR/install
        if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
            chroot_run $MODULE_MERGED_DIR /install
        else
            chroot_run $MODULE_MERGED_DIR /install >>$OUTPUT 2>&1
        fi
    fi

    module_chroot_umount_fs

    module_check_mounted

    if [ -f $MODULE_UPPER_DIR/livekit.conf ]; then
        read_config $MODULE_UPPER_DIR/livekit.conf KERNEL

        if [ -L $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL/build ]; then
            rm -f $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL/build
        fi
        if [ -L $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL/source ]; then
            rm -f $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL/source
        fi
        set +e
        if [ -d $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL ]; then
            (cd $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL && cp --parents -afr * /$LOWER_DIR/usr/lib/modules/$KERNEL/)
        fi
        if [ -d $MODULE_UPPER_DIR/lib/modules/$KERNEL ]; then
            (cd $MODULE_UPPER_DIR/lib/modules/$KERNEL && cp --parents -afr * /$LOWER_DIR/lib/modules/$KERNEL/)
        fi
        set -e
    fi

}

# =================================================================
#
#
# =================================================================
function chroot_pkg_install() {
    current_process

    install_core_packages

    # remove unused
    $APT_CMD autoremove $APT_OPTIONS >>$OUTPUT 2>&1

    # clean up apt cache
    $APT_CMD clean $APT_OPTIONS >>$OUTPUT 2>&1
}

# =================================================================
# Unused for now. These steps are performed when running
# installation in linux-live/basesystem/01-core/install
# =================================================================
function chroot_configure() {
    current_process

    (cd /linux-live/basesystem/01-core/rootcopy-install && cp --parents -afr * /)

    # minios-install setup
    if [ ! -d /etc/$LIVEKITNAME ]; then
        mkdir -p /etc/$LIVEKITNAME
    fi
    cat <<EOF >/etc/$LIVEKITNAME/config
#!/bin/bash
# This is a config file for MiniOS-Live build script and Linux Live Kit boot script.
# !!! You shouldn't need to change anything expect PACKAGE_VARIANT OUTPUT COMP_TYPE !!!
LIVEKITNAME="$LIVEKITNAME"
SYSTEMNAME="$SYSTEMNAME"
DISTRIBUTION_TYPE="$DISTRIBUTION_TYPE"
DISTRIBUTION="$DISTRIBUTION"
DISTRIBUTION_ARCH="$DISTRIBUTION_ARCH"
PACKAGE_VARIANT="$PACKAGE_VARIANT"
DESKTOP_ENVIRONMENT="$DESKTOP_ENVIRONMENT"
COMP_TYPE="xz" # Compression method used for the system and modules.
OUTPUT="/dev/stdout" # Default is output to /dev/stdout. You can use OUTPUT="/dev/null" if you want to silent installation or OUTPUT="somefilename.log" to route events to log file.
DEBIAN_FRONTEND_TYPE="noninteractive"
APT_CMD="apt-get"
APT_OPTIONS="-y"
UNION_BUILD_TYPE="overlayfs"
BEXT="sb"
EOF

    if [ ! -d /etc/NetworkManager ]; then
        echo "Enable dhclient.service autostart." >>$OUTPUT 2>&1
        cat <<EOF >/usr/lib/systemd/system/dhclient.service
[Unit]
Description=DHCP Client
Documentation=man:dhclient(8)
Wants=network.target
After=network-pre.target systemd-sysctl.service systemd-modules-load.service
Before=network.target shutdown.target network-online.target
ConditionPathExists=!/run/initramfs/net.up.flag

[Service]
Type=forking
ExecStart=-/bin/sh -c 'udevadm settle && dhclient -nw'
PIDFile=/run/dhclient.pid

[Install]
WantedBy=multi-user.target
WantedBy=network-online.target
EOF
        systemctl enable dhclient >>$OUTPUT 2>&1
    elif [ -d /etc/NetworkManager ] && [[ $DISTRIBUTION = "bionic" || $DISTRIBUTION = "focal" ]]; then
        if [ ! -d /etc/netplan/ ]; then
            mkdir -p /etc/netplan/
        fi
        cat <<EOF >/etc/netplan/01-netcfg.yaml
# This file describes the network interfaces available on your system
# For more information, see netplan(5).
# Set and change netplan renderer to NetworkManager GUI tool 
network:
  version: 2
  renderer: NetworkManager

EOF
        cat <<EOF >/etc/NetworkManager/NetworkManager.conf
[main]
rc-manager=resolvconf
plugins=ifupdown,keyfile
dns=dnsmasq
[ifupdown]
managed=false

EOF
    fi

    if [ -f /etc/systemd/system/multi-user.target.wants/grub-initrd-fallback.service ]; then
        echo "Disable grub-initrd-fallback.service autostart."
        systemctl disable grub-initrd-fallback.service
    fi

    if grep openssh-server $SCRIPT_DIR/basesystem/01-core/$PACKAGE_VARIANT.list >>$OUTPUT 2>&1; then
        echo "Enable ssh.service autostart." >>$OUTPUT 2>&1
        cat <<EOF >/usr/lib/systemd/system/ssh-keygen.service
[Unit]
Description=Generate sshd keys
Before=ssh.service

[Service]
Type=oneshot
ExecStart=/usr/bin/ssh-keygen -A
RemainAfterExit=true
StandardOutput=journal

[Install]
WantedBy=multi-user.target
EOF
        #if [ $CLOUD != "true" ]; then
        #    sed -i 's,#PermitRootLogin prohibit-password,PermitRootLogin yes,g' /etc/ssh/sshd_config
        #    sed -i 's,#PasswordAuthentication yes,PasswordAuthentication yes,g' /etc/ssh/sshd_config
        #fi
        #systemctl enable ssh-keygen >>$OUTPUT 2>&1
        #systemctl enable ssh >>$OUTPUT 2>&1
    fi

    if [ ! -f /usr/share/sudo ]; then
        cat <<EOF >/usr/share/sudo
#!/bin/bash
if [ "$#" -lt 1 ]; then
   echo "Usage: sudo [command] [arguments]"
   exit 1
fi

if [ "$UID" = 0 ]; then
   exec "$@"
fi

echo "Sudo is not installed. Run the command as root or install sudo."
EOF
    fi
}

# =================================================================
#
#
# =================================================================
function chroot_finish_up() {
    current_process

    # truncate machine id (why??)
    truncate -s 0 /etc/machine-id >>$OUTPUT 2>&1

    # remove diversion (why??)
    rm /sbin/initctl >>$OUTPUT 2>&1
    dpkg-divert --rename --remove /sbin/initctl >>$OUTPUT 2>&1

    # remove ssh config
    #rm -f /etc/ssh/ssh_host*

    # clean up useless stuff
    rm -rf /tmp/* ~/.bash_history >>$OUTPUT 2>&1
    rm -rf ~/.cache
    find /var/log/ -type f | xargs rm -f >>$OUTPUT 2>&1
    rm -f /etc/ssh/ssh_host*
    rm -f /var/backups/* >>$OUTPUT 2>&1
    rm -f /var/cache/ldconfig/* >>$OUTPUT 2>&1
    #rm -f /var/cache/debconf/* >>$OUTPUT 2>&1
    rm -f /var/cache/fontconfig/* >>$OUTPUT 2>&1
    rm -f /var/cache/apt/archives/*.deb >>$OUTPUT 2>&1
    rm -f /var/cache/apt/*.bin >>$OUTPUT 2>&1
    rm -f /var/cache/debconf/*-old >>$OUTPUT 2>&1
    rm -f /var/lib/apt/extended_states >>$OUTPUT 2>&1
    rm -f /var/lib/apt/lists/*Packages >>$OUTPUT 2>&1
    rm -f /var/lib/apt/lists/*Translation* >>$OUTPUT 2>&1
    rm -f /var/lib/apt/lists/*InRelease >>$OUTPUT 2>&1
    rm -f /var/lib/apt/lists/deb.* >>$OUTPUT 2>&1
    rm -f /var/lib/dpkg/*-old >>$OUTPUT 2>&1

}

# =================================================================
# =================================================================
# ======================= MODULE FUNCTIONS ========================
# =================================================================
# =================================================================

# =================================================================
#
#
# =================================================================
function module_check_mounted() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."
    if grep -qs "$MODULE_MERGED_DIR" /proc/mounts || grep -qs "$MODULE_MERGED_DIR/dev" /proc/mounts || grep -qs "$MODULE_MERGED_DIR/run" /proc/mounts || grep -qs "$MODULE_MERGED_DIR/proc" /proc/mounts || grep -qs "$MODULE_MERGED_DIR/sys" /proc/mounts || grep -qs "$MODULE_MERGED_DIR/dev/pts" /proc/mounts || grep -qs "$MODULE_MERGED_DIR/tmp" /proc/mounts; then
        echo -e "${BOLD}${LIGHTYELLOW}Сhroot contains mounted filesystems.${ENDCOLOUR}"
        if [ "$UNATTENDED" = "true" ]; then
            module_chroot_umount_fs
        else
            read -r -p "$(echo -e ""Do you want to ${GREEN}unmount them${ENDCOLOUR}? [${BOLD}${GREEN}Y${ENDCOLOUR}/n])" response
            response=${response,,}
            if [[ "$response" =~ ^(no|n)$ ]]; then
                exit 1
            else
                module_chroot_umount_fs
            fi
        fi
    fi
}

# =================================================================
#
#
# =================================================================
function module_check_install_dir() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."
    if [ "$UNATTENDED" = "true" ]; then
        #echo -e "${RED}!!!Unattended installation!!!${ENDCOLOUR}"
        echo -e "The working directory is ${MAGENTA}$MODULE_UPPER_DIR${ENDCOLOUR}."
        if [ "$(ls -A $MODULE_UPPER_DIR)" != "" ]; then
            module_cleanup
            module_check_mounted
        fi
    else
        # ▼ должно быть только перенаправление ошибки!
        if [ "$(ls -A $MODULE_UPPER_DIR)" != "" ]; then
            echo -e "${MAGENTA}$MODULE_UPPER_DIR${ENDCOLOUR} is not empty."
            module_cleanup
            module_check_mounted
            echo -e "The working directory is ${MAGENTA}$MODULE_MERGED_DIR${ENDCOLOUR}."
        else
            module_check_mounted
            echo -e "The working directory is ${MAGENTA}$MODULE_MERGED_DIR${ENDCOLOUR}."
        fi
    fi
}

# =================================================================
#
#
# =================================================================
function module_chroot_mount_fs() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."

    local MODULES MODULE_LOWER_DIR FILTER

    module_check_mounted

    if [ $SCRIPT_DIR = "/usr/bin" ]; then
        mkdir -p $MODULES_DIR
        #mount -t tmpfs none $MODULES_DIR
    fi

    set +u

    if [ -z $BUILD_DKMS ] || [ $BUILD_DKMS != "true" ]; then
        if [ $UNION_BUILD_TYPE = "overlayfs" ]; then
            MODULES_LIST=""
            if [ $SCRIPT_DIR != "/usr/bin" ]; then
                MODULES=($WORK_DIR/image/$LIVEKITNAME/*.$BEXT)
                for ((i = ${#MODULES[@]} - 1; i >= 0; i--)); do
                    MODULE_LOWER_DIR=$(basename ${MODULES[$i]} .$BEXT)
                    mkdir -p $MODULES_DIR/lower/$MODULE_LOWER_DIR-lower
                    mount ${MODULES[$i]} $MODULES_DIR/lower/$MODULE_LOWER_DIR-lower
                    MODULES_LIST=$MODULES_LIST":""$MODULES_DIR/lower/$MODULE_LOWER_DIR-lower"
                done
                MODULES_LIST=${MODULES_LIST:1}
            else
                MODULES=/run/initramfs/memory/bundles/
                if [ $FILTER_MODULES = "true" ]; then
                    MODULES_LIST=$(ls -1dr $MODULES[0-1]* | egrep "0[1-$FILTER_LEVEL]" | tr '\n' ':')
                else
                    MODULES_LIST=$(ls -1dr $MODULES[0-1]* | tr '\n' ':')
                fi
                MODULES_LIST=${MODULES_LIST/%:/}
            fi
            mkdir -p $MODULE_UPPER_DIR $MODULE_WORK_DIR $MODULE_MERGED_DIR
            mount -t overlay overlay -o lowerdir=$MODULES_LIST,upperdir=$MODULE_UPPER_DIR,workdir=$MODULE_WORK_DIR $MODULE_MERGED_DIR
        elif [ $UNION_BUILD_TYPE = "aufs" ]; then
            MODULES_LIST=""
            if [ $SCRIPT_DIR != "/usr/bin" ]; then
                MODULES=($WORK_DIR/image/$LIVEKITNAME/*.$BEXT)
                for ((i = ${#MODULES[@]} - 1; i >= 0; i--)); do
                    MODULE_LOWER_DIR=$(basename ${MODULES[$i]} .$BEXT)
                    mkdir -p $MODULES_DIR/lower/$MODULE_LOWER_DIR-lower
                    mount ${MODULES[$i]} $MODULES_DIR/lower/$MODULE_LOWER_DIR-lower
                    MODULES_LIST=$MODULES_LIST":""$MODULES_DIR/lower/$MODULE_LOWER_DIR-lower""=ro"
                done
                MODULES_LIST=${MODULES_LIST:1}
            else
                MODULES=/run/initramfs/memory/bundles/
                if [ $FILTER_MODULES = "true" ]; then
                    MODULES_LIST=$(ls -1dr $MODULES[0-1]* | egrep "0[1-4]" | tr '\n' ':')
                else
                    MODULES_LIST=$(ls -1dr $MODULES[0-1]* | tr '\n' ':')
                fi
                MODULES_LIST=${MODULES_LIST/%:/}
            fi
            mkdir -p $MODULE_UPPER_DIR $MODULE_WORK_DIR $MODULE_MERGED_DIR
            mount -t aufs -o br:$MODULE_UPPER_DIR=rw:$MODULES_LIST aufs $MODULE_MERGED_DIR
        fi
    else
        mkdir -p $MODULE_UPPER_DIR $MODULE_WORK_DIR $MODULE_MERGED_DIR
        if [ $UNION_BUILD_TYPE = "overlayfs" ]; then
            mount -t overlay overlay -o lowerdir=$LOWER_DIR,upperdir=$MODULE_UPPER_DIR,workdir=$MODULE_WORK_DIR $MODULE_MERGED_DIR
        elif [ $UNION_BUILD_TYPE = "aufs" ]; then
            mount -t aufs -o br:$MODULE_UPPER_DIR=rw:$LOWER_DIR aufs $MODULE_MERGED_DIR
        fi
    fi

    set -u

    if [ ! -d $MODULE_MERGED_DIR/dev ]; then
        mkdir -p $MODULE_MERGED_DIR/dev
    fi
    if [ ! -d $MODULE_MERGED_DIR/run ]; then
        mkdir -p $MODULE_MERGED_DIR/run
    fi
    if [ ! -d $MODULE_MERGED_DIR/proc ]; then
        mkdir -p $MODULE_MERGED_DIR/proc
    fi
    if [ ! -d $MODULE_MERGED_DIR/sys ]; then
        mkdir -p $MODULE_MERGED_DIR/sys
    fi
    if [ ! -d $MODULE_MERGED_DIR/tmp ]; then
        mkdir -p $MODULE_MERGED_DIR/tmp
    fi

    mount --bind /dev $MODULE_MERGED_DIR/dev

    if [ $SCRIPT_DIR = "/usr/bin" ]; then
        echo "nameserver 8.8.8.8" >$MODULE_MERGED_DIR/etc/resolv.conf
    else
        if [ -f /.dockerenv ] || [ "$container" = "podman" ]; then
            if [ -L $MODULE_MERGED_DIR/etc/resolv.conf ] || [ $DISTRIBUTION = "stretch" ]; then
                mv $MODULE_MERGED_DIR/etc/resolv.conf $MODULE_MERGED_DIR/etc/resolv.conf.bak
                echo "nameserver 8.8.8.8" >>$MODULE_MERGED_DIR/etc/resolv.conf
            fi
            : 'if [ ! -d $MODULE_MERGED_DIR/run/resolvconf ]; then
            mkdir -p $MODULE_MERGED_DIR/run/resolvconf
            touch $MODULE_MERGED_DIR/run/resolvconf/resolv.conf
            mount --bind /etc/resolv.conf $MODULE_MERGED_DIR/run/resolvconf/resolv.conf
            fi'
        else
            mount --bind /run $MODULE_MERGED_DIR/run
        fi
    fi
    mount none -t proc $MODULE_MERGED_DIR/proc
    mount none -t sysfs $MODULE_MERGED_DIR/sys
    mount none -t devpts $MODULE_MERGED_DIR/dev/pts
    mount none -t tmpfs $MODULE_MERGED_DIR/tmp
}

# =================================================================
#
#
# =================================================================
function module_chroot_umount_fs() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."

    local MODULES MODULE_LOWER_DIR

    set +e

    if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
        umount $MODULE_MERGED_DIR/proc
        umount $MODULE_MERGED_DIR/sys
        umount $MODULE_MERGED_DIR/dev/pts
        umount $MODULE_MERGED_DIR/tmp
        umount $MODULE_MERGED_DIR/dev
        if [ $SCRIPT_DIR = "/usr/bin" ]; then
            rm -f $MODULE_UPPER_DIR/etc/resolv.conf
            umount $MODULE_MERGED_DIR
            umount $MODULES_DIR/lower/*
            umount $MODULES_DIR
        else
            if [ -f /.dockerenv ] || [ "$container" = "podman" ]; then
                if [[ -L $MODULE_MERGED_DIR/etc/resolv.conf.bak && ! -L $MODULE_MERGED_DIR/etc/resolv.conf ]] || [ $DISTRIBUTION = "stretch" ]; then
                    rm -f $MODULE_MERGED_DIR/etc/resolv.conf
                    mv $MODULE_MERGED_DIR/etc/resolv.conf.bak $MODULE_MERGED_DIR/etc/resolv.conf
                elif [ -L $MODULE_MERGED_DIR/etc/resolv.conf.bak ] && [ -L $MODULE_MERGED_DIR/etc/resolv.conf ]; then
                    rm -f $MODULE_MERGED_DIR/etc/resolv.conf.bak
                fi
                : 'umount $MODULE_MERGED_DIR/run/resolvconf/resolv.conf
                rm -f $MODULE_MERGED_DIR/run/resolvconf/resolv.conf
                rmdir $MODULE_MERGED_DIR/run/resolvconf'
            else
                umount $MODULE_MERGED_DIR/run
            fi

            umount $MODULE_MERGED_DIR

            if [ -f /.dockerenv ] || [ "$container" = "podman" ]; then
                rm -f $MODULE_UPPER_DIR/etc/resolv.conf
                rm -f $MODULE_UPPER_DIR/etc/resolv.conf.bak
            fi
        fi
    else
        umount $MODULE_MERGED_DIR/proc >>$OUTPUT 2>&1
        umount $MODULE_MERGED_DIR/sys >>$OUTPUT 2>&1
        umount $MODULE_MERGED_DIR/dev/pts >>$OUTPUT 2>&1
        umount $MODULE_MERGED_DIR/tmp >>$OUTPUT 2>&1
        umount $MODULE_MERGED_DIR/dev >>$OUTPUT 2>&1
        if [ $SCRIPT_DIR = "/usr/bin" ]; then
            rm -f $MODULE_UPPER_DIR/etc/resolv.conf >>$OUTPUT 2>&1

            umount $MODULE_MERGED_DIR >>$OUTPUT 2>&1

            umount $MODULES_DIR/lower/* >>$OUTPUT 2>&1

            umount $MODULES_DIR >>$OUTPUT 2>&1
        else
            if [ -f /.dockerenv ] || [ "$container" = "podman" ]; then
                if [[ -L $MODULE_MERGED_DIR/etc/resolv.conf.bak && ! -L $MODULE_MERGED_DIR/etc/resolv.conf ]] || [ $DISTRIBUTION = "stretch"]; then
                    rm -f $MODULE_UPPER_DIR/etc/resolv.conf
                    mv $MODULE_MERGED_DIR/etc/resolv.conf.bak $MODULE_MERGED_DIR/etc/resolv.conf
                elif [ -L $MODULE_MERGED_DIR/etc/resolv.conf.bak ] && [ -L $MODULE_MERGED_DIR/etc/resolv.conf ]; then
                    rm -f $MODULE_UPPER_DIR/etc/resolv.conf.bak
                fi
                : 'umount $MODULE_MERGED_DIR/run/resolvconf/resolv.conf >>$OUTPUT 2>&1
                rm -f $MODULE_UPPER_DIR/run/resolvconf/resolv.conf
                rmdir $MODULE_UPPER_DIR/run/resolvconf'
            else
                umount $MODULE_MERGED_DIR/run >>$OUTPUT 2>&1
            fi
            umount $MODULE_MERGED_DIR >>$OUTPUT 2>&1

            if [ -f /.dockerenv ] || [ "$container" = "podman" ]; then
                rm -f $MODULE_UPPER_DIR/etc/resolv.conf >>$OUTPUT 2>&1
                rm -f $MODULE_UPPER_DIR/etc/resolv.conf.bak >>$OUTPUT 2>&1
            fi
        fi
    fi

    set +u

    if [ -z $BUILD_DKMS ] || [ $BUILD_DKMS != "true" ]; then
        MODULES=($WORK_DIR/image/$LIVEKITNAME/*.$BEXT)
        for ((i = ${#MODULES[@]} - 1; i >= 0; i--)); do
            MODULE_LOWER_DIR=$(basename ${MODULES[$i]} .$BEXT)
            umount $MODULES_DIR/lower/$MODULE_LOWER_DIR-lower
        done
    fi

    set -eu

    module_check_mounted
}

# =================================================================
#
#
# =================================================================
function module_cleanup() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."
    if [ "$UNATTENDED" = "true" ]; then
        module_check_mounted
        rm -rf $MODULE_UPPER_DIR
        if [ -d "$MODULE_UPPER_DIR" ]; then
            module_cleanup
        fi
    else
        read -r -p "$(echo -e ""Do you want to ${BOLD}${RED}completely remove content${ENDCOLOUR} of ${MAGENTA}$MODULE_UPPER_DIR${ENDCOLOUR}? [y/${BOLD}${GREEN}N${ENDCOLOUR}])" response
        response=${response,,}
        if [[ "$response" =~ ^(yes|y)$ ]]; then
            module_check_mounted
            rm -rf $MODULE_UPPER_DIR
            if [ -d "$MODULE_UPPER_DIR" ]; then
                module_cleanup
            fi
        else
            echo -e "${MAGENTA}$MODULE_UPPER_DIR${ENDCOLOUR} should be empty to continue."
            exit 1
        fi
    fi
}

# =================================================================
#
#
# =================================================================
function module_chroot_finish_up() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."

    # truncate machine id (why??)
    chroot $MODULE_MERGED_DIR /bin/bash -x <<EOF
truncate -s 0 /etc/machine-id
EOF

    # remove diversion (why??)
    if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
        chroot $MODULE_MERGED_DIR /bin/bash -x <<EOF
    rm /sbin/initctl
    dpkg-divert --rename --remove /sbin/initctl
EOF
    else
        chroot $MODULE_MERGED_DIR /bin/bash -x <<EOF
    rm /sbin/initctl >>$OUTPUT 2>&1
    dpkg-divert --rename --remove /sbin/initctl >>$OUTPUT 2>&1
EOF
    fi

    if [ $SCRIPT_DIR = "/usr/bin" ]; then
        if [ -d $MODULE_UPPER_DIR/home/live ]; then
            chown 1000:1000 $MODULE_UPPER_DIR/home/live
            chown -R 1000:1000 $MODULE_UPPER_DIR/home/live
        fi
    fi
}

# =================================================================
#
#
# =================================================================
function module_chroot_cleanup() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."
    set +e
    # clean up useless stuff
    if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
        rm -rf $MODULE_UPPER_DIR/boot $MODULE_UPPER_DIR/dev $MODULE_UPPER_DIR/proc $MODULE_UPPER_DIR/sys $MODULE_UPPER_DIR/rmp $MODULE_UPPER_DIR/run
        rm -f $MODULE_UPPER_DIR/root/.bash_history
        rm -rf $MODULE_UPPER_DIR/.cache
        find $MODULE_UPPER_DIR/var/log/ -type f | xargs rm -f
        rm -f $MODULE_UPPER_DIR/etc/ssh/ssh_host*
        rm -f $MODULE_UPPER_DIR/var/backups/*
        rm -f $MODULE_UPPER_DIR/var/cache/ldconfig/*
        #rm -f $MODULE_UPPER_DIR/var/cache/debconf/*
        rm -f $MODULE_UPPER_DIR/var/cache/fontconfig/*
        rm -f $MODULE_UPPER_DIR/var/cache/apt/archives/*.deb
        rm -f $MODULE_UPPER_DIR/var/cache/apt/*.bin
        rm -f $MODULE_UPPER_DIR/var/cache/debconf/*-old
        rm -f $MODULE_UPPER_DIR/var/lib/apt/extended_states
        rm -f $MODULE_UPPER_DIR/var/lib/apt/lists/*Packages
        rm -f $MODULE_UPPER_DIR/var/lib/apt/lists/*Translation*
        rm -f $MODULE_UPPER_DIR/var/lib/apt/lists/*InRelease
        rm -f $MODULE_UPPER_DIR/var/lib/apt/lists/deb.*
        rm -f $MODULE_UPPER_DIR/var/lib/dpkg/*-old
        rm -f $MODULE_UPPER_DIR/preinstall
        rm -f $MODULE_UPPER_DIR/install
        rm -f $MODULE_UPPER_DIR/install2
        rm -f $MODULE_UPPER_DIR/cleanup
        rm -f $MODULE_UPPER_DIR/$PACKAGE_VARIANT.list
        rm -f $MODULE_UPPER_DIR/postinstall
        rm -rf $MODULE_UPPER_DIR/rootcopy
        rm -f $MODULE_UPPER_DIR/etc/machine-id
        rm -rf $MODULE_UPPER_DIR/var/cache
        if [ $REMOVE_DPKG_DB = "true" ]; then
            rm -rf $MODULE_UPPER_DIR/var/lib/dpkg
        fi
    else
        rm -rf $MODULE_UPPER_DIR/boot $MODULE_UPPER_DIR/dev $MODULE_UPPER_DIR/proc $MODULE_UPPER_DIR/sys $MODULE_UPPER_DIR/rmp $MODULE_UPPER_DIR/run
        rm -f $MODULE_UPPER_DIR/root/.bash_history >>$OUTPUT 2>&1
        rm -rf $MODULE_UPPER_DIR/.cache
        find $MODULE_UPPER_DIR/var/log/ -type f | xargs rm -f >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/etc/ssh/ssh_host*
        rm -f $MODULE_UPPER_DIR/var/backups/* >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/var/cache/ldconfig/* >>$OUTPUT 2>&1
        #rm -f $MODULE_UPPER_DIR/var/cache/debconf/* >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/var/cache/fontconfig/* >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/var/cache/apt/archives/*.deb >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/var/cache/apt/*.bin >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/var/cache/debconf/*-old >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/var/lib/apt/extended_states >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/var/lib/apt/lists/*Packages >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/var/lib/apt/lists/*Translation* >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/var/lib/apt/lists/*InRelease >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/var/lib/apt/lists/deb.* >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/var/lib/dpkg/*-old >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/preinstall >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/install >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/install2 >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/cleanup >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/$PACKAGE_VARIANT.list >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/postinstall >>$OUTPUT 2>&1
        rm -rf $MODULE_UPPER_DIR/rootcopy-install >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/etc/machine-id >>$OUTPUT 2>&1
        rm -rf $MODULE_UPPER_DIR/var/cache >>$OUTPUT 2>&1
        if [ $REMOVE_DPKG_DB = "true" ]; then
            rm -rf $MODULE_UPPER_DIR/var/lib/dpkg >>$OUTPUT 2>&1
        fi
        set -e
    fi
}

# =================================================================
#
#
# =================================================================
function module_build_cleanup() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."

    if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
        chroot_cleanup $MODULE_UPPER_DIR
    else
        chroot_cleanup $MODULE_UPPER_DIR >>$OUTPUT 2>&1
    fi
}

# =================================================================
#
#
# =================================================================
function build_modules() {
    current_process
    if ! { [ $DESKTOP_ENVIRONMENT = "core" ] || [ $DESKTOP_ENVIRONMENT = "cloud" ]; } && [ "${CMD[ii]}" != "build_dkms" ]; then

        if [ $CONTAINER_TYPE = "1" ]; then
            if [ ! -f /.minios-live ]; then
                setup_host
            fi
        fi

        if [ $SCRIPT_DIR = "/usr/bin" ]; then
            WORK_DIR=$CURRENT_DIR
            SOURCE_MODULES_DIR=$CURRENT_DIR/modules
            MODULES_DIR=/tmp/build

            if [ -d $SOURCE_MODULES_DIR ]; then
                cd $SOURCE_MODULES_DIR
            else
                help
            fi
        else
            SOURCE_MODULES_DIR=$SCRIPT_DIR/linux-live/modules/$DESKTOP_ENVIRONMENT
            MODULES_DIR=$WORK_DIR/modules

            cd $SOURCE_MODULES_DIR
        fi

        for MODULE in *; do
            if [ $SCRIPT_DIR != "/usr/bin" ] && (ls $WORK_DIR/image/$LIVEKITNAME/*.$BEXT | grep -q $MODULE 2>/dev/null); then
                echo -e "${RED}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!${ENDCOLOUR}"
                echo -e "Please remove ${MAGENTA}$WORK_DIR/image/$LIVEKITNAME/$MODULE.$BEXT${ENDCOLOUR} if you want to build ${MAGENTA}$MODULE${ENDCOLOUR}."
                echo -e "${RED}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!${ENDCOLOUR}"
            #elif [ $DISTRIBUTION = "orel" ] && [ $MODULE = "01-firmware" ]; then
            #    echo "Astra Linux does not contain firmware in the repository"
            else
                MODULE_UPPER_DIR="$MODULES_DIR/$MODULE-upper"
                MODULE_WORK_DIR="$MODULES_DIR/$MODULE-work"
                MODULE_MERGED_DIR="$MODULES_DIR/$MODULE-merged"

                module_check_install_dir

                module_chroot_mount_fs

                # run pre-install script
                if [ -f $SOURCE_MODULES_DIR/$MODULE/preinstall ]; then
                    if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
                        cp $SOURCE_MODULES_DIR/$MODULE/preinstall $MODULE_MERGED_DIR/preinstall
                        chmod +x $MODULE_MERGED_DIR/preinstall
                        chroot_run $MODULE_MERGED_DIR /preinstall
                    else
                        cp $SOURCE_MODULES_DIR/$MODULE/preinstall $MODULE_MERGED_DIR/preinstall
                        chmod +x $MODULE_MERGED_DIR/preinstall
                        chroot_run $MODULE_MERGED_DIR /preinstall >>$OUTPUT 2>&1
                    fi
                fi

                # copy files
                if [ ! -f $SOURCE_MODULES_DIR/$MODULE/is_internal_build ]; then
                    if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
                        if [ "$(ls -A $SOURCE_MODULES_DIR/$MODULE/rootcopy-install)" != "" ]; then
                            (cd $SOURCE_MODULES_DIR/$MODULE/rootcopy-install && cp --parents -afr * $MODULE_MERGED_DIR/)
                        fi
                    else
                        if [ "$(ls -A $SOURCE_MODULES_DIR/$MODULE/rootcopy-install)" != "" ] >>$OUTPUT 2>&1; then
                            (cd $SOURCE_MODULES_DIR/$MODULE/rootcopy-install && cp --parents -afr * $MODULE_MERGED_DIR/)
                        fi
                    fi
                else
                    if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
                        if [ "$(ls -A $SOURCE_MODULES_DIR/$MODULE/rootcopy-install)" != "" ]; then
                            mkdir $MODULE_MERGED_DIR/rootcopy-install
                            (cd $SOURCE_MODULES_DIR/$MODULE/rootcopy-install && cp --parents -afr * $MODULE_MERGED_DIR/rootcopy-install/)
                        fi
                    else
                        if [ "$(ls -A $SOURCE_MODULES_DIR/$MODULE/rootcopy-install)" != "" ] >>$OUTPUT 2>&1; then
                            mkdir $MODULE_MERGED_DIR/rootcopy-install
                            (cd $SOURCE_MODULES_DIR/$MODULE/rootcopy-install && cp --parents -afr * $MODULE_MERGED_DIR/rootcopy-install/)
                        fi
                    fi
                fi

                # run install script
                if [ -f $SOURCE_MODULES_DIR/$MODULE/install ]; then
                    cp $SOURCE_MODULES_DIR/$MODULE/install $MODULE_MERGED_DIR/install
                    chmod +x $MODULE_MERGED_DIR/install
                    if [ -f $SOURCE_MODULES_DIR/$MODULE/cleanup ]; then
                        cp $SOURCE_MODULES_DIR/$MODULE/cleanup $MODULE_MERGED_DIR/cleanup
                    fi
                    if [ -f $SOURCE_MODULES_DIR/$MODULE/$PACKAGE_VARIANT.list ]; then
                        cp $SOURCE_MODULES_DIR/$MODULE/$PACKAGE_VARIANT.list $MODULE_MERGED_DIR/$PACKAGE_VARIANT.list
                    fi
                    if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
                        chroot_run $MODULE_MERGED_DIR /install
                    else
                        chroot_run $MODULE_MERGED_DIR /install >>$OUTPUT 2>&1
                    fi
                fi

                if [ -f $SOURCE_MODULES_DIR/$MODULE/is_internal_build ]; then
                    module_chroot_umount_fs

                    module_build_cleanup

                    # run external actions

                    if [ "$(ls -A $MODULE_UPPER_DIR)" != "" ]; then
                        mkdir -p $WORK_DIR/modules/tmp >>$OUTPUT 2>&1
                        mksquashfs $MODULE_UPPER_DIR $WORK_DIR/modules/tmp/$MODULE-stock.$BEXT -comp lz4 -b 1024K -always-use-fragments -noappend >>$OUTPUT 2>&1 || exit
                        mv $WORK_DIR/modules/tmp/$MODULE-stock.$BEXT $MODULE_UPPER_DIR/$MODULE-stock.$BEXT >>$OUTPUT 2>&1
                        cd $MODULE_UPPER_DIR >>$OUTPUT 2>&1
                        unsquashfs $MODULE-stock.$BEXT >>$OUTPUT 2>&1
                    else
                        echo -e "${MAGENTA}$MODULE_UPPER_DIR${ENDCOLOUR} is empty. Nothing to do."
                    fi

                    #module_check_install_dir

                    module_chroot_mount_fs
                fi

                # run install2 script
                if [ -f $SOURCE_MODULES_DIR/$MODULE/install2 ]; then
                    cp $SOURCE_MODULES_DIR/$MODULE/install2 $MODULE_MERGED_DIR/install2
                    chmod +x $MODULE_MERGED_DIR/install2
                    if [ "$(ls -A $SOURCE_MODULES_DIR/$MODULE/patches)" != "" ] >>$OUTPUT 2>&1; then
                        mkdir $MODULE_MERGED_DIR/patches
                        (cd $SOURCE_MODULES_DIR/$MODULE/patches && cp --parents -afr * $MODULE_MERGED_DIR/patches/)
                    fi
                    if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
                        chroot_run $MODULE_MERGED_DIR /install2
                    else
                        chroot_run $MODULE_MERGED_DIR /install2 >>$OUTPUT 2>&1
                    fi
                fi

                if [ -f $SOURCE_MODULES_DIR/$MODULE/is_dkms_build ]; then
                    read_config $MODULE_UPPER_DIR/livekit.conf KERNEL
                    if [ -L $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL/build ]; then
                        rm -f $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL/build
                    fi
                    if [ -L $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL/source ]; then
                        rm -f $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL/source
                    fi
                    if [ -L $MODULE_UPPER_DIR/lib/modules/$KERNEL/build ]; then
                        rm -f $MODULE_UPPER_DIR/lib/modules/$KERNEL/build
                    fi
                    if [ -L $MODULE_UPPER_DIR/lib/modules/$KERNEL/source ]; then
                        rm -f $MODULE_UPPER_DIR/lib/modules/$KERNEL/source
                    fi
                    set +e
                    if [ -d $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL ]; then
                        if [ ! -d $MODULE_UPPER_DIR/squashfs-root/usr/lib/modules/$KERNEL ]; then
                            mkdir -p $MODULE_UPPER_DIR/squashfs-root/usr/lib/modules/$KERNEL
                        fi
                        (cd $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL && cp --parents -afr * $MODULE_UPPER_DIR/squashfs-root/usr/lib/modules/$KERNEL/)
                    fi
                    if [ -d $MODULE_UPPER_DIR/lib/modules/$KERNEL ]; then
                        if [ ! -d $MODULE_UPPER_DIR/squashfs-root/lib/modules/$KERNEL ]; then
                            mkdir -p $MODULE_UPPER_DIR/squashfs-root/lib/modules/$KERNEL
                        fi
                        (cd $MODULE_UPPER_DIR/lib/modules/$KERNEL && cp --parents -afr * $MODULE_UPPER_DIR/squashfs-root/lib/modules/$KERNEL/)
                    fi
                    set -e
                    if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
                        chroot_run $MODULE_MERGED_DIR dir2sb /squashfs-root /$MODULE.sb
                    else
                        chroot_run $MODULE_MERGED_DIR dir2sb /squashfs-root /$MODULE.sb >>$OUTPUT 2>&1
                    fi
                    rm -f $MODULE_UPPER_DIR/livekit.conf
                fi

                # copy files
                if [ ! -f $SOURCE_MODULES_DIR/$MODULE/is_internal_build ]; then
                    if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
                        if [ "$(ls -A $SOURCE_MODULES_DIR/$MODULE/rootcopy-postinstall)" != "" ]; then
                            (cd $SOURCE_MODULES_DIR/$MODULE/rootcopy-postinstall && cp --parents -afr * $MODULE_MERGED_DIR/)
                        fi
                    else
                        if [ "$(ls -A $SOURCE_MODULES_DIR/$MODULE/rootcopy-postinstall)" != "" ] >>$OUTPUT 2>&1; then
                            (cd $SOURCE_MODULES_DIR/$MODULE/rootcopy-postinstall && cp --parents -afr * $MODULE_MERGED_DIR/)
                        fi
                    fi
                else
                    if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
                        if [ "$(ls -A $SOURCE_MODULES_DIR/$MODULE/rootcopy-postinstall)" != "" ]; then
                            mkdir $MODULE_MERGED_DIR/rootcopy-postinstall
                            (cd $SOURCE_MODULES_DIR/$MODULE/rootcopy-postinstall && cp --parents -afr * $MODULE_MERGED_DIR/rootcopy-postinstall/)
                        fi
                    else
                        if [ "$(ls -A $SOURCE_MODULES_DIR/$MODULE/rootcopy-postinstall)" != "" ] >>$OUTPUT 2>&1; then
                            mkdir $MODULE_MERGED_DIR/rootcopy-postinstall
                            (cd $SOURCE_MODULES_DIR/$MODULE/rootcopy-postinstall && cp --parents -afr * $MODULE_MERGED_DIR/rootcopy-postinstall/)
                        fi
                    fi
                fi

                # run post-install script
                if [ -f $SOURCE_MODULES_DIR/$MODULE/postinstall ]; then
                    cp $SOURCE_MODULES_DIR/$MODULE/postinstall $MODULE_MERGED_DIR/postinstall
                    chmod +x $MODULE_MERGED_DIR/postinstall
                    if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
                        chroot_run $MODULE_MERGED_DIR /postinstall
                    else
                        chroot_run $MODULE_MERGED_DIR /postinstall >>$OUTPUT 2>&1
                    fi
                fi

                if [ ! -f $SOURCE_MODULES_DIR/$MODULE/is_internal_build ]; then
                    set +e
                    chroot_run $MODULE_MERGED_DIR uncompress_files /etc/alternatives
                    chroot_run $MODULE_MERGED_DIR uncompress_files /usr/share/man
                    chroot_run $MODULE_MERGED_DIR remove_broken_links /etc/alternatives
                    chroot_run $MODULE_MERGED_DIR remove_broken_links /usr/share/man
                    set -e
                fi

                # run external actions
                if [ -f $SOURCE_MODULES_DIR/$MODULE/is_internal_build ] && [ $SCRIPT_DIR != "/usr/bin" ]; then
                    cp $MODULE_UPPER_DIR/$MODULE.$BEXT $WORK_DIR/image/$LIVEKITNAME/$MODULE-$COMP_TYPE.$BEXT >>$OUTPUT 2>&1
                elif [ -f $SOURCE_MODULES_DIR/$MODULE/is_internal_build ] && [ $SCRIPT_DIR = "/usr/bin" ]; then
                    cp $MODULE_UPPER_DIR/$MODULE.$BEXT $CURRENT_DIR/$MODULE-$COMP_TYPE.$BEXT >>$OUTPUT 2>&1
                    chmod 666 $CURRENT_DIR/$MODULE-$COMP_TYPE.$BEXT
                fi

                module_chroot_finish_up

                module_chroot_umount_fs

                if [ ! -f $SOURCE_MODULES_DIR/$MODULE/is_internal_build ]; then
                    module_build_cleanup
                fi

                module_chroot_cleanup

                if [ ! -f $SOURCE_MODULES_DIR/$MODULE/is_internal_build ]; then
                    if [ $SCRIPT_DIR = "/usr/bin" ]; then
                        if [ "$(ls -A $MODULE_UPPER_DIR)" != "" ]; then
                            mksquashfs $MODULE_UPPER_DIR $CURRENT_DIR/$MODULE-$COMP_TYPE.$BEXT -comp $COMP_TYPE -b 1024K -always-use-fragments -noappend || exit
                            chmod 666 $CURRENT_DIR/$MODULE-$COMP_TYPE.$BEXT
                        else
                            echo -e "${MAGENTA}$MODULE_UPPER_DIR${ENDCOLOUR} ${RED}is empty${ENDCOLOUR}. Nothing to do."
                        fi

                        module_chroot_umount_fs
                    else
                        if [ ! -f $WORK_DIR/image/$LIVEKITNAME/$MODULE-$COMP_TYPE.$BEXT ]; then
                            if [ "$(ls -A $MODULE_UPPER_DIR)" != "" ]; then
                                mksquashfs $MODULE_UPPER_DIR $WORK_DIR/image/$LIVEKITNAME/$MODULE-$COMP_TYPE.$BEXT -comp $COMP_TYPE -b 1024K -always-use-fragments -noappend || exit
                            else
                                echo -e "${MAGENTA}$MODULE_UPPER_DIR${ENDCOLOUR} is empty. Nothing to do."
                            fi
                        else
                            echo -e "${RED}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!${ENDCOLOUR}"
                            echo -e "Please remove ${MAGENTA}$WORK_DIR/image/$LIVEKITNAME/$MODULE-$COMP_TYPE.$BEXT${ENDCOLOUR} if you want to build ${MAGENTA}$MODULE${ENDCOLOUR}."
                            echo -e "${RED}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!${ENDCOLOUR}"
                        fi
                    fi
                fi

            fi
        done
    fi
}

# =================================================================
#
#
# =================================================================
function build_modules_live() {
    current_process
    echo "here 2"
    if [ $CONTAINER_TYPE = "1" ]; then
        if [ ! -f /.minios-live ]; then
            setup_host
        fi
    fi

    MODULES_DIR=$WORK_DIR/modules

    cd $SOURCE_MODULES_DIR

    for MODULE in *; do

        if (ls $WORK_DIR/image/$LIVEKITNAME/*.$BEXT | grep -q $MODULE 2>/dev/null); then
            echo -e "${RED}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!${ENDCOLOUR}"
            echo -e "Please remove ${MAGENTA}$WORK_DIR/image/$LIVEKITNAME/$MODULE.$BEXT${ENDCOLOUR} if you want to build ${MAGENTA}$MODULE${ENDCOLOUR}."
            echo -e "${RED}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!${ENDCOLOUR}"
        else

            MODULE_UPPER_DIR="$MODULES_DIR/$MODULE-upper"
            MODULE_WORK_DIR="$MODULES_DIR/$MODULE-work"
            MODULE_MERGED_DIR="$MODULES_DIR/$MODULE-merged"

            if [ "$(ls -A $MODULE_UPPER_DIR)" != "" ]; then
                if [ $COMP_TYPE = "zstd" ]; then
                    mksquashfs $MODULE_UPPER_DIR $WORK_DIR/image/$LIVEKITNAME/$MODULE-$COMP_TYPE.$BEXT -comp $COMP_TYPE -Xcompression-level 22 -b 1024K -always-use-fragments -noappend || exit
                else
                    mksquashfs $MODULE_UPPER_DIR $WORK_DIR/image/$LIVEKITNAME/$MODULE-$COMP_TYPE.$BEXT -comp $COMP_TYPE -b 1024K -always-use-fragments -noappend || exit
                fi
            else
                echo -e "${MAGENTA}$MODULE_UPPER_DIR${ENDCOLOUR} is empty. Nothing to do."
            fi
        fi
    done
}

function repack_module() {
    if [ $SCRIPT_DIR = "/usr/bin" ]; then
        cd $CURRENT_DIR
    fi
    OLD_MODULE=$MODULE
    MODULE=${MODULE%"-$OLD_COMP_TYPE.$BEXT"}
    if [ $COMP_TYPE = $OLD_COMP_TYPE ]; then
        echo "The module is already in the required compression format." && exit
    fi
    if [ $SCRIPT_DIR != "/usr/bin" ]; then
        unsquashfs $OLD_MODULE

        mksquashfs squashfs-root $MODULE-$COMP_TYPE.$BEXT -comp $COMP_TYPE -b 1024K -always-use-fragments -noappend || exit

        rm -rf squashfs-root
        rm -f $OLD_MODULE
    else
        if (ls $CURRENT_DIR/*.$BEXT | grep -q $MODULE 2>/dev/null); then
            echo -e "${RED}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!${ENDCOLOUR}"
            echo -e "Please remove $CURRENT_DIR/$MODULE-$COMP_TYPE.$BEXT${ENDCOLOUR} if you want to build ${MAGENTA}$MODULE${ENDCOLOUR}."
            echo -e "${RED}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!${ENDCOLOUR}"
        else
            mksquashfs /run/initramfs/memory/bundles/$OLD_MODULE $CURRENT_DIR/$MODULE-$COMP_TYPE.$BEXT -comp $COMP_TYPE -b 1024K -always-use-fragments -noappend || exit
        fi
    fi
}

function repack_modules() {
    current_process

    if [ $SCRIPT_DIR != "/usr/bin" ]; then
        cd $WORK_DIR/image/$LIVEKITNAME/
        for MODULE in *; do
            if (ls ./*-xz.$BEXT | grep -q $MODULE >>/dev/null 2>&1); then
                OLD_COMP_TYPE="xz"
                repack_module
            elif (ls ./*-lz4.$BEXT | grep -q $MODULE >>/dev/null 2>&1); then
                OLD_COMP_TYPE="lz4"
                repack_module
            elif (ls ./*-zstd.$BEXT | grep -q $MODULE >>/dev/null 2>&1); then
                OLD_COMP_TYPE="zstd"
                repack_module
            fi
        done
    else
        cd /run/initramfs/memory/bundles/
        for MODULE in *; do
            if (ls /run/initramfs/memory/bundles/*-xz.$BEXT | grep -q $MODULE >>/dev/null 2>&1); then
                OLD_COMP_TYPE="xz"
                repack_module
            elif (ls /run/initramfs/memory/bundles/*-lz4.$BEXT | grep -q $MODULE >>/dev/null 2>&1); then
                OLD_COMP_TYPE="lz4"
                repack_module
            elif (ls /run/initramfs/memory/bundles/*-zstd.$BEXT | grep -q $MODULE >>/dev/null 2>&1); then
                OLD_COMP_TYPE="zstd"
                repack_module
            fi
        done
    fi
}

function download_sources() {
    current_process

    if [ ! -d /opt/minios-live ]; then
        $APT_CMD update >>$OUTPUT 2>&1 &&
            $APT_CMD install $APT_OPTIONS git >>$OUTPUT 2>&1
        mkdir -p /opt
        cd /opt
        git clone --depth=1 https://github.com/minios-linux/minios-live.git >>$OUTPUT 2>&1
        if [ -d /opt/minios-live/.git ]; then
            rm -rf /opt/minios-live/.git >>$OUTPUT 2>&1
        fi
        if [ -f /opt/minios-live/.gitignore ]; then
            rm -f /opt/minios-live/.gitignore >>$OUTPUT 2>&1
        fi
        # allow user to edit configs
        chmod 666 /opt/minios-live/linux-live/buildconfig
        chmod 666 /opt/minios-live/linux-live/config
        if id -nu 1000 >/dev/null && [ -d /home/$(id -nu 1000)/Desktop ]; then
            if [ ! -L /home/$(id -nu 1000)/Desktop/buildconfig ]; then
                ln -s /opt/minios-live/linux-live/buildconfig /home/$(id -nu 1000)/Desktop/buildconfig
            fi
            if [ ! -L /home/$(id -nu 1000)/Desktop/config ]; then
                ln -s /opt/minios-live/linux-live/config /home/$(id -nu 1000)/Desktop/config
            fi
        fi
        if [ $(stat -c %s /opt/minios-live/linux-live/minioslib) -ne $(stat -c %s /run/initramfs/lib/minioslib) ]; then
            cp /opt/minios-live/linux-live/minioslib /run/initramfs/lib/ >>$OUTPUT 2>&1
        fi
        /opt/minios-live/install
    fi
}

# =================================================================
# =================================================================
# ===================== CONTAINER FUNCTIONS =======================
# =================================================================
# =================================================================

function container_run() {
    if [ ! "$(docker ps -q -f name=mlc-$DISTRIBUTION-$DESKTOP_ENVIRONMENT-$PACKAGE_VARIANT-$DISTRIBUTION_ARCH-$COMP_TYPE)" ]; then
        if [ "$(docker ps -aq -f status=exited -f name=mlc-$DISTRIBUTION-$DESKTOP_ENVIRONMENT-$PACKAGE_VARIANT-$DISTRIBUTION_ARCH-$COMP_TYPE)" ]; then
            # cleanup
            docker rm -f $CONTAINER_NAME
        fi
        cp -f $SCRIPT_DIR/linux-live/buildconfig $SCRIPT_DIR/linux-live/container_buildconfig
        cp -f $SCRIPT_DIR/linux-live/config $SCRIPT_DIR/linux-live/container_config
        sed -i -e "/DISTRIBUTION_TYPE=/s/=.*/=\"$DISTRIBUTION_TYPE\"/" $SCRIPT_DIR/linux-live/container_buildconfig
        sed -i -e "/DISTRIBUTION=/s/=.*/=\"$DISTRIBUTION\"/" $SCRIPT_DIR/linux-live/container_buildconfig
        sed -i -e "/DISTRIBUTION_ARCH=/s/=.*/=\"$DISTRIBUTION_ARCH\"/" $SCRIPT_DIR/linux-live/container_buildconfig
        sed -i -e "/DESKTOP_ENVIRONMENT=/s/=.*/=\"$DESKTOP_ENVIRONMENT\"/" $SCRIPT_DIR/linux-live/container_buildconfig
        sed -i -e "/COMP_TYPE=/s/=.*/=\"$COMP_TYPE\"/" $SCRIPT_DIR/linux-live/container_buildconfig
        sed -i -e "/COMP_TYPE=/s/=.*/=\"$COMP_TYPE\"/" $SCRIPT_DIR/linux-live/container_config
        sed -i -e "/PACKAGE_VARIANT=/s/=.*/=\"$PACKAGE_VARIANT\"/" $SCRIPT_DIR/linux-live/container_buildconfig
        # run your container
        docker run -d --log-driver=journald --name $CONTAINER_NAME --privileged -v /build:/build \
            -e DISTRIBUTION_TYPE="$DISTRIBUTION_TYPE" \
            -e DISTRIBUTION="$DISTRIBUTION" \
            -e DESKTOP_ENVIRONMENT="$DESKTOP_ENVIRONMENT" \
            -e PACKAGE_VARIANT="$PACKAGE_VARIANT" \
            -e DISTRIBUTION_ARCH="$DISTRIBUTION_ARCH" \
            -e COMP_TYPE="$COMP_TYPE" \
            -e USER_NAME="live" \
            -e DISTRIBUTION_VARIANT="minimumbase" \
            -e LOGPATH="/var/log" \
            -e OUTPUT="/dev/standardout" \
            -e BUILD_TEST_ISO="false" \
            -e CREATE_BACKUP="false" \
            -e DEV_SYSTEM="false" \
            -e DEBIAN_FRONTEND_TYPE="noninteractive" \
            -e APT_CMD="apt-get" \
            -e APT_OPTIONS="-y" \
            -e BOOT_TYPE="hybrid" \
            -e UNION_BUILD_TYPE="overlayfs" \
            -e SYSTEMNAME="minimumiOS" \
            -e USE_BOOTSTRAP="true" \
            -e USE_ROOTFS="true" \
            -e REMOVE_OLD_ISO="true" \
            -e REMOVE_SOURCES="true" \
            -e SKIP_SETUP_HOST="true" \
            -e DOWNLOAD_SOURCES="false" \
            -e REMOVE_DPKG_DB="false" \
            -e FILTER_MODULES="false" \
            -e FILTER_LEVEL="4" \
            local/mlc /build/minios-live/install -
    fi
}

function container_status_check() {
    RUN=$(docker inspect $CONTAINER_NAME --format='{{.State.Status}}')
}

function container_build_finish() {
    if [ -f $SCRIPT_DIR/linux-live/container_buildconfig ]; then
        rm -f $SCRIPT_DIR/linux-live/container_buildconfig
    fi
    if [ -f $SCRIPT_DIR/linux-live/container_config ]; then
        rm -f $SCRIPT_DIR/linux-live/container_config
    fi
    if [ ! -d $SCRIPT_DIR/logs ]; then
        mkdir -p $SCRIPT_DIR/logs
    fi
    docker logs $CONTAINER_NAME >&$SCRIPT_DIR/logs/$CONTAINER_NAME.log
    if [ "$(docker ps -aq -f status=exited -f name=mlc-$DISTRIBUTION-$DESKTOP_ENVIRONMENT-$PACKAGE_VARIANT-$DISTRIBUTION_ARCH-$COMP_TYPE)" ]; then
        # cleanup
        docker rm -f $CONTAINER_NAME
    fi
    if [ -d /build/minimumios-live/build/$DISTRIBUTION-$PACKAGE_VARIANT-$DISTRIBUTION_ARCH ]; then
        echo "/build/minimumios-live/build/$DISTRIBUTION-$PACKAGE_VARIANT-$DISTRIBUTION_ARCH exists"
    fi
}

function container_build_run() {
    DISTRIBUTION_TYPE="debian"
    DISTRIBUTION="$1"
    DESKTOP_ENVIRONMENT="$2"
    PACKAGE_VARIANT="$3"
    DISTRIBUTION_ARCH="$4"
    COMP_TYPE="$5"
    if [ $1 = "trusty" ] || [ $1 = "xenial" ] || [ $1 = "bionic" ] || [ $1 = "focal" ]; then
        DISTRIBUTION_TYPE="ubuntu"
    fi

    CONTAINER_NAME="mlc-$DISTRIBUTION-$DESKTOP_ENVIRONMENT-$PACKAGE_VARIANT-$DISTRIBUTION_ARCH-$COMP_TYPE"

    container_run

    container_status_check
    if [ "$RUN" = "running" ]; then
        echo "Container $CONTAINER_NAME has been started."
    fi

    while container_status_check; do
        if [ "$RUN" = "running" ]; then
            printf "."
            sleep 5
        else
            if [ "$(docker inspect $CONTAINER_NAME --format='{{.State.ExitCode}}')" != "0" ] 2>/dev/null; then
                printf "\nERROR: Container $CONTAINER_NAME stopped with error. Exit code $(docker inspect $CONTAINER_NAME --format='{{.State.ExitCode}}')\n"
                container_build_finish
            else
                printf "\nContainer $CONTAINER_NAME stopped, proceeding...\n"
                container_build_finish
            fi
            break
        fi
    done
}