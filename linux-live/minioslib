#!/bin/bash

# Functions library :: for install scripts
# Author: crims0n. <http://minios.dev>
#

# =================================================================
# =================================================================
# ========================= VARIABLES =============================
# =================================================================
# =================================================================

function common_variables() {
    # List of variables passed to chroot.
    VARIABLES="OUTPUT LOGPATH BUILD_TEST_ISO CREATE_BACKUP DEBIAN_FRONTEND_TYPE APT_CMD APT_OPTIONS DESKTOP_ENVIRONMENT DISTRIBUTION DISTRIBUTION_TYPE PACKAGE_VARIANT COMP_TYPE KERNEL KERNEL_RELEASE KERNEL_ARCH KERNEL_TYPE KERNEL_BPO KERNEL_AUFS KERNEL_NO_DKMS LIVEKITNAME SYSTEMNAME DISTRIBUTION_ARCH LOCALE TIMEZONE MODULE USER_NAME USER_PASSWORD ROOT_PASSWORD INITRD_TYPE BEXT"

    #
    CONTAINER_TYPE="0"
    set +u
    if [ -z $container ]; then
        container=""
    fi
    if [ -z $MODULE ]; then
        MODULE=""
    fi
    set -u
    : 'if [ -f /.dockerenv ] || [ "$container" = "podman" ]; then
        OUTPUT="/dev/stdout"
        #CONTAINER="docker"
    fi'
    if [[ (-f /.dockerenv || "$container" = "podman") && ! -f /.minios-live-container ]]; then
        CONTAINER_TYPE="1"
    fi
    if [[ (-f /.dockerenv || "$container" = "podman") && -f /.minios-live-container ]]; then
        CONTAINER_TYPE="2"
    fi

    #if [ $EXPORT_KERNEL = "true" ]; then
    #    NAMED_BOOT_FILES="true"
    #fi

    if [ $DISTRIBUTION_ARCH = "amd64" ]; then
        ISO_ARCH="amd64"
        KERNEL_ARCH="amd64"
    elif [ $DISTRIBUTION_ARCH = "i386-pae" ]; then
        ISO_ARCH="i386-pae"
        KERNEL_ARCH="686-pae"
        DISTRIBUTION_ARCH="i386"
    elif [ $DISTRIBUTION_ARCH = "i386" ]; then
        ISO_ARCH="i386"
        KERNEL_ARCH="686"
    elif [ $DISTRIBUTION_ARCH = "arm64" ]; then
        ISO_ARCH="arm64"
        KERNEL_ARCH="arm64"
    fi

    if [ $DESKTOP_ENVIRONMENT = "slax" ]; then
        PACKAGE_VARIANT="minimum"
    fi

    if [ $DESKTOP_ENVIRONMENT = "cloud" ]; then
        PACKAGE_VARIANT="cloud"
        KERNEL_TYPE="cloud"
    fi
    if [ $DESKTOP_ENVIRONMENT = "pve" ]; then
        PACKAGE_VARIANT="pve"
        KERNEL_TYPE="pve"
    fi

    if [ $DISTRIBUTION = "stretch" ] || [ $DISTRIBUTION = "buster" ] || [ $DISTRIBUTION = "bullseye" ] || [ $DISTRIBUTION = "bookworm" ] || [ $DISTRIBUTION = "kali-rolling" ] || [ $DISTRIBUTION = "sid" ] || [ $DISTRIBUTION = "orel" ]; then
        DISTRIBUTION_TYPE="debian"
    elif [ $DISTRIBUTION = "bionic" ] || [ $DISTRIBUTION = "focal" ] || [ $DISTRIBUTION = "jammy" ]; then
        DISTRIBUTION_TYPE="ubuntu"
    fi
    if [ $DISTRIBUTION_TYPE = "debian" ]; then
        if [ $BUILD_FROM_SNAPSHOT = "true" ]; then
            DISTRIBUTION_URL="https://snapshot.debian.org/archive/debian/$SNAPSHOT_DATE"
        else
            DISTRIBUTION_URL="http://ftp.debian.org/debian"
        fi
    elif [ $DISTRIBUTION_TYPE = "ubuntu" ]; then
        DISTRIBUTION_URL="http://archive.ubuntu.com/ubuntu"
    fi

    if [ $DISTRIBUTION = "kali-rolling" ]; then
        DISTRIBUTION_URL="http://archive.kali.org/kali"
    fi

    if [ $DISTRIBUTION = "orel" ]; then
        DISTRIBUTION_URL="http://mirror.yandex.ru/astra/stable/2.12_x86-64/repository"
    fi

    if [ $DISTRIBUTION = "orel" ] && [ $COMP_TYPE = "zstd" ]; then
        COMP_TYPE="lz4"
    elif [ $DISTRIBUTION = "stretch" ] && ([ $COMP_TYPE = "zstd" ] || [ $COMP_TYPE = "lz4" ]); then
        COMP_TYPE="gzip"
    fi

    if [ -d /run/initramfs/memory/bundles ]; then
        BUNDLES=/run/initramfs/memory/bundles
    elif [ -d /memory/bundles ]; then
        BUNDLES=/memory/bundles
    fi

    # List of directories for root filesystem
    # No subdirectories are allowed, no slashes,
    # so You can't use /var/tmp here for example
    # Exclude directories like proc sys tmp
    #if [[ $DISTRIBUTION_ARCH == *"i386"* ]]; then
    #    MKMOD="bin etc home lib opt root sbin srv usr var"
    #else
    MKMOD="bin etc home lib lib64 opt root sbin srv usr var"
    #fi

}

# =================================================================
# =================================================================
# ===================== COMMON FUNCTIONS ==========================
# =================================================================
# =================================================================

function current_process() {
    echo -e "${LIGHTYELLOW}=====> running ${CYAN}${CMD[ii]}${ENDCOLOR}${LIGHTYELLOW} ...${ENDCOLOR}"
}

# =================================================================
# beautiful console
# красивая консоль
# =================================================================

function console_colors() {
    RED="\e[31m"
    GREEN="\e[32m"
    YELLOW="\e[33m"
    BLUE="\e[34m"
    MAGENTA="\e[35m"
    CYAN="\e[36m"
    LIGHTGRAY="\e[37m"
    DARKGRAY="\e[90m"
    LIGHTRED="\e[91m"
    LIGHTGREEN="\e[92m"
    LIGHTYELLOW="\e[93m"
    LIGHTBLUE="\e[94m"
    LIGHTMAGENTA="\e[95m"
    LIGHTCYAN="\e[96m"
    BOLD="\e[1m"
    DIM="\e[2m"
    UNDERLINED="\e[4m"
    BLINK="\e[5m"
    REVERSE="\e[7m"
    HIDDEN="\e[8m"
    ENDCOLOR="\e[0m"
}

# =================================================================
# help functions
# функции помощи
# =================================================================

function help() {
    if [ $SCRIPT_DIR != "/usr/bin" ]; then
        # if $1 is set, use $1 as headline message in help()
        if [ -f /etc/default/locale ]; then
            if grep -q 'LANG="ru_RU.UTF-8"' /etc/default/locale >/dev/null 2>&1; then
                if [ -z ${1+x} ]; then
                    echo -e "${LIGHTYELLOW}Этот скрипт собирает загружаемый ISO образ $SYSTEMNAME.${ENDCOLOR}"
                    echo -e
                else
                    echo -e $1
                    echo
                fi
                echo -e "Поддерживаемые команды : ${CYAN}${CMD[*]}${ENDCOLOR}"
                echo -e
                echo -e "Синтаксис: ${MAGENTA}$0${ENDCOLOR} [start_cmd] [-] [end_cmd]"
                if [ -L /usr/bin/$LIVEKITNAME-install ] && [ "$0" != "/usr/bin/$LIVEKITNAME-install" ]; then
                    echo -e "\t${CYAN}$LIVEKITNAME-install${ENDCOLOR} [start_cmd] [-] [end_cmd]"
                fi
                echo -e "\tзапуск от start_cmd до end_cmd"
                echo -e "\tесли start_cmd опущен, выполняются все команды, начиная с первой"
                echo -e "\tесли end_cmd опущен, выполняются все команды до последней"
                echo -e "\tвведите одну команду, чтобы запустить определенную команду"
                echo -e "\tвведите '-' как единственный аргумент для запуска всех команд"
                echo -e "\t"
                echo -e "\tПримеры:${LIGHTYELLOW}$0 -${ENDCOLOR}"
                echo -e "\t\t${LIGHTYELLOW}$0 build_bootstrap - build_chroot${ENDCOLOR}"
                echo -e "\t\t${LIGHTYELLOW}$0 - build_chroot${ENDCOLOR}"
                echo -e "\t\t${LIGHTYELLOW}$0 build_bootstrap -${ENDCOLOR}"
                echo -e "\t\t${LIGHTYELLOW}$0 build_iso${ENDCOLOR}"
                exit 0
            else
                if [ -z ${1+x} ]; then
                    echo -e "${LIGHTYELLOW}This script builds bootable $SYSTEMNAME ISO image.${ENDCOLOR}"
                    echo -e
                else
                    echo -e $1
                    echo
                fi
                echo -e "Supported commands : ${CYAN}${CMD[*]}${ENDCOLOR}"
                echo -e
                echo -e "Syntax: ${MAGENTA}$0${ENDCOLOR} [start_cmd] [-] [end_cmd]"
                if [ -L /usr/bin/$LIVEKITNAME-install ] && [ "$0" != "/usr/bin/$LIVEKITNAME-install" ]; then
                    echo -e "\t${CYAN}$LIVEKITNAME-install${ENDCOLOR} [start_cmd] [-] [end_cmd]"
                fi
                echo -e "\trun from start_cmd to end_cmd"
                echo -e "\tif start_cmd is omitted, start from first command"
                echo -e "\tif end_cmd is omitted, end with last command"
                echo -e "\tenter single cmd to run the specific command"
                echo -e "\tenter '-' as only argument to run all commands"
                echo -e "\t"
                echo -e "\tExamples:${LIGHTYELLOW}$0 -${ENDCOLOR}"
                echo -e "\t\t${LIGHTYELLOW}$0 build_bootstrap - build_chroot${ENDCOLOR}"
                echo -e "\t\t${LIGHTYELLOW}$0 - build_chroot${ENDCOLOR}"
                echo -e "\t\t${LIGHTYELLOW}$0 build_bootstrap -${ENDCOLOR}"
                echo -e "\t\t${LIGHTYELLOW}$0 build_iso${ENDCOLOR}"

                exit 0
            fi
        fi
    else
        # if $1 is set, use $1 as headline message in help()
        if [ -f /etc/default/locale ]; then
            if grep -q 'LANG="ru_RU.UTF-8"' /etc/default/locale >/dev/null 2>&1; then
                if [ -z ${1+x} ]; then
                    echo -e "${LIGHTYELLOW}Этот скрипт собирает модули для $SYSTEMNAME.${ENDCOLOR}"
                    echo -e
                else
                    echo -e $1
                    echo
                fi
                echo -e "Поддерживаемые команды : ${CYAN}${CMD[*]}${ENDCOLOR}"
                echo -e
                echo -e "Синтаксис: ${MAGENTA}$0${ENDCOLOR} [start_cmd] [-] [end_cmd]"
                if [ -L /usr/bin/$LIVEKITNAME-install ] && [ "$0" != "/usr/bin/$LIVEKITNAME-install" ]; then
                    echo -e "\t${CYAN}$LIVEKITNAME-install${ENDCOLOR} [start_cmd] [-] [end_cmd]"
                fi
                echo -e "\tзапуск от start_cmd до end_cmd"
                echo -e "\tесли start_cmd опущен, выполняются все команды, начиная с первой"
                echo -e "\tесли end_cmd опущен, выполняются все команды до последней"
                echo -e "\tвведите одну команду, чтобы запустить определенную команду"
                echo -e "\tвведите '-' как единственный аргумент для запуска всех команд"
                echo -e "\t"
                echo -e "\tСкрипты установки должны находиться в папке с именем будущего модуля."
                echo -e "\tНапример, чтобы собрать модуль с именем 05-vscode, скрипты сборки"
                echo -e "\tдолжны находиться по следующему пути: ${LIGHTYELLOW}$CURRENT_DIR/modules/05-vscode${ENDCOLOR}"
                echo -e "\tПримеры:"
                echo -e "\t${LIGHTYELLOW}$0 build_modules${ENDCOLOR} сборка модулей"
                echo -e "\t${LIGHTYELLOW}$0 repack_modules${ENDCOLOR} перепаковка системы с типом сжатия, указанным"
                echo -e "\tв /etc/$LIVEKITNAME/config в переменной COMP_TYPE"
                echo -e "\t${LIGHTYELLOW}$0 -${ENDCOLOR} эта команда запустит обе функции поочерёдно"
                exit 0
            else
                if [ -z ${1+x} ]; then
                    echo -e "${LIGHTYELLOW}This script builds modules for $SYSTEMNAME.${ENDCOLOR}"
                    echo -e
                else
                    echo -e $1
                    echo
                fi
                echo -e "Supported commands : ${CYAN}${CMD[*]}${ENDCOLOR}"
                echo -e
                echo -e "Syntax: ${MAGENTA}$0${ENDCOLOR} [start_cmd] [-] [end_cmd]"
                if [ -L /usr/bin/$LIVEKITNAME-install ] && [ "$0" != "/usr/bin/$LIVEKITNAME-install" ]; then
                    echo -e "\t${CYAN}$LIVEKITNAME-install${ENDCOLOR} [start_cmd] [-] [end_cmd]"
                fi
                echo -e "\trun from start_cmd to end_cmd"
                echo -e "\tif start_cmd is omitted, start from first command"
                echo -e "\tif end_cmd is omitted, end with last command"
                echo -e "\tenter single cmd to run the specific command"
                echo -e "\tenter '-' as only argument to run all commands"
                echo -e "\t"
                echo -e "\tThe installation scripts must be in the folder with the"
                echo -e "\tname of the future module. For example, to build a module"
                echo -e "\tnamed 05-vscode, build scripts should be in the following"
                echo -e "\tpath: ${LIGHTYELLOW}$CURRENT_DIR/modules/05-vscode${ENDCOLOR}"
                echo -e "\tExamples:"
                echo -e "\t${LIGHTYELLOW}$0 build_modules ${ENDCOLOR} build modules"
                echo -e "\t${LIGHTYELLOW}$0 repack_modules ${ENDCOLOR} repack the system with the"
                echo -e "\tcompression type specified by /etc/$LIVEKITNAME/config in COMP_TYPE variable"
                echo -e "\t${LIGHTYELLOW}$0 - ${ENDCOLOR} this command will run both functions alternately"
                exit 0
            fi
        fi
    fi

}

function read_cmdline() {
    for i in $@; do
        case $i in
        user_name=*)
            USER_NAME="${i#*=}"
            shift # past argument=value
            ;;
        user_password=*)
            USER_PASSWORD="${i#*=}"
            shift # past argument=value
            ;;
        root_password=*)
            ROOT_PASSWORD="${i#*=}"
            shift # past argument=value
            ;;
        host_name=*)
            HOST_NAME="${i#*=}"
            shift # past argument=value
            ;;
        default_target=*)
            DEFAULT_TARGET="${i#*=}"
            shift # past argument=value
            ;;
        enable_services=*)
            ENABLE_SERVICES="${i#*=}"
            shift # past argument=value
            ;;
        disable_services=*)
            DISABLE_SERVICES="${i#*=}"
            shift # past argument=value
            ;;
        ssh)
            SSH=true
            shift # past argument with no value
            ;;
        ssh_key=*)
            SSH_KEY="${i#*=}"
            shift # past argument=value
            ;;
        $LIVEKITNAME.flags=*)
            FLAGS="${i#*=}"
            shift # past argument=value
            ;;
        slax.flags=*)
            SFLAGS="${i#*=}"
            shift # past argument=value
            ;;
        scripts=*)
            SCRIPTS="${i#*=}"
            shift # past argument=value
            ;;
        cloud)
            CLOUD=true
            shift # past argument with no value
            ;;
        hide_credentials)
            HIDE_CREDENTIALS=true
            shift # past argument with no value
            ;;
        autologin=*)
            AUTOLOGIN="${i#*=}"
            shift # past argument with no value
            ;;
        *)
            UNKNOWN=true
            # unknown option
            ;;
        esac
    done
}

# =================================================================
# reading configuration file
# чтение конфигурационного файла
# =================================================================

function read_config() { # read_config file.cfg var_name1 var_name2
    # ref: https://stackoverflow.com/a/20815951

    shopt -s extglob # needed the "one of these"-match below
    local configfile="${1?No configuration file given}"
    local keylist="${@:2}" # positional parameters 2 and following

    if [[ ! -f "$configfile" ]]; then
        echo >&2 "\"$configfile\" is not a file!"
        exit 1
    fi
    if [[ ! -r "$configfile" ]]; then
        echo >&2 "\"$configfile\" is not readable!"
        exit 1
    fi

    keylist="${keylist// /|}" # this will generate a regex 'one of these'

    # lhs : "left hand side" : Everything left of the '='
    # rhs : "right hand side": Everything right of the '='
    #
    # "lhs" will hold the name of the key you want to read.
    # The value of "rhs" will be assigned to that key.
    while IFS='= ' read -r lhs rhs; do
        # IF lhs in keylist
        # AND rhs not empty
        if [[ "$lhs" =~ ^($keylist)$ ]] && [[ -n $rhs ]]; then
            rhs="${rhs%\"*}"   # Del opening string quotes
            rhs="${rhs#\"*}"   # Del closing string quotes
            rhs="${rhs%\'*}"   # Del opening string quotes
            rhs="${rhs#\'*}"   # Del closing string quotes
            eval $lhs=\"$rhs\" # The magic happens here
        fi
        # tr used as a safeguard against dos line endings
    done <<<$(tr -d '\r' <$configfile)

    shopt -u extglob # Switching it back off after use
}

function read_config_value() {
    cat $1 | egrep -o "(^|[[:space:]])$2=[^[:space:]]+" | tr -d " " | cut -d "=" -f 2- | tail -n 1
}

# =================================================================
# parsing input commands
# разбор входных команд
# =================================================================

function find_index() {
    local ret
    local i
    for ((i = 0; i < ${#CMD[*]}; i++)); do
        if [ "${CMD[i]}" == "$1" ]; then
            index=$i
            return
        fi
    done
    help "Command not found : $1"
}

# =================================================================
# creating a symbolic link to the executable file for using
# autocompletion on the command line
# создание символической ссылки на исполняемый файл для
# использования автодополнения в командной строке
# =================================================================

function create_livekitname_install_symlink() {
    if [ -L /usr/bin/$LIVEKITNAME-install ]; then
        if [ "$(readlink /usr/bin/$LIVEKITNAME-install)" != "$SCRIPT_DIR/install" ]; then
            rm -f /usr/bin/$LIVEKITNAME-install
            ln -s $SCRIPT_DIR/install /usr/bin/$LIVEKITNAME-install
            if grep 'LANG="ru_RU.UTF-8"' /etc/default/locale >/dev/null 2>&1; then
                echo -e "Символическая ссылка ${MAGENTA}/usr/bin/$LIVEKITNAME-install${ENDCOLOR} была обновлена."
                echo -e "Теперь она указывает на ${MAGENTA}$SCRIPT_DIR/install${ENDCOLOR}."
            else
                echo -e "The ${MAGENTA}/usr/bin/$LIVEKITNAME-install${ENDCOLOR} symbolic link has been updated."
                echo -e "It now points to ${MAGENTA}$SCRIPT_DIR/install${ENDCOLOR}."
            fi
        fi
        if [ "$0" != "/usr/bin/$LIVEKITNAME-install" ]; then
            if grep 'LANG="ru_RU.UTF-8"' /etc/default/locale >/dev/null 2>&1; then
                echo -e "Вы можете использовать команду ${CYAN}$LIVEKITNAME-install${ENDCOLOR} для запуска этой программы."
            else
                echo -e "You can use the ${CYAN}$LIVEKITNAME-install${ENDCOLOR} command to run this program."
            fi
        fi
    else
        ln -s $SCRIPT_DIR/install /usr/bin/$LIVEKITNAME-install
        if grep 'LANG="ru_RU.UTF-8"' /etc/default/locale >/dev/null 2>&1; then
            echo -e "Символическая ссылка ${MAGENTA}/usr/bin/$LIVEKITNAME-install${ENDCOLOR} была добавлена"
            echo -e "для ${MAGENTA}$SCRIPT_DIR/install${ENDCOLOR}."

        else
            echo -e "The ${MAGENTA}/usr/bin/$LIVEKITNAME-install${ENDCOLOR} symbolic link has been added"
            echo -e "for ${MAGENTA}$SCRIPT_DIR/install${ENDCOLOR}."
        fi
    fi
    : 'if [ ! -f /usr/bin/minios-modules ]; then
        cp "$SCRIPT_DIR/linux-live/basesystem/00-core/rootcopy-install/usr/bin/minios-modules" /usr/bin/minios-modules
        if [ "$0" != "/usr/bin/minios-modules" ]; then
            if grep 'LANG="ru_RU.UTF-8"' /etc/default/locale >/dev/null 2>&1; then
                echo -e "Вы можете использовать команду ${CYAN}minios-modules${ENDCOLOR} для запуска программы сборки модулей."
            else
                echo -e "You can use the ${CYAN}minios-modules${ENDCOLOR} command to run the module build program."
            fi
        fi
    fi'
}

# =================================================================
# creating autocompletion on the command line
# создание автодополнения в командной строке
# =================================================================

function create_completion() {
    if [ -d /etc/bash_completion.d ]; then
        if [ ! -f /etc/bash_completion.d/$LIVEKITNAME-install ] || ! grep "${CMD[*]}" /etc/bash_completion.d/$LIVEKITNAME-install >/dev/null 2>&1; then
            cat <<EOF >/etc/bash_completion.d/$LIVEKITNAME-install
#!/usr/bin/env bash
complete -W "${CMD[*]}" $LIVEKITNAME-install
EOF
        fi
        if [ "$0" = "/usr/bin/$LIVEKITNAME-install" ]; then
            if grep 'LANG="ru_RU.UTF-8"' /etc/default/locale >/dev/null 2>&1; then
                echo -e "Дополнение команд работает только при использовании команды ${CYAN}$LIVEKITNAME-install${ENDCOLOR}."
                echo -e
            else
                echo -e "Command completion only works when using the ${CYAN}$LIVEKITNAME-install${ENDCOLOR} command."
                echo -e
            fi
        fi
        if [ ! -f /etc/bash_completion.d/minios-modules ] || ! grep "${CMD[*]}" /etc/bash_completion.d/minios-modules >/dev/null 2>&1; then
            cat <<EOF >/etc/bash_completion.d/minios-modules
#!/usr/bin/env bash
complete -W "build_modules repack_modules download_sources" minios-modules
EOF
        fi
        if [ "$0" = "/usr/bin/minios-modules" ]; then
            if grep 'LANG="ru_RU.UTF-8"' /etc/default/locale >/dev/null 2>&1; then
                echo -e "Дополнение команд работает только при использовании команды ${CYAN}minios-modules${ENDCOLOR}."
                echo -e
            else
                echo -e "Command completion only works when using the ${CYAN}minios-modules${ENDCOLOR} command."
                echo -e
            fi
        fi
    fi
}

# =================================================================
# only allow 'root' to run the script
# разрешаем запуск скрипта только пользователю 'root'
# =================================================================

function allow_root_only() {
    if [ $(id -u) -ne 0 ]; then
        echo -e "${BOLD}${RED}This script should be run as 'root'!${ENDCOLOR}"
        exit 1
    fi

    export HOME=/root
    export LC_ALL=C
}

# =================================================================
# check that we are inside chroot
# проверяем, что мы внутри chroot
# =================================================================

function check_is_in_chroot() {
    if [ $(stat -c %i /)="2" ]; then
        echo -e "${BOLD}${RED}This script should be run inside chroot only!${ENDCOLOR}"
        exit 1
    fi
}

# =================================================================
#
#
# =================================================================

function aufs_support() {
    if ! cat /proc/filesystems | grep aufs >/dev/null; then
        UNION_BUILD_TYPE="overlayfs"
    else
        UNION_BUILD_TYPE="aufs"
    fi
}

# =================================================================
# check if filesystems are unmounted inside chroot
# проверяем, размонтированы ли файловые системы внутри chroot
# =================================================================

function check_mounted() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."
    if grep -qs "$INSTALL_DIR/dev" /proc/mounts || grep -qs "$INSTALL_DIR/run" /proc/mounts || grep -qs "$INSTALL_DIR/proc" /proc/mounts || grep -qs "$INSTALL_DIR/sys" /proc/mounts || grep -qs "$INSTALL_DIR/dev/pts" /proc/mounts || grep -qs "$INSTALL_DIR/tmp" /proc/mounts; then
        echo -e "${BOLD}${LIGHTYELLOW}Сhroot contains mounted filesystems.${ENDCOLOR}"
        if [ "$UNATTENDED" = "true" ]; then
            chroot_umount_fs
        else
            read -r -p "$(echo -e ""Do you want to ${GREEN}unmount them${ENDCOLOR}? [${BOLD}${GREEN}Y${ENDCOLOR}/n])" response
            response=${response,,}
            if [[ "$response" =~ ^(no|n)$ ]]; then
                exit 1
            else
                chroot_umount_fs
            fi
        fi
    fi
}

# =================================================================
# check if the folder where the installation will be performed is empty
# проверяем, пуста ли папка, в которую будет производиться установка
# =================================================================

function check_install_dir() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."
    if [ "$UNATTENDED" = "true" ]; then
        #echo -e "${RED}!!!Unattended installation!!!${ENDCOLOR}"
        #INSTALL_DIR="$BUILD_DIR/$DISTRIBUTION-$DISTRIBUTION_ARCH"
        INSTALL_DIR="$WORK_DIR/basesystem"
        echo -e "The working directory is ${MAGENTA}$INSTALL_DIR${ENDCOLOR}."
        if [ "$(ls -A $INSTALL_DIR 2>/dev/null)" != "" ]; then
            cleanup
            check_mounted
        fi
    else
        # ▼ должно быть только перенаправление ошибки!
        if [ "$(ls -A $INSTALL_DIR 2>/dev/null)" != "" ]; then
            echo -e "${MAGENTA}$INSTALL_DIR${ENDCOLOR} is not empty."
            cleanup
            check_mounted
            if [ ! -d "$INSTALL_DIR" ]; then
                mkdir -p $INSTALL_DIR
            fi
            INSTALL_DIR="$(
                cd $INSTALL_DIR
                pwd
            )"
            echo $INSTALL_DIR >$SCRIPT_DIR/.install_dir && chmod 644 $SCRIPT_DIR/.install_dir
            echo -e "The working directory is ${MAGENTA}$INSTALL_DIR${ENDCOLOR}."
        else
            mkdir -p $INSTALL_DIR
            check_mounted
            INSTALL_DIR="$(
                cd $INSTALL_DIR
                pwd
            )"
            echo $INSTALL_DIR >$SCRIPT_DIR/.install_dir && chmod 644 $SCRIPT_DIR/.install_dir
            echo -e "The working directory is ${MAGENTA}$INSTALL_DIR${ENDCOLOR}."
        fi
    fi
}

# =================================================================
# configure build folder
# настраиваем папку для сборки
# =================================================================

function setup_install_dir() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."
    WORK_DIR="$BUILD_DIR/$DISTRIBUTION-$PACKAGE_VARIANT-$DISTRIBUTION_ARCH"
    if [ "$UNATTENDED" = "true" ] && [ "$INSTALL_DIR" = "" ]; then
        INSTALL_DIR="$WORK_DIR/basesystem"
        check_install_dir
    else
        if [ "$INSTALL_DIR" = "" ]; then
            if [ ! -f "$SCRIPT_DIR/.install_dir" ]; then
                echo "Enter the address of the working directory where we will build the system"
                read -r -p "$(echo -e "(Default is ${MAGENTA}$WORK_DIR/basesystem${ENDCOLOR}): ")" response
                INSTALL_DIR=${response,,}
                if [ "$INSTALL_DIR" = "" ]; then
                    INSTALL_DIR="$WORK_DIR/basesystem"
                fi
                check_install_dir
            else
                LAST_INSTALL_DIR=$(cat "$SCRIPT_DIR/.install_dir")
                echo -e "Last time you used the build directory ${MAGENTA}$LAST_INSTALL_DIR${ENDCOLOR}."
                read -r -p "$(echo -e ""Do you want to use it again? [${BOLD}${GREEN}Y${ENDCOLOR}/n])" response
                response=${response,,}
                if [[ "$response" =~ ^(no|n)$ ]]; then
                    echo "Enter the address of the working directory where we will build the system"
                    read -r -p "$(echo -e "(Default is ${MAGENTA}$WORK_DIR/basesystem${ENDCOLOR}): ")" response
                    INSTALL_DIR=${response,,}
                    if [ "$INSTALL_DIR" = "" ]; then
                        INSTALL_DIR="$WORK_DIR/basesystem"
                    fi
                    check_install_dir
                else
                    INSTALL_DIR="$LAST_INSTALL_DIR"
                    check_install_dir
                fi
            fi
        fi
    fi
}

# =================================================================
# cleaning the build folder
# очистка папки для сборки
# =================================================================

function cleanup() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."
    if [ "${CMD[ii]}" = "setup_host" ] || [ "${CMD[ii]}" = "build_bootstrap" ] || [ "${CMD[ii]}" = "build_chroot" ]; then
        if [ "$UNATTENDED" = "true" ]; then
            check_mounted
            rm -rf $INSTALL_DIR
            if [ -d "$INSTALL_DIR" ]; then
                cleanup
            fi
        else
            read -r -p "$(echo -e ""Do you want to ${BOLD}${RED}completely remove content${ENDCOLOR} of ${MAGENTA}$INSTALL_DIR${ENDCOLOR}? [y/${BOLD}${GREEN}N${ENDCOLOR}])" response
            response=${response,,}
            if [[ "$response" =~ ^(yes|y)$ ]]; then
                check_mounted
                rm -rf $INSTALL_DIR
                if [ -d "$INSTALL_DIR" ]; then
                    cleanup
                fi
            else
                echo -e "${MAGENTA}$INSTALL_DIR${ENDCOLOR} should be empty to continue."
                exit 1
            fi
        fi
    elif [ "${CMD[ii]}" = "remove_sources" ]; then
        if [ $REMOVE_SOURCES = "true" ]; then
            if [ "$UNATTENDED" = "true" ]; then
                check_mounted
                rm -rf $WORK_DIR
                if [ -d "$WORK_DIR" ]; then
                    cleanup
                fi
            else
                read -r -p "$(echo -e ""Do you want to ${BOLD}${RED}completely remove content${ENDCOLOR} of ${MAGENTA}$WORK_DIR{ENDCOLOR}? [y/${BOLD}${GREEN}N${ENDCOLOR}])" response
                response=${response,,}
                if [[ "$response" =~ ^(yes|y)$ ]]; then
                    check_mounted
                    rm -rf $WORK_DIR
                    if [ -d "$WORK_DIR" ]; then
                        cleanup
                    fi
                else
                    echo -e "${MAGENTA}$INSTALL_DIR${ENDCOLOR} should be empty to continue."
                    exit 1
                fi
            fi
        fi
    fi

}

# =================================================================
# mount filesystems inside chroot
# монтируем файловые системы внутри chroot
# =================================================================

function chroot_mount_fs() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."

    check_mounted

    if [ -f /.dockerenv ] || [ "$container" = "podman" ] || [ $DISTRIBUTION_TYPE = "ubuntu" ]; then
        if [ -L $INSTALL_DIR/etc/resolv.conf ] || [ $DISTRIBUTION = "stretch" ] || [ $DISTRIBUTION_TYPE = "ubuntu" ]; then
            if [ -e $INSTALL_DIR/etc/resolv.conf ]; then
                mv $INSTALL_DIR/etc/resolv.conf $INSTALL_DIR/etc/resolv.conf.bak
            fi
            echo "nameserver 8.8.8.8" >>$INSTALL_DIR/etc/resolv.conf
        elif [ ! -e $INSTALL_DIR/etc/resolv.conf ]; then
            echo "nameserver 8.8.8.8" >>$INSTALL_DIR/etc/resolv.conf
        fi
    fi

    mount --bind /dev $INSTALL_DIR/dev
    mount --bind /run $INSTALL_DIR/run
    if [ $DISTRIBUTION = "stretch" ]; then
        mount --bind /proc $INSTALL_DIR/proc
    else
        mount none -t proc $INSTALL_DIR/proc
    fi
    mount none -t sysfs $INSTALL_DIR/sys
    mount none -t devpts $INSTALL_DIR/dev/pts
    mount none -t tmpfs $INSTALL_DIR/tmp
}

# =================================================================
# unmount filesystems inside chroot
# размонтируем файловые системы внутри chroot
# =================================================================

function chroot_umount_fs() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."

    set +e
    if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
        umount $INSTALL_DIR/proc
        umount $INSTALL_DIR/sys
        umount $INSTALL_DIR/dev/pts
        umount $INSTALL_DIR/tmp
        umount $INSTALL_DIR/dev
        umount $INSTALL_DIR/run
    else
        umount $INSTALL_DIR/proc >>$OUTPUT 2>&1
        umount $INSTALL_DIR/sys >>$OUTPUT 2>&1
        umount $INSTALL_DIR/dev/pts >>$OUTPUT 2>&1
        umount $INSTALL_DIR/tmp >>$OUTPUT 2>&1
        umount $INSTALL_DIR/dev >>$OUTPUT 2>&1
        umount $INSTALL_DIR/run >>$OUTPUT 2>&1
    fi
    if [ -f /.dockerenv ] || [ "$container" = "podman" ] || [ $DISTRIBUTION_TYPE = "ubuntu" ]; then
        if [ -L $INSTALL_DIR/etc/resolv.conf.bak ] || [ $DISTRIBUTION = "stretch" ] || [ $DISTRIBUTION = "focal" ]; then
            rm -f $INSTALL_DIR/etc/resolv.conf
            mv $INSTALL_DIR/etc/resolv.conf.bak $INSTALL_DIR/etc/resolv.conf
        elif [ -L $INSTALL_DIR/etc/resolv.conf.bak ] && [ -L $INSTALL_DIR/etc/resolv.conf ]; then
            rm -f $INSTALL_DIR/etc/resolv.conf.bak
        elif [ -e $INSTALL_DIR/etc/resolv.conf ] && [ $DISTRIBUTION_TYPE = "bionic" ]; then
            rm -f $INSTALL_DIR/etc/resolv.conf
        fi
    fi
    set -e

    check_mounted
}

# =================================================================
# delete the log
# удаляем лог
# =================================================================

function remove_log_file() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."
    if [ -f $LOGPATH/$LIVEKITNAME.log ]; then
        rm -f $LOGPATH/$LIVEKITNAME.log
    fi
    if [ -f $INSTALL_DIR/$LIVEKITNAME.log ]; then
        rm -f $INSTALL_DIR/$LIVEKITNAME.log
    fi
}

# =================================================================
# creating a backup of scripts (to run you need to set the variable
# CREATE_BACKUP = "true" in linux-live/buildconfig)
# создание бэкапа скриптов (для запуска необходимо установить
# переменную CREATE_BACKUP="1" в linux-live/buildconfig)
# =================================================================

function create_backup() {
    if [ $CREATE_BACKUP = "true" ]; then
        echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."
        if [ ! -f $SCRIPT_DIR/.script_version ]; then
            cat "1" >$SCRIPT_DIR/.script_version >>$OUTPUT 2>&1
            chmod 644 $SCRIPT_DIR/.script_version >>$OUTPUT 2>&1
        fi
        DATE=$(date +%Y%m%d_%H%M)
        CHANGED="false"
        rm -rf $SCRIPT_DIR/iso >>$OUTPUT 2>&1
        rm -f $SCRIPT_DIR/.install_dir >>$OUTPUT 2>&1
        rm -f $SCRIPT_DIR/*.log >>$OUTPUT 2>&1
        if [ ! -d $BUILD_DIR/minios-live-current ]; then
            CHANGED="true"
            mkdir -p $BUILD_DIR/minios-live-current
            (cd $SCRIPT_DIR && cp --parents -afr * $BUILD_DIR/minios-live-current)
        else
            for file in $(find $SCRIPT_DIR -path $SCRIPT_DIR/.git -prune -false -o -type f | sed "s,$SCRIPT_DIR/,,g" | sed "s,.script_version,,g"); do
                if ! cmp $SCRIPT_DIR/$file $BUILD_DIR/minios-live-current/$file >>$OUTPUT 2>&1; then
                    CHANGED="true"
                    echo -e "$file has been modified since last backup." >>$OUTPUT 2>&1
                    echo -e "Copying $SCRIPT_DIR/$file to $BUILD_DIR/minios-live-current/$file..." >>$OUTPUT 2>&1
                    cp -f "$SCRIPT_DIR/$file" "$BUILD_DIR/minios-live-current/$file" >>$OUTPUT 2>&1
                fi
            done
        fi
        if [ $CHANGED = "true" ]; then
            SCRIPT_VERSION=$(cat $SCRIPT_DIR/.script_version)
            echo $(($SCRIPT_VERSION + 1)) >$SCRIPT_DIR/.script_version
            echo $(($SCRIPT_VERSION + 1)) >$BUILD_DIR/minios-live-current/.script_version
            cd $SCRIPT_DIR >>$OUTPUT 2>&1
            rm -f $BUILD_DIR/minios-live-current.tar.gz
            tar -czf $BUILD_DIR/minios-live-current.tar.gz ./ >>$OUTPUT 2>&1
            cp $BUILD_DIR/minios-live-current.tar.gz $BUILD_DIR/minios-live-v$SCRIPT_VERSION-$DATE.tar.gz >>$OUTPUT 2>&1
        fi
    fi
}

function add_unofficial_repository() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."
    if [ $DISTRIBUTION = "buster" ] || [ $DISTRIBUTION = "bullseye" ]; then
        if [ $USE_UNOFFICIAL_REPOSITORY = "true" ]; then
            cat <<EOF >$INSTALL_DIR/etc/apt/sources.list
deb $UNOFFICIAL_REPOSITORY_ADDRESS $DISTRIBUTION main contrib non-free
EOF
        fi
    fi
}

function remove_unofficial_repository() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."
    if [ $BUILD_FROM_SNAPSHOT = "true" ]; then
        cp -f $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION-snapshot.list $INSTALL_DIR/etc/apt/sources.list
    else
        cp -f $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION.list $INSTALL_DIR/etc/apt/sources.list
    fi
}

# =================================================================
# Displaying information about the start of the build for a more
# convenient search in the logs
# Отображение информации о старте сборки для более удобного поиска
# в логах
# =================================================================

function new_run() {
    DATE=$(date +"%Y.%m.%d %H:%M")
    echo ""
    echo "=================================================================" >>$OUTPUT 2>&1
    echo "=================================================================" >>$OUTPUT 2>&1
    echo "============================ NEW RUN ============================" >>$OUTPUT 2>&1
    echo "======================== $DATE =======================" >>$OUTPUT 2>&1
    echo "=================================================================" >>$OUTPUT 2>&1
    echo "======= If during the installation you get an error that ========" >>$OUTPUT 2>&1
    echo "=== /dev/stdout is not available, try using a bionic or xenial ==" >>$OUTPUT 2>&1
    echo "================= based container to install. ===================" >>$OUTPUT 2>&1
    echo "=================================================================" >>$OUTPUT 2>&1
    echo "=================================================================" >>$OUTPUT 2>&1
    echo "========== Distributution: $DISTRIBUTION" >>$OUTPUT 2>&1
    echo "========== Desktop environment: $DESKTOP_ENVIRONMENT" >>$OUTPUT 2>&1
    echo "========== Package variant: $PACKAGE_VARIANT" >>$OUTPUT 2>&1
    echo "========== Arch: $DISTRIBUTION_ARCH" >>$OUTPUT 2>&1
    echo "========== Initrd type: $INITRD_TYPE" >>$OUTPUT 2>&1
    echo "========== Kernel type: $KERNEL_TYPE" >>$OUTPUT 2>&1
    echo "========== Kernel BPO: $KERNEL_BPO" >>$OUTPUT 2>&1
    echo "========== Kernel AUFS: $KERNEL_AUFS" >>$OUTPUT 2>&1
    echo "========== Don't install additional drivers: $KERNEL_NO_DKMS" >>$OUTPUT 2>&1
    echo "========== Named boot files: $NAMED_BOOT_FILES" >>$OUTPUT 2>&1
    echo "========== Compression: $COMP_TYPE" >>$OUTPUT 2>&1
    echo "========== Locale: $LOCALE" >>$OUTPUT 2>&1
    echo "========== Time zone: $TIMEZONE" >>$OUTPUT 2>&1
    echo "=================================================================" >>$OUTPUT 2>&1
    echo "=================================================================" >>$OUTPUT 2>&1
    echo ""
}

function add_chroot_configuration_files() {
    cat <<EOF >$1/$LIVEKITNAME.conf
OUTPUT=$OUTPUT
LOGPATH=$LOGPATH
BUILD_TEST_ISO=$BUILD_TEST_ISO
CREATE_BACKUP=$CREATE_BACKUP
DEBIAN_FRONTEND_TYPE=$DEBIAN_FRONTEND_TYPE
APT_CMD=$APT_CMD
APT_OPTIONS=$APT_OPTIONS
DESKTOP_ENVIRONMENT=$DESKTOP_ENVIRONMENT
DISTRIBUTION=$DISTRIBUTION
DISTRIBUTION_TYPE=$DISTRIBUTION_TYPE
PACKAGE_VARIANT=$PACKAGE_VARIANT
COMP_TYPE=$COMP_TYPE
#KERNEL=\$KERNEL
KERNEL_RELEASE=$KERNEL_RELEASE
KERNEL_ARCH=$KERNEL_ARCH
KERNEL_TYPE=$KERNEL_TYPE
KERNEL_BPO=$KERNEL_BPO
KERNEL_AUFS=$KERNEL_AUFS
KERNEL_NO_DKMS=$KERNEL_NO_DKMS
LIVEKITNAME=$LIVEKITNAME
SYSTEMNAME=$SYSTEMNAME
DISTRIBUTION_ARCH=$DISTRIBUTION_ARCH
LOCALE=$LOCALE
TIMEZONE=$TIMEZONE
MODULE=$MODULE
USER_NAME=$USER_NAME
BEXT=$BEXT
EOF

    cat <<'EOF' >$1/functions
#!/bin/bash

# =================================================================
# beautiful console
# красивая консоль
# =================================================================
function console_colors() {
    RED="\e[31m"
    GREEN="\e[32m"
    YELLOW="\e[33m"
    BLUE="\e[34m"
    MAGENTA="\e[35m"
    CYAN="\e[36m"
    LIGHTGRAY="\e[37m"
    DARKGRAY="\e[90m"
    LIGHTRED="\e[91m"
    LIGHTGREEN="\e[92m"
    LIGHTYELLOW="\e[93m"
    LIGHTBLUE="\e[94m"
    LIGHTMAGENTA="\e[95m"
    LIGHTCYAN="\e[96m"
    BOLD="\e[1m"
    DIM="\e[2m"
    UNDERLINED="\e[4m"
    BLINK="\e[5m"
    REVERSE="\e[7m"
    HIDDEN="\e[8m"
    ENDCOLOR="\e[0m"
}

# =================================================================
# reading configuration file
# чтение конфигурационного файла
# =================================================================

function read_config() { # read_config file.cfg var_name1 var_name2
    # ref: https://stackoverflow.com/a/20815951

    shopt -s extglob # needed the "one of these"-match below
    local configfile="${1?No configuration file given}"
    local keylist="${@:2}" # positional parameters 2 and following

    if [[ ! -f "$configfile" ]]; then
        echo >&2 "\"$configfile\" is not a file!"
        exit 1
    fi
    if [[ ! -r "$configfile" ]]; then
        echo >&2 "\"$configfile\" is not readable!"
        exit 1
    fi

    keylist="${keylist// /|}" # this will generate a regex 'one of these'

    # lhs : "left hand side" : Everything left of the '='
    # rhs : "right hand side": Everything right of the '='
    #
    # "lhs" will hold the name of the key you want to read.
    # The value of "rhs" will be assigned to that key.
    while IFS='= ' read -r lhs rhs; do
        # IF lhs in keylist
        # AND rhs not empty
        if [[ "$lhs" =~ ^($keylist)$ ]] && [[ -n $rhs ]]; then
            rhs="${rhs%\"*}"   # Del opening string quotes
            rhs="${rhs#\"*}"   # Del closing string quotes
            rhs="${rhs%\'*}"   # Del opening string quotes
            rhs="${rhs#\'*}"   # Del closing string quotes
            eval $lhs=\"$rhs\" # The magic happens here
        fi
        # tr used as a safeguard against dos line endings
    done <<<$(tr -d '\r' <$configfile)

    shopt -u extglob # Switching it back off after use
}

# Unzip gzipped files (man pages), so LZMA can compress 2times better.
# First we fix symlinks, then uncompress files
# $1 = search directory
uncompress_files() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."
    local LINK LINE

    find "$1" -type l -name "*.gz" | while read LINE; do
        LINK="$(readlink "$LINE" | sed -r 's/.gz$//')"
        FILE="$(echo "$LINE" | sed -r 's/.gz$//')"
        ln -sfn "$LINK" "$FILE"
        rm -f "$LINE"
    done
    find "$1" -type f -name "*.gz" | xargs -r gunzip
}

# remove broken links
# $1 = search directory
remove_broken_links() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."
    find "$1" -type l -exec test ! -e {} \; -print | xargs rm -vf
}
EOF
}

function remove_chroot_configuration_files() {
    rm -f $1/$LIVEKITNAME.conf
    rm -f $1/functions
}

function get_latest_release() {
    curl --silent "https://api.github.com/repos/$1/releases/latest" | # Get latest release from GitHub api
        grep '"tag_name":' |                                          # Get tag line
        sed -E 's/.*"([^"]+)".*/\1/'                                  # Pluck JSON value
}

function get_latest_package_url() {
    curl --silent "https://api.github.com/repos/$1/releases/latest" | # Get latest release from GitHub api
        grep '"browser_download_url":' | grep ".sb"\" |               # Get tag line
        sed -E 's/.*"([^"]+)".*/\1/'                                  # Pluck JSON value
}

function timezone_to_array() {
    local IFS
    IFS="/"
    TIMEZONE=($TIMEZONE)
}

function language_to_array() {
    local IFS
    IFS="_"
    LANG=($LOCALE)
}

# =================================================================
# =================================================================
# ====================== HOST FUNCTIONS ===========================
# =================================================================
# =================================================================

# =================================================================
# Creating a $PACKAGE_VARIANT list from a template
# Создание списка пакетов из шаблона
# =================================================================

function create_apt_list() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."
    if [ $BUILD_FROM_SNAPSHOT = "true" ]; then
        if [ $DISTRIBUTION = "sid" ] || [ $DISTRIBUTION = "bookworm" ]; then
            echo "deb     https://snapshot.debian.org/archive/debian/$SNAPSHOT_DATE/ $DISTRIBUTION main contrib non-free" >$SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION-snapshot.list
            echo "#deb-src https://snapshot.debian.org/archive/debian/$SNAPSHOT_DATE/ $DISTRIBUTION main contrib non-free" >>$SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION-snapshot.list
        else
            cp -f $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION_TYPE-snapshot.list $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION-snapshot.list
            sed -i "s,distro,$DISTRIBUTION,g;s,datetime,$SNAPSHOT_DATE,g" $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION-snapshot.list
        fi
    else
        if [ ! -f $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION.list ]; then
            if [ $DISTRIBUTION_TYPE = "debian" ] && [[ $DISTRIBUTION = "stretch" || $DISTRIBUTION = "buster" ]]; then
                cp -f $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION_TYPE-old.list $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION.list
            else
                cp -f $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION_TYPE.list $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION.list
            fi
            sed -i "s,distro,$DISTRIBUTION,g" $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION.list
            sed -i "s,http://archive.ubuntu.com/ubuntu,$DISTRIBUTION_URL,g" $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION.list
        fi
    fi

}

function get_vars() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."
    set +u
    add_chroot_configuration_files $1
    . /functions
    read_config /$LIVEKITNAME.conf $VARIABLES
    export $VARIABLES
    set -u
}

function chroot_run() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."
    add_chroot_configuration_files $1
    chroot $1 /bin/bash <<EOF
. /functions
read_config /$LIVEKITNAME.conf $VARIABLES
export $VARIABLES
${@:2}
EOF
    remove_chroot_configuration_files $1
}

# Unzip gzipped files (man pages), so LZMA can compress 2times better.
# First we fix symlinks, then uncompress files
# $1 = search directory
uncompress_files() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."
    local LINK LINE

    find "$1" -type l -name "*.gz" | while read LINE; do
        LINK="$(readlink "$LINE" | sed -r 's/.gz$//')"
        FILE="$(echo "$LINE" | sed -r 's/.gz$//')"
        ln -sfn "$LINK" "$FILE"
        rm -f "$LINE"
    done
    find "$1" -type f -name "*.gz" | xargs -r gunzip
}

# remove broken links
# $1 = search directory
remove_broken_links() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."
    find "$1" -type l -exec test ! -e {} \; -print | xargs rm -vf
}

# =================================================================
# Installing the base system
# Установка базовой системы
# =================================================================

function build_bootstrap() {
    current_process

    if [ $CONTAINER_TYPE = "1" ]; then
        if [ ! -f /.minios-live ]; then
            setup_host
        fi
    fi
    if [ $USE_ROOTFS = "true" ] && [ ! -f $SCRIPT_DIR/rootfs/$DISTRIBUTION-$DISTRIBUTION_ARCH-rootfs.tar.gz ]; then
        if [ -f $SCRIPT_DIR/rootfs/$DISTRIBUTION-$DISTRIBUTION_ARCH.tar.gz ]; then
            if [ ! -d $INSTALL_DIR ]; then
                mkdir -p $INSTALL_DIR
            fi
            tar -xzf $SCRIPT_DIR/rootfs/$DISTRIBUTION-$DISTRIBUTION_ARCH.tar.gz -C $INSTALL_DIR
        else
            if [ $DISTRIBUTION = "orel" ]; then
                if [ ! -L /usr/share/debootstrap/scripts/orel ]; then
                    ln -s sid /usr/share/debootstrap/scripts/orel
                fi
                sudo DEBIAN_FRONTEND=$DEBIAN_FRONTEND_TYPE \
                    debootstrap --keyring $SCRIPT_DIR/linux-live/basesystem/gpg/astra-archive.gpg --arch=$DISTRIBUTION_ARCH --exclude=usr-is-merged $DISTRIBUTION $INSTALL_DIR $DISTRIBUTION_URL >>$OUTPUT 2>>$OUTPUT
            elif [ $PACKAGE_VARIANT = "minimum" ]; then
                sudo DEBIAN_FRONTEND=$DEBIAN_FRONTEND_TYPE \
                    debootstrap --arch=$DISTRIBUTION_ARCH $DISTRIBUTION $INSTALL_DIR $DISTRIBUTION_URL >>$OUTPUT 2>>$OUTPUT
            elif [ $DISTRIBUTION_TYPE = "ubuntu" ]; then
                sudo DEBIAN_FRONTEND=$DEBIAN_FRONTEND_TYPE \
                    debootstrap --arch=$DISTRIBUTION_ARCH --variant=$DISTRIBUTION_VARIANT $DISTRIBUTION $INSTALL_DIR $DISTRIBUTION_URL >>$OUTPUT 2>>$OUTPUT
            else
                sudo DEBIAN_FRONTEND=$DEBIAN_FRONTEND_TYPE \
                    debootstrap --arch=$DISTRIBUTION_ARCH --include=apt-transport-https $DISTRIBUTION $INSTALL_DIR $DISTRIBUTION_URL >>$OUTPUT 2>>$OUTPUT
            fi
            #sudo DEBIAN_FRONTEND=$DEBIAN_FRONTEND_TYPE \
            #    debootstrap --arch=$DISTRIBUTION_ARCH --variant=$DISTRIBUTION_VARIANT $DISTRIBUTION $INSTALL_DIR $DISTRIBUTION_URL >>$OUTPUT 2>>$OUTPUT
            if [ ! -d $SCRIPT_DIR/rootfs ]; then
                mkdir -p $SCRIPT_DIR/rootfs
            fi
            tar -czf $SCRIPT_DIR/rootfs/$DISTRIBUTION-$DISTRIBUTION_ARCH.tar.gz -C $INSTALL_DIR .
        fi
    elif [ $USE_ROOTFS = "true" ] && [ -f $SCRIPT_DIR/rootfs/$DISTRIBUTION-$DISTRIBUTION_ARCH-rootfs.tar.gz ]; then
        if [ ! -d $INSTALL_DIR ]; then
            mkdir -p $INSTALL_DIR
        fi
        tar -xzf $SCRIPT_DIR/rootfs/$DISTRIBUTION-$DISTRIBUTION_ARCH-rootfs.tar.gz -C $INSTALL_DIR
    elif [ $USE_ROOTFS != "true" ] && [ $USE_BOOTSTRAP = "true" ]; then
        if [ -f $SCRIPT_DIR/rootfs/$DISTRIBUTION-$DISTRIBUTION_ARCH.tar.gz ]; then
            if [ ! -d $INSTALL_DIR ]; then
                mkdir -p $INSTALL_DIR
            fi
            tar -xzf $SCRIPT_DIR/rootfs/$DISTRIBUTION-$DISTRIBUTION_ARCH.tar.gz -C $INSTALL_DIR
        else
            if [ $DISTRIBUTION = "orel" ]; then
                cd /usr/share/debootstrap/scripts
                ln -s sid orel
                sudo DEBIAN_FRONTEND=$DEBIAN_FRONTEND_TYPE \
                    debootstrap --keyring $SCRIPT_DIR/linux-live/basesystem/gpg/astra-archive.gpg --arch=$DISTRIBUTION_ARCH $DISTRIBUTION $INSTALL_DIR $DISTRIBUTION_URL >>$OUTPUT 2>>$OUTPUT
            elif [ $PACKAGE_VARIANT = "minimum" ]; then
                sudo DEBIAN_FRONTEND=$DEBIAN_FRONTEND_TYPE \
                    debootstrap --arch=$DISTRIBUTION_ARCH $DISTRIBUTION $INSTALL_DIR $DISTRIBUTION_URL >>$OUTPUT 2>>$OUTPUT
            else
                sudo DEBIAN_FRONTEND=$DEBIAN_FRONTEND_TYPE \
                    debootstrap --arch=$DISTRIBUTION_ARCH $DISTRIBUTION $INSTALL_DIR $DISTRIBUTION_URL >>$OUTPUT 2>>$OUTPUT
            fi
            if [ ! -d $SCRIPT_DIR/rootfs ]; then
                mkdir -p $SCRIPT_DIR/rootfs
            fi
            tar -czf $SCRIPT_DIR/rootfs/$DISTRIBUTION-$DISTRIBUTION_ARCH.tar.gz -C $INSTALL_DIR .
        fi
    else
        if [ $DISTRIBUTION = "orel" ]; then
            cd /usr/share/debootstrap/scripts
            ln -s sid orel
            sudo DEBIAN_FRONTEND=$DEBIAN_FRONTEND_TYPE \
                debootstrap --keyring $SCRIPT_DIR/linux-live/basesystem/gpg/astra-archive.gpg --arch=$DISTRIBUTION_ARCH $DISTRIBUTION $INSTALL_DIR $DISTRIBUTION_URL >>$OUTPUT 2>>$OUTPUT
        elif [ $PACKAGE_VARIANT = "minimum" ]; then
            sudo DEBIAN_FRONTEND=$DEBIAN_FRONTEND_TYPE \
                debootstrap --arch=$DISTRIBUTION_ARCH $DISTRIBUTION $INSTALL_DIR $DISTRIBUTION_URL >>$OUTPUT 2>>$OUTPUT
        else
            sudo DEBIAN_FRONTEND=$DEBIAN_FRONTEND_TYPE \
                debootstrap --arch=$DISTRIBUTION_ARCH $DISTRIBUTION $INSTALL_DIR $DISTRIBUTION_URL >>$OUTPUT 2>>$OUTPUT
        fi
    fi

    build_rootfs

}

function mx_repo() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."
    if [ $USE_MX_REPO = "true" ]; then
        if [ $DISTRIBUTION = "stretch" ] || [ $DISTRIBUTION = "buster" ] || [ $DISTRIBUTION = "bullseye" ]; then
            cd $INSTALL_DIR
            wget http://mxrepo.com/mx/repo/pool/main/m/mx-archive-keyring/mx-archive-keyring_2018.2mx17_all.deb
            wget http://mxrepo.com/mx/repo/pool/main/m/mx19-archive-keyring/mx19-archive-keyring_2020.4.29_all.deb
            wget http://mxrepo.com/mx/repo/pool/main/m/mx21-archive-keyring/mx21-archive-keyring_2021.2.19_all.deb
            wget http://mxrepo.com/mx/repo/pool/main/a/antix-archive-keyring/antix-archive-keyring_20019.3.14_all.deb
            if [ -f /.minios-live-container ]; then
                if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
                    chroot_run $INSTALL_DIR apt-get install -y /*.deb
                else
                    chroot_run $INSTALL_DIR apt-get install -y /*.deb >>$OUTPUT 2>&1
                fi
            else
                chroot_run $INSTALL_DIR apt-get install -y /*.deb >>$OUTPUT 2>&1
            fi
            rm $INSTALL_DIR/*.deb
            cat <<EOF >$INSTALL_DIR/etc/apt/sources.list.d/mx.list
# MX Community Main and Test Repos
deb http://mxrepo.com/mx/repo/ $DISTRIBUTION main non-free
#deb http://mxrepo.com/mx/testrepo/ $DISTRIBUTION test

#ahs hardware stack repo
deb http://mxrepo.com/mx/repo/ $DISTRIBUTION ahs
EOF
        fi
    fi
}

function antix_repo() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."
    if [ $USE_ANTIX_REPO = "true" ]; then
        if [ $DISTRIBUTION = "stretch" ] || [ $DISTRIBUTION = "buster" ] || [ $DISTRIBUTION = "bullseye" ]; then
            cd $INSTALL_DIR
            wget http://mxrepo.com/mx/repo/pool/main/m/mx-archive-keyring/mx-archive-keyring_2018.2mx17_all.deb
            wget http://mxrepo.com/mx/repo/pool/main/m/mx19-archive-keyring/mx19-archive-keyring_2020.4.29_all.deb
            wget http://mxrepo.com/mx/repo/pool/main/m/mx21-archive-keyring/mx21-archive-keyring_2021.2.19_all.deb
            wget http://mxrepo.com/mx/repo/pool/main/a/antix-archive-keyring/antix-archive-keyring_20019.3.14_all.deb
            if [ -f /.minios-live-container ]; then
                if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
                    chroot_run $INSTALL_DIR apt-get install -y /*.deb
                else
                    chroot_run $INSTALL_DIR apt-get install -y /*.deb >>$OUTPUT 2>&1
                fi
            else
                chroot_run $INSTALL_DIR apt-get install -y /*.deb >>$OUTPUT 2>&1
            fi
            rm $INSTALL_DIR/*.deb
            cat <<EOF >$INSTALL_DIR/etc/apt/sources.list.d/antix.list
# antiX Community Repos
deb http://mirror.yandex.ru/mirrors/MX-Linux/MX-Packages/antix/$DISTRIBUTION/ $DISTRIBUTION main nonfree
EOF
        fi
    fi
}

function mint_repo() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."
    if [ $DISTRIBUTION_TYPE = "ubuntu" ]; then
        if [ $DISTRIBUTION = "jammy" ]; then
            cd $INSTALL_DIR
            wget http://packages.linuxmint.com/pool/main/l/linuxmint-keyring/linuxmint-keyring_2022.06.21_all.deb
            if [ -f /.minios-live-container ]; then
                if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
                    chroot_run $INSTALL_DIR apt-get install -y /*.deb
                else
                    chroot_run $INSTALL_DIR apt-get install -y /*.deb >>$OUTPUT 2>&1
                fi
            else
                chroot_run $INSTALL_DIR apt-get install -y /*.deb >>$OUTPUT 2>&1
            fi
            rm $INSTALL_DIR/*.deb
            if [ $DISTRIBUTION = "focal" ]; then
                cat <<EOF >$INSTALL_DIR/etc/apt/sources.list.d/linux-mint.list
deb http://packages.linuxmint.com una main upstream import backport #id:linuxmint_main
EOF
            elif [ $DISTRIBUTION = "jammy" ]; then
                cat <<EOF >$INSTALL_DIR/etc/apt/sources.list.d/linux-mint.list
deb http://packages.linuxmint.com vera main upstream import backport #id:linuxmint_main
EOF
            fi
        fi
    fi
}

function build_rootfs() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."
    #current_process

    if [ $USE_ROOTFS = "true" ]; then
        if [ ! -f $SCRIPT_DIR/rootfs/$DISTRIBUTION-$DISTRIBUTION_ARCH-rootfs.tar.gz ]; then
            if [ $CONTAINER_TYPE = "1" ]; then
                if [ ! -f /.minios-live ]; then
                    setup_host
                fi
            fi

            chroot_mount_fs

            cat <<'EOF' >$INSTALL_DIR/etc/apt/apt.conf.d/000MiniOS
APT::Install-Recommends "0";
APT::Install-Suggests "0";
Acquire::Languages { "none"; }
EOF

            if [ $DISTRIBUTION = "kali-rolling" ]; then
                DISTRIBUTION="testing"
                create_apt_list
                cp -f $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION.list $INSTALL_DIR/etc/apt/sources.list
                if [ -f /.minios-live-container ]; then
                    if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
                        chroot_run $INSTALL_DIR apt-get update
                        chroot_run $INSTALL_DIR apt-get install -y gnupg
                        chroot_run $INSTALL_DIR apt-key adv --keyserver keyserver.ubuntu.com --recv-keys ED444FF07D8D0BF6
                    else
                        chroot_run $INSTALL_DIR apt-get update -y >>$OUTPUT 2>&1
                        chroot_run $INSTALL_DIR apt-get install -y gnupg >>$OUTPUT 2>&1
                        chroot_run $INSTALL_DIR apt-key adv --keyserver keyserver.ubuntu.com --recv-keys ED444FF07D8D0BF6 >>$OUTPUT 2>&1
                    fi
                else
                    chroot $INSTALL_DIR apt-get update -y >>$OUTPUT 2>&1
                    chroot $INSTALL_DIR apt-get install -y gnupg >>$OUTPUT 2>&1
                    chroot $INSTALL_DIR apt-key adv --keyserver keyserver.ubuntu.com --recv-keys ED444FF07D8D0BF6 >>$OUTPUT 2>&1
                fi
                DISTRIBUTION="kali-rolling"
            fi

            create_apt_list

            if [ -f /.minios-live-container ]; then
                if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
                    chroot_run $INSTALL_DIR apt-get update
                    chroot_run $INSTALL_DIR apt-get install -y gnupg ca-certificates
                    if [ $DISTRIBUTION = "orel" ]; then
                        cd $INSTALL_DIR
                        wget https://dl.astralinux.ru/astra/stable/2.12_x86-64/repository/pool/non-free/libg/libgost/libgost_2.0.2-5+ci2_amd64.deb
                        chroot_run $INSTALL_DIR apt-get install -y ./libgost_2.0.2-5+ci2_amd64.deb
                        rm $INSTALL_DIR/libgost_2.0.2-5+ci2_amd64.deb
                        cd -
                        #apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 0E98404D386FA1D9
                    fi
                    #if [ $DISTRIBUTION = "stretch" ] || [ $DISTRIBUTION = "orel" ]; then
                    #    chroot_run $INSTALL_DIR apt-get install -y apt-transport-https
                    #fi
                    #curl https://minios-linux.github.io/debian/minios-linux.asc | gpg --dearmor >$INSTALL_DIR/etc/apt/trusted.gpg.d/minios-linux.gpg
                    #if [ $DISTRIBUTION = "kali-rolling" ] || [ $DISTRIBUTION_TYPE = "ubuntu" ]; then
                    #    echo "deb https://minios-linux.github.io/debian/ bookworm main contrib non-free" >$INSTALL_DIR/etc/apt/sources.list.d/minios-linux.list
                    #elif [ $DISTRIBUTION = "orel" ]; then
                    #    echo "deb https://minios-linux.github.io/debian/ stretch main contrib non-free" >$INSTALL_DIR/etc/apt/sources.list.d/minios-linux.list
                    #else
                    #    echo "deb https://minios-linux.github.io/debian/ $DISTRIBUTION main contrib non-free" >$INSTALL_DIR/etc/apt/sources.list.d/minios-linux.list
                    #fi
                else
                    chroot_run $INSTALL_DIR apt-get update -y >>$OUTPUT 2>&1
                    chroot_run $INSTALL_DIR apt-get install -y gnupg ca-certificates >>$OUTPUT 2>&1
                    if [ $DISTRIBUTION = "orel" ]; then
                        cd $INSTALL_DIR >>$OUTPUT 2>&1
                        wget https://dl.astralinux.ru/astra/stable/2.12_x86-64/repository/pool/non-free/libg/libgost/libgost_2.0.2-5+ci2_amd64.deb >>$OUTPUT 2>&1
                        chroot_run $INSTALL_DIR apt-get install -y ./libgost_2.0.2-5+ci2_amd64.deb >>$OUTPUT 2>&1
                        rm $INSTALL_DIR/libgost_2.0.2-5+ci2_amd64.deb >>$OUTPUT 2>&1
                        cd - >>$OUTPUT 2>&1
                        #apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 0E98404D386FA1D9 >>$OUTPUT 2>&1
                    fi
                    #if [ $DISTRIBUTION = "stretch" ] || [ $DISTRIBUTION = "orel" ]; then
                    #    chroot_run $INSTALL_DIR apt-get install -y apt-transport-https >>$OUTPUT 2>&1
                    #fi
                    #curl https://minios-linux.github.io/debian/minios-linux.asc | gpg --dearmor >$INSTALL_DIR/etc/apt/trusted.gpg.d/minios-linux.gpg >>$OUTPUT 2>&1
                    #if [ $DISTRIBUTION = "kali-rolling" ] || [ $DISTRIBUTION_TYPE = "ubuntu" ]; then
                    #    echo "deb https://minios-linux.github.io/debian/ bookworm main contrib non-free" >$INSTALL_DIR/etc/apt/sources.list.d/minios-linux.list >>$OUTPUT 2>&1
                    #elif [ $DISTRIBUTION = "orel" ]; then
                    #    echo "deb https://minios-linux.github.io/debian/ stretch main contrib non-free" >$INSTALL_DIR/etc/apt/sources.list.d/minios-linux.list >>$OUTPUT 2>&1
                    #else
                    #    echo "deb https://minios-linux.github.io/debian/ $DISTRIBUTION main contrib non-free" >$INSTALL_DIR/etc/apt/sources.list.d/minios-linux.list >>$OUTPUT 2>&1
                    #fi
                fi
            else
                chroot $INSTALL_DIR apt-get update -y >>$OUTPUT 2>&1
                chroot $INSTALL_DIR apt-get install -y gnupg ca-certificates >>$OUTPUT 2>&1
                if [ $DISTRIBUTION = "orel" ]; then
                    cd $INSTALL_DIR >>$OUTPUT 2>&1
                    wget https://dl.astralinux.ru/astra/stable/2.12_x86-64/repository/pool/non-free/libg/libgost/libgost_2.0.2-5+ci2_amd64.deb >>$OUTPUT 2>&1
                    chroot_run $INSTALL_DIR apt-get install -y ./libgost_2.0.2-5+ci2_amd64.deb >>$OUTPUT 2>&1
                    rm $INSTALL_DIR/libgost_2.0.2-5+ci2_amd64.deb >>$OUTPUT 2>&1
                    cd - >>$OUTPUT 2>&1
                    #apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 0E98404D386FA1D9 >>$OUTPUT 2>&1
                fi
                #if [ $DISTRIBUTION = "stretch" ] || [ $DISTRIBUTION = "orel" ]; then
                #    chroot_run $INSTALL_DIR apt-get install -y apt-transport-https >>$OUTPUT 2>&1
                #fi
                #curl https://minios-linux.github.io/debian/minios-linux.asc | gpg --dearmor >$INSTALL_DIR/etc/apt/trusted.gpg.d/minios-linux.gpg >>$OUTPUT 2>&1
                #if [ $DISTRIBUTION = "kali-rolling" ] || [ $DISTRIBUTION_TYPE = "ubuntu" ]; then
                #    echo "deb https://minios-linux.github.io/debian/ bookworm main contrib non-free" >$INSTALL_DIR/etc/apt/sources.list.d/minios-linux.list >>$OUTPUT 2>&1
                #elif [ $DISTRIBUTION = "orel" ]; then
                #    echo "deb https://minios-linux.github.io/debian/ stretch main contrib non-free" >$INSTALL_DIR/etc/apt/sources.list.d/minios-linux.list >>$OUTPUT 2>&1
                #else
                #    echo "deb https://minios-linux.github.io/debian/ $DISTRIBUTION main contrib non-free" >$INSTALL_DIR/etc/apt/sources.list.d/minios-linux.list >>$OUTPUT 2>&1
                #fi
            fi

            if [ $BUILD_FROM_SNAPSHOT = "true" ]; then
                cp -f $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION-snapshot.list $INSTALL_DIR/etc/apt/sources.list
                echo 'Acquire::Check-Valid-Until "false";' | sudo tee $INSTALL_DIR/etc/apt/apt.conf.d/00snapshot
            else
                cp -f $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION.list $INSTALL_DIR/etc/apt/sources.list
            fi

            mx_repo
            antix_repo
            #mint_repo

            if [ -f /.minios-live-container ]; then
                if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
                    chroot_run $INSTALL_DIR apt-get update
                else
                    chroot_run $INSTALL_DIR apt-get update -y >>$OUTPUT 2>&1
                fi
            else
                chroot $INSTALL_DIR apt-get update -y >>$OUTPUT 2>&1
            fi

            if [ -f /.minios-live-container ]; then
                if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
                    chroot_run $INSTALL_DIR apt-get upgrade -y
                else
                    chroot_run $INSTALL_DIR apt-get upgrade -y >>$OUTPUT 2>&1
                fi
            else
                chroot $INSTALL_DIR apt-get upgrade -y >>$OUTPUT 2>&1
            fi

            if [ -f $SCRIPT_DIR/linux-live/package_lists/prerequisites.list ]; then
                if [ -f /.minios-live-container ]; then
                    if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
                        chroot_run $INSTALL_DIR apt-get install -y \
                            $(grep -vE "^\s*#" $SCRIPT_DIR/linux-live/package_lists/prerequisites.list | tr "\n" " ")
                    else
                        chroot_run $INSTALL_DIR apt-get install -y \
                            $(grep -vE "^\s*#" $SCRIPT_DIR/linux-live/package_lists/prerequisites.list | tr "\n" " ") >>$OUTPUT 2>&1
                    fi
                else
                    chroot $INSTALL_DIR apt-get install -y \
                        $(grep -vE "^\s*#" $SCRIPT_DIR/linux-live/package_lists/prerequisites.list | tr "\n" " ") >>$OUTPUT 2>&1
                fi
            fi

            if [ -f /.minios-live-container ]; then
                if [ -f /.minios-live-container ]; then
                    chroot_run $INSTALL_DIR apt-get clean -y
                else
                    chroot_run $INSTALL_DIR apt-get clean -y >>$OUTPUT 2>&1
                fi
            else
                chroot $INSTALL_DIR apt-get clean -y >>$OUTPUT 2>&1
            fi
            chroot_umount_fs

            tar -czf $SCRIPT_DIR/rootfs/$DISTRIBUTION-$DISTRIBUTION_ARCH-rootfs.tar.gz -C $INSTALL_DIR .
        fi
    fi
}

# =================================================================
#
#
# =================================================================
function copy_build_scripts() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."

    local DESTINATION
    set +u
    if [ -z $1 ]; then
        DESTINATION=$INSTALL_DIR
    else
        DESTINATION=$1
    fi
    set -u
    if [ ! -d $DESTINATION/linux-live ]; then
        mkdir -p $DESTINATION/linux-live
        (cd $SCRIPT_DIR/linux-live && cp --parents -afr * $DESTINATION/linux-live)
    else
        find $SCRIPT_DIR/linux-live -type f -not -path "*.git/*" -print0 | sed "s,$SCRIPT_DIR/linux-live/,,g" | while IFS= read -r -d '' file; do
            if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
                if ! cmp $SCRIPT_DIR/linux-live/"$file" $DESTINATION/linux-live/"$file"; then
                    echo -e "$file has been modified since last build run."
                    echo -e "Copying $SCRIPT_DIR/linux-live/$file to $DESTINATION/linux-live/$file..."
                    cp -f $SCRIPT_DIR/linux-live/"$file" $DESTINATION/linux-live/"$file"
                fi
            else
                if ! cmp $SCRIPT_DIR/linux-live/"$file" $DESTINATION/linux-live/"$file" >>$OUTPUT 2>&1; then
                    echo -e "$file has been modified since last build run." >>$OUTPUT 2>&1
                    echo -e "Copying $SCRIPT_DIR/linux-live/$file to $DESTINATION/linux-live/$file..." >>$OUTPUT 2>&1
                    cp -f $SCRIPT_DIR/linux-live/"$file" $DESTINATION/linux-live/"$file" >>$OUTPUT 2>&1
                fi
            fi
        done
    fi

    #chmod +x $DESTINATION/linux-live/build
    chmod +x $DESTINATION/linux-live/install_chroot

    if [ "$DEV_SYSTEM" = "true" ]; then
        if [ ! -d $DESTINATION/opt/minios-live ]; then
            mkdir -p $DESTINATION/opt/minios-live
            (cd $SCRIPT_DIR && cp --parents -afr * $DESTINATION/opt/minios-live)
        else
            find $SCRIPT_DIR/linux-live -type f -print0 | sed "s,$SCRIPT_DIR/linux-live/,,g" | while IFS= read -r -d '' file; do
                if ! cmp $SCRIPT_DIR/"$file" $DESTINATION/opt/minios-live/"$file" >>$OUTPUT 2>&1; then
                    echo -e "$file has been modified since last build run." >>$OUTPUT 2>&1
                    echo -e "Copying $SCRIPT_DIR/$file to $DESTINATION/opt/minios-live/$file..." >>$OUTPUT 2>&1
                    cp -f $SCRIPT_DIR/"$file" $DESTINATION/opt/minios-live/"$file" >>$OUTPUT 2>&1
                fi
            done
        fi
    elif [ $DOWNLOAD_SOURCES = "true" ]; then
        if [ ! -d $DESTINATION/opt/minios-live ]; then
            mkdir -p $DESTINATION/opt
            cd $DESTINATION/opt
            git clone --depth=1 https://github.com/minios-linux/minios-live.git >>$OUTPUT 2>&1
            if [ -d $DESTINATION/opt/minios-live/.git ]; then
                rm -rf $DESTINATION/opt/minios-live/.git >>$OUTPUT 2>&1
            fi
            if [ -f $DESTINATION/opt/minios-live/.gitignore ]; then
                rm -f $DESTINATION/opt/minios-live/.gitignore >>$OUTPUT 2>&1
            fi
        fi
    fi

    if [ -d $DESTINATION/opt/minios-live/.git ]; then
        rm -rf $DESTINATION/opt/minios-live/.git >>$OUTPUT 2>&1
    fi
    if [ -f $DESTINATION/opt/minios-live/.gitignore ]; then
        rm -f $DESTINATION/opt/minios-live/.gitignore >>$OUTPUT 2>&1
    fi

}

# =================================================================
#
#
# =================================================================
function build_chroot() {
    current_process

    if [ $CONTAINER_TYPE = "1" ]; then
        if [ ! -f /.minios-live ]; then
            setup_host
        fi
    fi

    chroot_mount_fs

    copy_build_scripts

    create_apt_list

    if [ "$OUTPUT"="$LOGPATH/$LIVEKITNAME.log" ] && [ -f /$LIVEKITNAME.log ]; then
        mv -f /$LIVEKITNAME.log $INSTALL_DIR/$LIVEKITNAME.log
    fi
    if [ "$OUTPUT"="$LOGPATH/$LIVEKITNAME.log" ] && [ -f $INSTALL_DIR/$LIVEKITNAME.log ]; then
        echo "===========================================" >>$INSTALL_DIR/$LIVEKITNAME.log 2>&1
        echo "===========================================" >>$INSTALL_DIR/$LIVEKITNAME.log 2>&1
        echo "=============== CHROOT LOG ================" >>$INSTALL_DIR/$LIVEKITNAME.log 2>&1
        echo "===========================================" >>$INSTALL_DIR/$LIVEKITNAME.log 2>&1
        echo "===========================================" >>$INSTALL_DIR/$LIVEKITNAME.log 2>&1
    fi

    if [ $BUILD_FROM_SNAPSHOT = "true" ]; then
        cp -f $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION-snapshot.list $INSTALL_DIR/etc/apt/sources.list
    else
        cp -f $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION.list $INSTALL_DIR/etc/apt/sources.list
    fi
    #if [ $LOCALE = "ru_RU" ]; then
    #    sed -i "s/deb.debian.org/mirror.yandex.ru/g;s/security.debian.org/mirror.yandex.ru/g" $INSTALL_DIR/etc/apt/sources.list
    #fi

    VANILLA_ASTRA="true"
    if [ $DISTRIBUTION = "orel" ]; then
        if [ $VANILLA_ASTRA != "true" ]; then
            #apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 0E98404D386FA1D9
            cat $SCRIPT_DIR/linux-live/aptsources/stretch.list | sed '/backports/d' >$INSTALL_DIR/etc/apt/sources.list.d/stretch.list
        fi
    fi

    add_unofficial_repository

    if [ -f /.minios-live-container ]; then
        chroot_run $INSTALL_DIR /linux-live/install_chroot -
    else
        chroot $INSTALL_DIR /linux-live/install_chroot -
    fi

    remove_unofficial_repository

    chroot_umount_fs

    if [ "$OUTPUT"="$LOGPATH/$LIVEKITNAME.log" ] && [ -f $INSTALL_DIR/$LIVEKITNAME.log ]; then
        mv -f $INSTALL_DIR/$LIVEKITNAME.log $SCRIPT_DIR/$LIVEKITNAME.log
        if [ -f $SCRIPT_DIR/$LIVEKITNAME.log ]; then
            echo -e "Installation log was saved to ${MAGENTA}$SCRIPT_DIR/$LIVEKITNAME.log${ENDCOLOR}"
        fi
    fi
}

function mkmod_corefs() {
    local FOLDER
    cd $1
    COREFS=""
    for FOLDER in $MKMOD; do
        if [ -d $1/$FOLDER ]; then
            COREFS="$COREFS $FOLDER"
        fi
    done
}

# =================================================================
#
#
# =================================================================
function build_live() {
    current_process

    if [ $CONTAINER_TYPE = "1" ]; then
        if [ ! -f /.minios-live ]; then
            setup_host
        fi
    fi

    remove_log_file

    copy_build_scripts

    check_install_dir

    rm -rf $WORK_DIR/image
    mkdir -p $WORK_DIR/image/$LIVEKITNAME/{boot,changes,modules}

    #build_boot

    # create compressed 00-core.sb
    mkmod_corefs $INSTALL_DIR

    #mksquashfs $COREFS $WORK_DIR/image/$LIVEKITNAME/00-core-$COMP_TYPE.$BEXT -comp $COMP_TYPE -b 1024K -always-use-fragments -keep-as-directory -noappend || exit
    if [ $COMP_TYPE = "zstd" ]; then
        time mksquashfs $COREFS $WORK_DIR/image/$LIVEKITNAME/00-core-$DISTRIBUTION_ARCH-$COMP_TYPE.$BEXT -comp $COMP_TYPE -Xcompression-level 19 -b 1024K -always-use-fragments -noappend || exit
    else
        time mksquashfs $COREFS $WORK_DIR/image/$LIVEKITNAME/00-core-$DISTRIBUTION_ARCH-$COMP_TYPE.$BEXT -comp $COMP_TYPE -b 1024K -always-use-fragments -noappend || exit
    fi
}

function build_config() {
    current_process

    if [ -d $WORK_DIR/image/$LIVEKITNAME ]; then
        cat <<EOF >$WORK_DIR/image/$LIVEKITNAME/$LIVEKITNAME.conf
USER_NAME="$USER_NAME"
USER_PASSWORD="$USER_PASSWORD"
ROOT_PASSWORD="$ROOT_PASSWORD"
HOST_NAME="$LIVEKITNAME"
DEFAULT_TARGET="$DEFAULT_TARGET"
ENABLE_SERVICES="$ENABLE_SERVICES"
DISABLE_SERVICES="$DISABLE_SERVICES"
SSH_KEY="$SSH_KEY"
CLOUD="$CLOUD"
SCRIPTS="$SCRIPTS"
HIDE_CREDENTIALS="$HIDE_CREDENTIALS"
AUTOLOGIN="$AUTOLOGIN"
CORE_BUNDLE_PREFIX="00-core"
BEXT="$BEXT"

EOF
    fi
}

# =================================================================
#
#
# =================================================================
function build_boot() {
    current_process
    #echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."

    local OLD_KERNEL

    if [ $CONTAINER_TYPE = "1" ]; then
        if [ ! -f /.minios-live ]; then
            setup_host
        fi
    fi

    copy_build_scripts

    check_install_dir

    #if [ $CLOUD != "true" ]; then
    cp -r $SCRIPT_DIR/linux-live/bootfiles/* $WORK_DIR/image/$LIVEKITNAME
    #fi

    if [ $DESKTOP_ENVIRONMENT = "cloud" ]; then
        BOOT_TYPE="hybrid"
    fi
    if [ $BOOT_TYPE = "hybrid" ]; then
        if [ $DISTRIBUTION_ARCH = "amd64" ]; then
            rm -rf $WORK_DIR/image/$LIVEKITNAME/boot/grub/i386-efi
            rm $WORK_DIR/image/$LIVEKITNAME/boot/grub/efi32.img
            rm $WORK_DIR/image/$LIVEKITNAME/boot/EFI/boot/*32.efi
            mv $WORK_DIR/image/$LIVEKITNAME/boot/grub/efi64.img $WORK_DIR/image/$LIVEKITNAME/boot/grub/efi.img
            cat <<EOF >$WORK_DIR/image/$LIVEKITNAME/boot/EFI/debian/grub.cfg
search --file --set=root /.disk/info
set prefix=(\$root)/minios/boot/grub
source \$prefix/x86_64-efi/grub.cfg
EOF
            cat <<EOF >$WORK_DIR/image/$LIVEKITNAME/boot/grub/x86_64-efi/grub.cfg
insmod part_acorn
insmod part_amiga
insmod part_apple
insmod part_bsd
insmod part_dfly
insmod part_dvh
insmod part_gpt
insmod part_msdos
insmod part_plan
insmod part_sun
insmod part_sunpc
source /$LIVEKITNAME/boot/grub/grub.cfg

EOF
        elif [[ $DISTRIBUTION_ARCH == *"i386"* ]]; then
            rm -rf $WORK_DIR/image/$LIVEKITNAME/boot/grub/x86_64-efi
            rm $WORK_DIR/image/$LIVEKITNAME/boot/grub/efi64.img
            rm $WORK_DIR/image/$LIVEKITNAME/boot/EFI/boot/*64.efi
            mv $WORK_DIR/image/$LIVEKITNAME/boot/grub/efi32.img $WORK_DIR/image/$LIVEKITNAME/boot/grub/efi.img
            cat <<EOF >$WORK_DIR/image/$LIVEKITNAME/boot/EFI/debian/grub.cfg
search --file --set=root /.disk/info
set prefix=(\$root)/minios/boot/grub
source \$prefix/i386-efi/grub.cfg
EOF
            cat <<EOF >$WORK_DIR/image/$LIVEKITNAME/boot/grub/i386-efi/grub.cfg
insmod part_acorn
insmod part_amiga
insmod part_apple
insmod part_bsd
insmod part_dfly
insmod part_dvh
insmod part_gpt
insmod part_msdos
insmod part_plan
insmod part_sun
insmod part_sunpc
source /$LIVEKITNAME/boot/grub/grub.cfg

EOF
        fi

        if [ ! -d $WORK_DIR/image/EFI ]; then
            mkdir -p $WORK_DIR/image/EFI
        fi
        cp -r $WORK_DIR/image/$LIVEKITNAME/boot/EFI/* $WORK_DIR/image/EFI
        #cp -r $SCRIPT_DIR/linux-live/bootfiles-grub/* $WORK_DIR/image
        #if [ ! -d $WORK_DIR/image/$LIVEKITNAME/boot/grub ]; then
        #    mkdir $WORK_DIR/image/$LIVEKITNAME/boot/grub
        #fi
        #cp -r $SCRIPT_DIR/linux-live/bootfiles-grub/* $WORK_DIR/image/$LIVEKITNAME/boot/grub
        if [ ! -d $WORK_DIR/image/.disk ]; then
            mkdir -p $WORK_DIR/image/.disk
        fi
        echo $SYSTEMNAME >$WORK_DIR/image/.disk/info
    else
        rm -rf $WORK_DIR/image/$LIVEKITNAME/boot/grub
        rm -rf $WORK_DIR/image/$LIVEKITNAME/boot/EFI
    fi

    if [ $PACKAGE_VARIANT = "standard" ] || [ $PACKAGE_VARIANT = "maximum" ] || [ $PACKAGE_VARIANT = "ultra" ]; then
        ENABLE_SERVICES="ssh,firewalld"
    elif [ $PACKAGE_VARIANT = "minimum" ]; then
        ENABLE_SERVICES="ssh"
    fi
    DEFAULT_SETTINGS="load_ramdisk=1 prompt_ramdisk=0 rw printk.time=0 consoleblank=0 apparmor=0 net.ifnames=0 biosdevname=0"
    #if [ $INITRD_TYPE = "livekit-mos" ]; then
    #    BOOT_SETTINGS="quiet enable_services=$ENABLE_SERVICES"
    #else
    BOOT_SETTINGS="quiet"
    #fi
    if [ $INITRD_TYPE = "livekit-mos" ]; then
        PERCH_SETTINGS="minios.flags=perch"
        LIVE_SETTINGS="minios.flags="
        RAM_SETTINGS="minios.flags=toram"
    elif [ $INITRD_TYPE = "livekit-slax" ]; then
        PERCH_SETTINGS="slax.flags=perch"
        LIVE_SETTINGS="slax.flags="
        RAM_SETTINGS="slax.flags=toram"
    elif [ $INITRD_TYPE = "uird" ]; then
        if [ $KERNEL_AUFS = "true" ] || ([ $DISTRIBUTION = "bionic" ] || [ $DISTRIBUTION = "focal" ]); then
            PERCH_SETTINGS=""
            LIVE_SETTINGS="uird.mode=clean"
            RAM_SETTINGS="uird.copy2ram"
        else
            PERCH_SETTINGS="uird.union=overlay"
            LIVE_SETTINGS="uird.union=overlay uird.mode=clean"
            RAM_SETTINGS="uird.union=overlay uird.copy2ram"
        fi
    fi

    if [ $DESKTOP_ENVIRONMENT = "mediaplayer" ]; then
        #BOOT_SETTINGS="hide_credentials enable_services=$ENABLE_SERVICES"
        BOOT_SETTINGS="hide_credentials"
    elif [ $PACKAGE_VARIANT = "minimum" ]; then
        if [ $DESKTOP_ENVIRONMENT = "slax" ]; then
            #BOOT_SETTINGS="user_name=root enable_services=$ENABLE_SERVICES"
            BOOT_SETTINGS="user_name=root"
        fi
        if [ $INITRD_TYPE = "livekit-mos" ]; then
            PERCH_SETTINGS="minios.flags=perch,automount"
            LIVE_SETTINGS="minios.flags=automount"
        elif [ $INITRD_TYPE = "livekit-slax" ]; then
            PERCH_SETTINGS="slax.flags=perch,automount"
            LIVE_SETTINGS="slax.flags=automount"
        fi
    fi

    cat <<EOF | iconv -f 'UTF-8' -t "CP866//TRANSLIT" >$WORK_DIR/image/$LIVEKITNAME/boot/syslinux.cfg
UI /$LIVEKITNAME/boot/vesamenu.c32

PROMPT 0
TIMEOUT 30

MENU CLEAR
MENU HIDDEN
MENU HIDDENKEY Enter default
MENU BACKGROUND /$LIVEKITNAME/boot/bootlogo.png

MENU WIDTH 80
MENU MARGIN 20
MENU ROWS 5
MENU TABMSGROW 9
MENU CMDLINEROW 9
MENU HSHIFT 0
MENU VSHIFT 19

MENU COLOR BORDER  30;40      #00000000 #00000000 none
MENU COLOR SEL     47;30      #FF000000 #FFFFFFFF none
MENU COLOR UNSEL   37;40      #FFFFFFFF #FF000000 none
MENU COLOR TABMSG  32;40      #FF60CA00 #FF000000 none

F1 help.txt /$LIVEKITNAME/boot/zblack.png

MENU AUTOBOOT Press Esc for options, automatic boot in # second{,s} ...
MENU TABMSG [F1] help                                                        [Tab] cmdline >

EOF
    cat <<EOF >$WORK_DIR/image/$LIVEKITNAME/boot/grub/grub.cfg
if loadfont \$prefix/font.pf2 ; then
  set default="0"
  set timeout="3"
  set hidden_timeout_quiet=false
  set gfxmode=auto
  insmod efi_gop
  insmod efi_uga
  insmod video_bochs
  insmod video_cirrus
  insmod gfxterm
  insmod png
  terminal_output gfxterm
fi
set color_normal=white/black
set color_highlight=black/white
background_image \$prefix/bootlogo.png

set default_settings="$DEFAULT_SETTINGS"
set perch_settings="$PERCH_SETTINGS"
set live_settings="$LIVE_SETTINGS"
set ram_settings="$RAM_SETTINGS"
set console_settings="console=tty0 console=ttyS0,115200"
set debug_settings="load_ramdisk=1 prompt_ramdisk=0 rw printk.time=0 apparmor=0 debug net.ifnames=0 biosdevname=0 enable_services=$ENABLE_SERVICES"
set linux_image="/$LIVEKITNAME/boot/vmlinuz"
set initrd_img="/$LIVEKITNAME/boot/initrfs.img"
set default=0
set message="Loading kernel and ramdisk..."

EOF

    if [ $DESKTOP_ENVIRONMENT = "cloud" ]; then
        cat <<EOF | iconv -f 'UTF-8' -t "CP866//TRANSLIT" >>$WORK_DIR/image/$LIVEKITNAME/boot/syslinux.cfg
LABEL default
MENU LABEL Run MiniOS (Copy to RAM)
KERNEL /$LIVEKITNAME/boot/vmlinuz
APPEND vga=normal initrd=/$LIVEKITNAME/boot/initrfs.img $DEFAULT_SETTINGS $RAM_SETTINGS console=tty0 console=ttyS0,115200 $BOOT_SETTINGS

EOF
        cat <<EOF >>$WORK_DIR/image/$LIVEKITNAME/boot/grub/grub.cfg
menuentry "Run MiniOS (Copy to RAM)"{
    echo \$message
    search --set -f \$linux_image
    linux \$linux_image \$default_settings \$ram_settings \$console_settings $BOOT_SETTINGS
    initrd \$initrd_img
}

EOF
        sed -i "s/background_image/#background_image/g" $WORK_DIR/image/$LIVEKITNAME/boot/grub/grub.cfg
    elif [ $DESKTOP_ENVIRONMENT = "mediaplayer" ]; then
        cat <<EOF | iconv -f 'UTF-8' -t "CP866//TRANSLIT" >>$WORK_DIR/image/$LIVEKITNAME/boot/syslinux.cfg
LABEL default
MENU LABEL Run MiniOS (Copy to RAM)
KERNEL /$LIVEKITNAME/boot/vmlinuz
APPEND vga=normal initrd=/$LIVEKITNAME/boot/initrfs.img $DEFAULT_SETTINGS $RAM_SETTINGS $BOOT_SETTINGS

EOF
        cat <<EOF >>$WORK_DIR/image/$LIVEKITNAME/boot/grub/grub.cfg
menuentry "Run MiniOS (Copy to RAM)"{
    echo \$message
    search --set -f \$linux_image
    linux \$linux_image \$default_settings \$ram_settings $BOOT_SETTINGS
    initrd \$initrd_img
}

EOF
    else
        cat <<EOF | iconv -f 'UTF-8' -t "CP866//TRANSLIT" >>$WORK_DIR/image/$LIVEKITNAME/boot/syslinux.cfg
LABEL default
MENU LABEL Run MiniOS (Persistent changes)
KERNEL /$LIVEKITNAME/boot/vmlinuz
APPEND vga=normal initrd=/$LIVEKITNAME/boot/initrfs.img $DEFAULT_SETTINGS $PERCH_SETTINGS $BOOT_SETTINGS

LABEL live
MENU LABEL Run MiniOS (Fresh start)
KERNEL /$LIVEKITNAME/boot/vmlinuz
APPEND vga=normal initrd=/$LIVEKITNAME/boot/initrfs.img $DEFAULT_SETTINGS $LIVE_SETTINGS $BOOT_SETTINGS

LABEL toram
MENU LABEL Run MiniOS (Copy to RAM)
KERNEL /$LIVEKITNAME/boot/vmlinuz
APPEND vga=normal initrd=/$LIVEKITNAME/boot/initrfs.img $DEFAULT_SETTINGS $RAM_SETTINGS $BOOT_SETTINGS

EOF
        cat <<EOF >>$WORK_DIR/image/$LIVEKITNAME/boot/grub/grub.cfg
menuentry "Run MiniOS (Persistent changes)"{
    echo \$message
    search --set -f \$linux_image
    linux \$linux_image \$default_settings \$perch_settings $BOOT_SETTINGS
    initrd \$initrd_img
}
menuentry "Run MiniOS (Fresh start)"{
    echo \$message
    search --set -f \$linux_image
    linux \$linux_image \$default_settings \$live_settings $BOOT_SETTINGS
    initrd \$initrd_img
}
menuentry "Run MiniOS (Copy to RAM)"{
    echo \$message
    search --set -f \$linux_image
    linux \$linux_image \$default_settings \$ram_settings $BOOT_SETTINGS
    initrd \$initrd_img
}

EOF
    fi

    if [ $LOCALE = "ru_RU" ]; then
        cat <<EOF >$WORK_DIR/image/README
################################### README ####################################
* Для установки MiniOS скопируйте содержимое ISO в корень носителя,
  затем запустите $LIVEKITNAME\boot\bootinst.bat в Windows или 
  $LIVEKITNAME/boot/bootinst.sh в Linux.
* При установке на носители с файловыми системами fat32 и ntfs изменения в
  режиме постоянных изменений будут сохранены в файле
  $LIVEKITNAME\changes\changes.dat, файл расширяется динамически, максимальный размер
  файла 4 ГБ (можно изменить  параметром changes_size в параметрах загрузки,
  например, changes_size=2000 установит максимальный размер файла в 2 ГБ).
* При установке на носители с файловыми системами ext2-ext4, xfs, btrfs
  изменения в режиме постоянных изменений будут сохранены в папке
  $LIVEKITNAME\changes без ограничений по размеру.
###############################################################################
EOF
    else
        cat <<EOF >$WORK_DIR/image/README
################################### README ####################################
* To install MiniOS, copy the contents of the ISO to the root of the media,
  then run $LIVEKITNAME\boot\bootinst.bat on Windows, or $LIVEKITNAME/boot/bootinst.sh
  on Linux.
* When installed on media with fat32 and ntfs file systems, changes in
  persistent changes mode will be saved in the $LIVEKITNAME\changes\changes.dat file,
  the file expands dynamically, the maximum file size is 4 GB (can be changed
  with the changes_size parameter in the boot options, for example
  changes_size=2000 will set the maximum file size to 2 GB).
* When installed on media with ext2-ext4, xfs, btrfs file systems, changes in
  the persistent changes mode will be saved in the $LIVEKITNAME\changes folder with
  no size limit.
###############################################################################
EOF
    fi

    #if [ $BOOT_TYPE = "hybrid" ]; then
    #    cp $WORK_DIR/image/$LIVEKITNAME/boot/grub/grub.cfg $WORK_DIR/image/$LIVEKITNAME/boot/grub/boot/grub
    #fi

    if [[ $MODULE == *"kernel"* ]] || [[ $MODULE == *"linux"* ]]; then
        if [ -f $MODULE_UPPER_DIR/miniosbuild.conf ]; then
            read_config $MODULE_UPPER_DIR/miniosbuild.conf KERNEL
        fi
        copy_build_scripts $MODULE_MERGED_DIR
        chmod +x $MODULE_MERGED_DIR/linux-live/initrfs
        chroot $MODULE_MERGED_DIR /linux-live/initrfs
        # copy boot files
        kernel_variables
        cp $MODULE_MERGED_DIR/boot/vmlinuz-* $WORK_DIR/image/$LIVEKITNAME/boot/$VMLINUZNAME
        cp $MODULE_MERGED_DIR/boot/initrfs.img $WORK_DIR/image/$LIVEKITNAME/boot/$INITRFSNAME
        sed -i "s,/boot/vmlinuz,/boot/$VMLINUZNAME,g;s,/boot/initrfs.img,/boot/$INITRFSNAME,g" $WORK_DIR/image/$LIVEKITNAME/boot/syslinux.cfg
        sed -i "s,/boot/vmlinuz,/boot/$VMLINUZNAME,g;s,/boot/initrfs.img,/boot/$INITRFSNAME,g" $WORK_DIR/image/$LIVEKITNAME/boot/grub/grub.cfg
        if [ -d $MODULE_MERGED_DIR/linux-live ]; then
            rm -rf $MODULE_MERGED_DIR/linux-live
        fi
    fi
}
# =================================================================
#
#
# =================================================================
function build_iso() {
    current_process

    if [ $CONTAINER_TYPE = "1" ]; then
        if [ ! -f /.minios-live ]; then
            setup_host
        fi
    fi

    check_install_dir

    if [ "$UNATTENDED" = "true" ]; then
        INSTALL_DIR="$WORK_DIR/basesystem"
    fi
    if [ "$INSTALL_DIR" = "" ]; then
        LAST_INSTALL_DIR=$(cat "$SCRIPT_DIR/.install_dir") >>$OUTPUT 2>&1
        INSTALL_DIR=$LAST_INSTALL_DIR
    fi

    cd $WORK_DIR/image
    if [ ! -d $ISO_DIR ]; then
        mkdir -p $ISO_DIR
    fi

    mkdir -p $ISO_DIR >>$OUTPUT 2>&1
    #VER=$SYSTEMVER
    DATE=$(date +%Y%m%d_%H%M)

    DIR=$WORK_DIR/image

    language_to_array

    if [ $DESKTOP_ENVIRONMENT = "cloud" ] || [ $DESKTOP_ENVIRONMENT = "pve" ] || [ $DESKTOP_ENVIRONMENT = "xfce-ultra" ] || [ $DESKTOP_ENVIRONMENT = "xfce-frugal" ] || [ $DESKTOP_ENVIRONMENT = "xfce-frugal-base" ]; then
        IMAGE=$LIVEKITNAME-$DISTRIBUTION-$DESKTOP_ENVIRONMENT
    else
        if [ $KERNEL_TYPE = "default" ]; then
            IMAGE=$LIVEKITNAME-$DISTRIBUTION-$DESKTOP_ENVIRONMENT-$PACKAGE_VARIANT
        else
            IMAGE=$LIVEKITNAME-$DISTRIBUTION-$DESKTOP_ENVIRONMENT-$PACKAGE_VARIANT-$KERNEL_TYPE
        fi
    fi
    if [ $LOCALE != "en_US" ]; then
        IMAGE=$IMAGE-${LANG[0]}-$ISO_ARCH-$INITRD_TYPE
    else
        IMAGE=$IMAGE-${LANG[0]}-$ISO_ARCH-$INITRD_TYPE
    fi
    if [ $KERNEL_AUFS = "true" ]; then
        IMAGE=$IMAGE-aufs
    fi
    if [ $BUILD_FROM_SNAPSHOT = "true" ]; then
        IMAGE=$IMAGE-$SNAPSHOT_DATE
    fi
    ISO=$ISO_DIR/$IMAGE-$COMP_TYPE-$DATE.iso

    B="-b $LIVEKITNAME/boot/isolinux.bin -c $LIVEKITNAME/boot/isolinux.boot"

    if [ $BOOT_TYPE = "hybrid" ]; then
        C="-no-emul-boot -boot-load-size 4 -boot-info-table -eltorito-alt-boot"
    else
        C="-no-emul-boot -boot-load-size 4 -boot-info-table"
    fi

    #                        ▼ should only be a redirect error!
    if [ -x "$(which xorriso 2>>$OUTPUT)" ] && [ $BOOT_TYPE = "hybrid" ]; then
        M="xorriso -as mkisofs -isohybrid-mbr $DIR/$LIVEKITNAME/boot/isohdpfx.bin"
        D=" -isohybrid-gpt-basdat -e"
    elif [ -x "$(which genisoimage 2>>$OUTPUT)" ]; then
        M=genisoimage
        if [ $BOOT_TYPE = "hybrid" ]; then
            D="-efi-boot"
        else
            D=""
        fi
    fi
    if [ $BOOT_TYPE = "hybrid" ]; then
        E="$LIVEKITNAME/boot/grub/efi.img -no-emul-boot"
    else
        E=""
    fi

    VER="$SYSTEMNAME"

    if [ $REMOVE_OLD_ISO = "true" ]; then
        set +e
        rm $ISO_DIR/$IMAGE-$COMP_TYPE-*.iso >>$OUTPUT 2>&1
        while [ -f $ISO_DIR/$LIVEKITNAME.iso ]; do
            rm $ISO_DIR/$LIVEKITNAME.iso >>$OUTPUT 2>&1
            sleep 1
        done
        set -e
    fi

    if [ $BOOT_TYPE = "hybrid" ]; then
        if
            ! $M -hide-rr-moved -f -r -J -l -V "$VER" -A "$VER" \
                $B $C $D $E -o $ISO $DIR
        then
            exit 1
        fi
        # testing iso boot transition to grub.
        : 'xorriso -as mkisofs -r \
            -V "$VER" \
            -o "$ISO-2" \
            --grub2-mbr "$LIVEKITNAME/boot/grub/boot_hybrid.img" \
            -partition_offset 16 \
            --mbr-force-bootable \
            -append_partition 2 28732ac11ff8d211ba4b00a0c93ec93b "$LIVEKITNAME/boot/grub/efi.img" \
            -appended_part_as_gpt \
            -iso_mbr_part_type a2a0d0ebe5b9334487c068b6b72699c7 \
            -c "$LIVEKITNAME/boot/grub/boot.catalog" \
            -b "$LIVEKITNAME/boot/grub/i386-pc/eltorito.img" \
            -no-emul-boot -boot-load-size 4 -boot-info-table --grub2-boot-info \
            -eltorito-alt-boot \
            -e "--interval:appended_partition_2:::" \
            -no-emul-boot \
            $DIR'
    else
        if
            ! $M -f -r -J -l -V "$VER" -A "$VER" \
                $B $C $D $E -o $ISO $DIR
        then
            exit 1
        fi
    fi

    echo ">>> $ISO created"

    if [ $BUILD_TEST_ISO = "true" ]; then
        if [ -L $ISO_DIR/$LIVEKITNAME.iso ]; then
            rm $ISO_DIR/$LIVEKITNAME.iso
        fi
        while [ -f $ISO_DIR/$LIVEKITNAME.iso ]; do
            rm $ISO_DIR/$LIVEKITNAME.iso >>$OUTPUT 2>&1
            sleep 1
        done
        if ln $ISO $ISO_DIR/$LIVEKITNAME.iso; then
            echo ">>> $ISO_DIR/$LIVEKITNAME.iso created"
        fi
    fi

    #exit 0
}

function remove_sources() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."
    if [ $REMOVE_SOURCES = "true" ]; then
        cleanup
    fi
    exit 0
}

# =================================================================
# =================================================================
# ====================== INSTALL FUNCTIONS ========================
# =================================================================
# =================================================================

# =================================================================
#
#
# =================================================================
function setup_host() {
    if [ $SKIP_SETUP_HOST != "true" ]; then
        current_process

        if [ $CONTAINER_TYPE != "2" ]; then
            hostreq_pkg_list
        fi
    fi
}

# =================================================================
#
#
# =================================================================
function chroot_setup_host() {
    current_process

    echo $LIVEKITNAME >/etc/hostname

    install_prerequesited_packages

    #configure machine id
    dbus-uuidgen >/etc/machine-id >>$OUTPUT 2>&1
    ln -fs /etc/machine-id /var/lib/dbus/machine-id >>$OUTPUT 2>&1

    # don't understand why, but multiple sources indicate this
    dpkg-divert --local --rename --add /sbin/initctl >>$OUTPUT 2>&1
    ln -s /bin/true /sbin/initctl >>$OUTPUT 2>&1

    current_process
}

# =================================================================
#
#
# =================================================================
function chroot_cleanup() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."

    set +eu

    rm -f $1/$LIVEKITNAME.conf
    rm -f $1/functions
    rm -f $1/preinstall
    rm -f $1/install
    rm -f $1/build
    rm -f $1/cleanup
    rm -f $1/$PACKAGE_VARIANT.list
    rm -f $1/package.list
    rm -f $1/postinstall
    rm -rf $1/rootcopy-install
    rm -rf $1/rootcopy
    rm -rf $1/patches

    rm -f $1/etc/fstab
    rm -f $1/etc/mtab
    rm -f $1/etc/apt/sources.list~
    rm -Rf $1/etc/systemd/system/timers.target.wants
    #rm -f $1/etc/systemd/system/multi-user.target.wants/ssh.service
    rm -f $1/etc/systemd/system/multi-user.target.wants/dnsmasq.service

    rm -f $1/etc/ssh/ssh_host*

    rm -f $1/var/backups/*
    rm -f $1/var/cache/ldconfig/*
    rm -f $1/var/cache/debconf/*
    rm -f $1/var/cache/fontconfig/*
    rm -f $1/var/lib/apt/extended_states
    rm -f $1/var/lib/systemd/random-seed
    rm -f $1/var/lib/apt/lists/deb.*
    rm -Rf $1/root/.local/share/mc
    rm -Rf $1/root/.cache
    rm -f $1/root/.wget-hsts

    rm -f $1/var/lib/dpkg/*-old
    rm -f $1/var/log/*
    rm -f $1/var/log/*/*
    rm -f $1/var/log/*/*/*
    rm -f $1/var/cache/apt/archives/*.deb
    rm -f $1/var/cache/apt/*.bin
    rm -f $1/var/cache/debconf/*-old
    rm -f $1/var/lib/dhcp/dhclient.leases
    rm -f $1/root/.bash_history
    rm -f $1/root/.wget-hsts
    rm -Rf $1/usr/share/doc/*
    rm -Rf $1/usr/share/info/*
    rm -f $1/usr/share/images/fluxbox/debian-squared.jpg
    rm -Rf $1/usr/share/fluxbox/nls/??*
    rm -Rf $1/usr/share/gnome/help
    if [ $LOCALE != "en_US" ]; then
        language_to_array
        for UNUSED_LOCALE in $(ls -d $1/usr/share/locale/?? | sed "/en/d;/${LANG[0]}/d"); do
            rm -Rf $UNUSED_LOCALE
        done
        for UNUSED_LOCALE in $(ls -d $1/usr/share/locale/??_* | sed "/en/d;/${LANG[0]}/d"); do
            rm -Rf $UNUSED_LOCALE
        done
        for UNUSED_LOCALE in $(ls -d $1/usr/share/locale/??@* | sed "/en/d;/${LANG[0]}/d"); do
            rm -Rf $UNUSED_LOCALE
        done
        for UNUSED_LOCALE in $(ls -d $1/usr/share/locale/??? | sed "/en/d;/${LANG[0]}/d"); do
            rm -Rf $UNUSED_LOCALE
        done
        for UNUSED_LOCALE in $(ls -d $1/usr/share/i18n/locales/*_* | sed "/en/d;/${LANG[0]}/d"); do
            UNUSED_LOCALE=$(basename $UNUSED_LOCALE)
            if [ $UNUSED_LOCALE == "i18n"* ] || [ $UNUSED_LOCALE == "iso14651"* ]; then
                rm -Rf $1/usr/share/i18n/locales/$UNUSED_LOCALE
            fi
        done
    else
        rm -Rf $1/usr/share/locale/??
        rm -Rf $1/usr/share/locale/??_*
        rm -Rf $1/usr/share/locale/??@*
        rm -Rf $1/usr/share/locale/???
        rm -Rf $1/usr/share/i18n/locales/*_*
    fi
    rm -Rf $1/usr/share/man/??
    rm -Rf $1/usr/share/man/*_*

    rm -Rf $1/usr/share/icons/elementaryXubuntu-dark
    rm -Rf $1/usr/share/icons/gnome/256x256
    if [ $REMOVE_LARGE_ICONS = "true" ]; then
        find $1/usr/share/icons/ -name 256x256 -o -name 512x512 -o -name 1024x1024 | xargs rm -rf
    fi

    rm $1/usr/share/applications/compton.desktop
    rm $1/usr/share/applications/debian-uxterm.desktop
    rm $1/usr/share/applications/debian-xterm.desktop
    rm $1/usr/share/applications/htop.desktop
    rm $1/usr/share/applications/mc.desktop
    rm $1/usr/share/applications/mcedit.desktop
    rm $1/usr/share/applications/pcmanfm-desktop-pref.desktop
    rm $1/usr/share/applications/python2.*.desktop
    rm $1/usr/share/applications/python3.*.desktop
    rm $1/usr/share/applications/vim.desktop

    if [ -z $1 ]; then
        uncompress_files $1/etc/alternatives
        uncompress_files $1/usr/share/man

        remove_broken_links $1/etc/alternatives
        remove_broken_links $1/usr/share/man
    fi

    set -eu
}

# =================================================================
#
#
# =================================================================
function hostreq_pkg_list() {
    echo -e "${YELLOW}=====> installing required software for host system ...${ENDCOLOR}"
    apt-get update >>$OUTPUT 2>&1

    if [ -f $SCRIPT_DIR/linux-live/package_lists/required_for_host.list ]; then
        apt-get install -y \
            $(grep -vE "^\s*#" $SCRIPT_DIR/linux-live/package_lists/required_for_host.list | tr "\n" " ") >>$OUTPUT 2>&1
    else
        apt-get install -y \
            sudo debootstrap genisoimage >>$OUTPUT 2>&1
    fi
    if [ $DISTRIBUTION_ARCH = "arm64" ]; then
        apt-get install -y \
            grub-efi-arm64-bin >>$OUTPUT 2>&1
    else
        apt-get install -y \
            grub-efi-amd64-bin grub-pc-bin >>$OUTPUT 2>&1
    fi
}

# =================================================================
#
#
# =================================================================
function install_prerequesited_packages() {
    echo -e "${YELLOW}=====> installing prerequested software for chroot system ...${ENDCOLOR}"

    if [ ! -f /etc/apt/apt.conf.d/000MiniOS ]; then
        cat <<'EOF' >/etc/apt/apt.conf.d/000MiniOS
APT::Install-Recommends "0";
APT::Install-Suggests "0";
Acquire::Languages { "none"; }
EOF
    fi
    if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
        if [ -f $SCRIPT_DIR/package_lists/prerequisites.list ]; then
            apt-get update
            echo -e "${YELLOW}=====> upgrading chroot system ...${ENDCOLOR}" &&
                apt-get upgrade -y >>$OUTPUT 2>&1 &&
                echo -e "${YELLOW}=====> installing packages ...${ENDCOLOR}" &&
                apt-get install -y \
                    $(grep -vE "^\s*#" $SCRIPT_DIR/package_lists/prerequisites.list | tr "\n" " ")
        fi
    else
        if [ -f $SCRIPT_DIR/package_lists/prerequisites.list ]; then
            apt-get update >>$OUTPUT 2>&1 &&
                echo -e "${YELLOW}=====> upgrading chroot system ...${ENDCOLOR}" &&
                apt-get upgrade -y >>$OUTPUT 2>&1 &&
                echo -e "${YELLOW}=====> installing packages ...${ENDCOLOR}" &&
                apt-get install -y \
                    $(grep -vE "^\s*#" $SCRIPT_DIR/package_lists/prerequisites.list | tr "\n" " ") >>$OUTPUT 2>&1
        fi
    fi

}

# =================================================================
#
#
# =================================================================
function install_core_packages() {
    echo -e "${YELLOW}=====> installing main packages for chroot system ...${ENDCOLOR}"

    get_vars

    if [ -f /linux-live/basesystem/00-core/preinstall ]; then
        chmod +x /linux-live/basesystem/00-core/preinstall
        /linux-live/basesystem/00-core/preinstall
    fi
    : 'if [ "$(ls -A /linux-live/basesystem/00-core/rootcopy-install)" != "" ]; then
        (cd /linux-live/basesystem/00-core/rootcopy-install && cp --parents -afr * /)
    fi'
    if [ -f /linux-live/basesystem/00-core/install ]; then
        chmod +x /linux-live/basesystem/00-core/install
        /linux-live/basesystem/00-core/install
    fi
    if [ -f /linux-live/basesystem/00-core/postinstall ]; then
        chmod +x /linux-live/basesystem/00-core/postinstall
        /linux-live/basesystem/00-core/postinstall
    fi

    chroot_cleanup
}

# =================================================================
#
#
# =================================================================
function build_dkms() {
    if [ $KERNEL_TYPE != "none" ]; then
        echo -e "${YELLOW}=====> building dkms packages for chroot system ...${ENDCOLOR}"

        local LOWER_DIR MODULE_UPPER_DIR MODULE_WORK_DIR MODULE_MERGED_DIR KERNEL BUILD_DKMS

        LOWER_DIR="$WORK_DIR/basesystem"
        MODULE_UPPER_DIR="$WORK_DIR/modules/01-dkms-upper"
        MODULE_WORK_DIR="$WORK_DIR/modules/01-dkms-work"
        MODULE_MERGED_DIR="$WORK_DIR/modules/01-dkms-merged"
        BUILD_DKMS="true"

        module_check_install_dir

        module_chroot_mount_fs

        # run install script
        if [ -f $SCRIPT_DIR/linux-live/basesystem/01-dkms/install ]; then
            cp $SCRIPT_DIR/linux-live/basesystem/01-dkms/install $MODULE_MERGED_DIR/install
            chmod +x $MODULE_MERGED_DIR/install
            if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
                chroot_run $MODULE_MERGED_DIR /install
            else
                chroot_run $MODULE_MERGED_DIR /install >>$OUTPUT 2>&1
            fi
        fi

        module_chroot_umount_fs

        module_check_mounted

        if [ -f $MODULE_UPPER_DIR/miniosbuild.conf ]; then
            read_config $MODULE_UPPER_DIR/miniosbuild.conf KERNEL

            if [ -L $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL/build ]; then
                rm -f $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL/build
            fi
            if [ -L $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL/source ]; then
                rm -f $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL/source
            fi
            set +e
            if [ -d $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL ]; then
                (cd $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL && cp --parents -afr * /$LOWER_DIR/usr/lib/modules/$KERNEL/)
            fi
            if [ -d $MODULE_UPPER_DIR/lib/modules/$KERNEL ]; then
                (cd $MODULE_UPPER_DIR/lib/modules/$KERNEL && cp --parents -afr * /$LOWER_DIR/lib/modules/$KERNEL/)
            fi
            set -e
        fi
    fi
}

# =================================================================
#
#
# =================================================================
function chroot_pkg_install() {
    current_process

    install_core_packages

    # remove unused
    apt-get autoremove -y >>$OUTPUT 2>&1

    # clean up apt cache
    apt-get clean -y >>$OUTPUT 2>&1
}

# =================================================================
# Unused for now. These steps are performed when running
# installation in linux-live/basesystem/00-core/install
# =================================================================
function chroot_configure() {
    current_process

    (cd /linux-live/basesystem/00-core/rootcopy-install && cp --parents -afr * /)

    # minios-install setup
    if [ ! -d /etc/$LIVEKITNAME ]; then
        mkdir -p /etc/$LIVEKITNAME
    fi

    if [ ! -d /etc/NetworkManager ]; then
        echo "Enable dhclient.service autostart." >>$OUTPUT 2>&1
        cat <<EOF >/usr/lib/systemd/system/dhclient.service
[Unit]
Description=DHCP Client
Documentation=man:dhclient(8)
Wants=network.target
After=network-pre.target systemd-sysctl.service systemd-modules-load.service
Before=network.target shutdown.target network-online.target
ConditionPathExists=!/run/initramfs/net.up.flag

[Service]
Type=forking
ExecStart=-/bin/sh -c 'udevadm settle && dhclient -nw'
PIDFile=/run/dhclient.pid

[Install]
WantedBy=multi-user.target
WantedBy=network-online.target
EOF
        systemctl enable dhclient >>$OUTPUT 2>&1
    elif [ -d /etc/NetworkManager ] && [[ $DISTRIBUTION = "bionic" || $DISTRIBUTION = "focal" || $DISTRIBUTION = "jammy" ]]; then
        if [ ! -d /etc/netplan/ ]; then
            mkdir -p /etc/netplan/
        fi
        cat <<EOF >/etc/netplan/01-netcfg.yaml
# This file describes the network interfaces available on your system
# For more information, see netplan(5).
# Set and change netplan renderer to NetworkManager GUI tool 
network:
  version: 2
  renderer: NetworkManager

EOF
        cat <<EOF >/etc/NetworkManager/NetworkManager.conf
[main]
rc-manager=resolvconf
plugins=ifupdown,keyfile
dns=dnsmasq
[ifupdown]
managed=false

EOF
    fi

    if [ -f /etc/systemd/system/multi-user.target.wants/grub-initrd-fallback.service ]; then
        echo "Disable grub-initrd-fallback.service autostart."
        systemctl disable grub-initrd-fallback.service
    fi

    if grep openssh-server $SCRIPT_DIR/basesystem/00-core/$PACKAGE_VARIANT.list >>$OUTPUT 2>&1; then
        echo "Enable ssh.service autostart." >>$OUTPUT 2>&1
        cat <<EOF >/usr/lib/systemd/system/ssh-keygen.service
[Unit]
Description=Generate sshd keys
Before=ssh.service

[Service]
Type=oneshot
ExecStart=/usr/bin/ssh-keygen -A
RemainAfterExit=true
StandardOutput=journal

[Install]
WantedBy=multi-user.target
EOF
        #if [ $CLOUD != "true" ]; then
        #    sed -i 's,#PermitRootLogin prohibit-password,PermitRootLogin yes,g' /etc/ssh/sshd_config
        #    sed -i 's,#PasswordAuthentication yes,PasswordAuthentication yes,g' /etc/ssh/sshd_config
        #fi
        systemctl enable ssh-keygen >>$OUTPUT 2>&1
        systemctl enable ssh >>$OUTPUT 2>&1
    fi

    if [ ! -f /usr/share/sudo ]; then
        cat <<EOF >/usr/share/sudo
#!/bin/bash
if [ "$#" -lt 1 ]; then
   echo "Usage: sudo [command] [arguments]"
   exit 1
fi

if [ "$UID" = 0 ]; then
   exec "$@"
fi

echo "Sudo is not installed. Run the command as root or install sudo."
EOF
    fi
}

# =================================================================
#
#
# =================================================================
function chroot_finish_up() {
    current_process

    # truncate machine id (why??)
    truncate -s 0 /etc/machine-id >>$OUTPUT 2>&1

    # remove diversion (why??)
    rm /sbin/initctl >>$OUTPUT 2>&1
    dpkg-divert --rename --remove /sbin/initctl >>$OUTPUT 2>&1

    # remove ssh config
    #rm -f /etc/ssh/ssh_host*

    # clean up useless stuff
    rm -rf /tmp/* ~/.bash_history >>$OUTPUT 2>&1
    rm -rf ~/.cache
    find /var/log/ -type f | xargs rm -f >>$OUTPUT 2>&1
    rm -f /etc/ssh/ssh_host*
    rm -f /var/backups/* >>$OUTPUT 2>&1
    rm -f /var/cache/ldconfig/* >>$OUTPUT 2>&1
    #rm -f /var/cache/debconf/* >>$OUTPUT 2>&1
    rm -f /var/cache/fontconfig/* >>$OUTPUT 2>&1
    rm -f /var/cache/apt/archives/*.deb >>$OUTPUT 2>&1
    rm -f /var/cache/apt/*.bin >>$OUTPUT 2>&1
    rm -f /var/cache/debconf/*-old >>$OUTPUT 2>&1
    rm -f /var/lib/apt/extended_states >>$OUTPUT 2>&1
    rm -f /var/lib/apt/lists/*Packages >>$OUTPUT 2>&1
    rm -f /var/lib/apt/lists/*Translation* >>$OUTPUT 2>&1
    rm -f /var/lib/apt/lists/*InRelease >>$OUTPUT 2>&1
    rm -f /var/lib/apt/lists/deb.* >>$OUTPUT 2>&1
    rm -f /var/lib/dpkg/*-old >>$OUTPUT 2>&1

}

# =================================================================
# =================================================================
# ======================= MODULE FUNCTIONS ========================
# =================================================================
# =================================================================

function module_add_unofficial_repository() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."
    if [ $DISTRIBUTION = "buster" ] || [ $DISTRIBUTION = "bullseye" ]; then
        if [ $USE_UNOFFICIAL_REPOSITORY = "true" ]; then
            if [ ! -d $MODULE_UPPER_DIR/etc/apt ]; then
                mkdir -p $MODULE_UPPER_DIR/etc/apt
            fi
            cat <<EOF >$MODULE_UPPER_DIR/etc/apt/sources.list
deb $UNOFFICIAL_REPOSITORY_ADDRESS $DISTRIBUTION main contrib non-free
EOF
        fi
    fi
}

function module_remove_unofficial_repository() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."
    if [ -f $MODULE_UPPER_DIR/etc/apt/sources.list ]; then
        rm $MODULE_UPPER_DIR/etc/apt/sources.list
    fi
}

# =================================================================
#
#
# =================================================================
function module_check_mounted() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."
    if grep -qs "$MODULE_MERGED_DIR" /proc/mounts || grep -qs "$MODULE_MERGED_DIR/dev" /proc/mounts || grep -qs "$MODULE_MERGED_DIR/run" /proc/mounts || grep -qs "$MODULE_MERGED_DIR/proc" /proc/mounts || grep -qs "$MODULE_MERGED_DIR/sys" /proc/mounts || grep -qs "$MODULE_MERGED_DIR/dev/pts" /proc/mounts || grep -qs "$MODULE_MERGED_DIR/tmp" /proc/mounts; then
        echo -e "${BOLD}${LIGHTYELLOW}Сhroot contains mounted filesystems.${ENDCOLOR}"
        if [ "$UNATTENDED" = "true" ]; then
            module_chroot_umount_fs
        else
            read -r -p "$(echo -e ""Do you want to ${GREEN}unmount them${ENDCOLOR}? [${BOLD}${GREEN}Y${ENDCOLOR}/n])" response
            response=${response,,}
            if [[ "$response" =~ ^(no|n)$ ]]; then
                exit 1
            else
                module_chroot_umount_fs
            fi
        fi
    fi
}

# =================================================================
#
#
# =================================================================
function module_check_install_dir() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."
    if [ "$UNATTENDED" = "true" ]; then
        #echo -e "${RED}!!!Unattended installation!!!${ENDCOLOR}"
        echo -e "The working directory is ${MAGENTA}$MODULE_UPPER_DIR${ENDCOLOR}."
        if [ "$(ls -A $MODULE_UPPER_DIR)" != "" ]; then
            module_cleanup
            module_check_mounted
        fi
    else
        if [ "$(ls -A $MODULE_UPPER_DIR)" != "" ]; then
            echo -e "${MAGENTA}$MODULE_UPPER_DIR${ENDCOLOR} is not empty."
            module_cleanup
            module_check_mounted
            echo -e "The working directory is ${MAGENTA}$MODULE_MERGED_DIR${ENDCOLOR}."
        else
            module_check_mounted
            echo -e "The working directory is ${MAGENTA}$MODULE_MERGED_DIR${ENDCOLOR}."
        fi
    fi
}

function filter_modules() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."
    : 'if [ $PACKAGE_VARIANT = "frugal" ] && ! { [[ $MODULE == *"minios"* ]] || [[ $MODULE == *"kernel"* ]] || [[ $MODULE == *"linux"* ]] || [[ $MODULE == *"firmware"* ]] || [[ $MODULE == *"xorg"* ]] || [[ $MODULE == *"gui-base"* ]] || [[ $MODULE == *"-desktop"* ]] || [[ $MODULE == *"-apps"* ]]; }; then
        FILTER_MODULES="true"
        FILTER_LEVEL="3"
        #if [ -f $SCRIPT_DIR/linux-live/container_buildconfig ]; then
        #    read_config $SCRIPT_DIR/linux-live/container_buildconfig FILTER_LEVEL
        #else
        #    read_config $SCRIPT_DIR/linux-live/buildconfig FILTER_LEVEL
        #fi
    elif [ $PACKAGE_VARIANT = "frugal" ] && ([[ $MODULE == *"minios"* ]] || [[ $MODULE == *"kernel"* ]] || [[ $MODULE == *"linux"* ]]); then
        FILTER_MODULES="true"
        FILTER_LEVEL="0"
    elif [ $PACKAGE_VARIANT = "frugal" ] && [[ $MODULE == *"firmware"* ]]; then
        FILTER_MODULES="true"
        FILTER_LEVEL="1"
    elif [ $PACKAGE_VARIANT = "frugal" ] && ([[ $MODULE == *"xorg"* ]] || [[ $MODULE == *"gui-base"* ]]); then
        FILTER_MODULES="true"
        FILTER_LEVEL="2"
    elif [ $PACKAGE_VARIANT = "frugal" ] && [[ $MODULE == *"-desktop"* ]]; then
        FILTER_MODULES="true"
        FILTER_LEVEL="3"
    elif [ $PACKAGE_VARIANT = "frugal" ] && [[ $MODULE == *"-apps"* ]]; then
        FILTER_MODULES="true"
        FILTER_LEVEL="4"
    elif ([[ $MODULE == *"kernel"* ]] || [[ $MODULE == *"linux"* ]] || [[ $MODULE == *"firmware"* ]] || [[ $MODULE == *"xorg"* ]] || [[ $MODULE == *"gui-base"* ]] || [[ $MODULE == *"-desktop"* ]] || [[ $MODULE == *"-apps"* ]]); then
        FILTER_MODULES="false"
    else
        if [ -f $SCRIPT_DIR/linux-live/container_buildconfig ]; then
            read_config $SCRIPT_DIR/linux-live/container_buildconfig FILTER_MODULES FILTER_LEVEL
        else
            read_config $SCRIPT_DIR/linux-live/buildconfig FILTER_MODULES FILTER_LEVEL
        fi
    fi'
    if [ $PACKAGE_VARIANT = "frugal" ] && ! [[ $MODULE =~ ^0[0-9]-* ]]; then
        FILTER_MODULES="true"
        FILTER_LEVEL="3"
    elif [ $PACKAGE_VARIANT = "frugal" ] && ([[ $MODULE == "00-"* ]] || [[ $MODULE == "01-"* ]]); then
        FILTER_MODULES="true"
        FILTER_LEVEL="0"
    elif [ $PACKAGE_VARIANT = "frugal" ] && [[ $MODULE == "02-"* ]]; then
        FILTER_MODULES="true"
        FILTER_LEVEL="1"
    elif [ $PACKAGE_VARIANT = "frugal" ] && [[ $MODULE == "03-"* ]]; then
        FILTER_MODULES="true"
        FILTER_LEVEL="2"
    elif [ $PACKAGE_VARIANT = "frugal" ] && [[ $MODULE == "04-"* ]]; then
        FILTER_MODULES="true"
        FILTER_LEVEL="3"
    elif [ $PACKAGE_VARIANT = "frugal" ] && [[ $MODULE == "05-"* ]]; then
        FILTER_MODULES="true"
        FILTER_LEVEL="4"
    elif [ $PACKAGE_VARIANT = "frugal" ] && [[ $MODULE == "06-"* ]]; then
        FILTER_MODULES="true"
        FILTER_LEVEL="5"
    elif [ $PACKAGE_VARIANT = "frugal" ] && [[ $MODULE == "07-"* ]]; then
        FILTER_MODULES="true"
        FILTER_LEVEL="6"
    elif [ $PACKAGE_VARIANT = "frugal" ] && [[ $MODULE == "08-"* ]]; then
        FILTER_MODULES="true"
        FILTER_LEVEL="7"
    elif [ $PACKAGE_VARIANT = "frugal" ] && [[ $MODULE == "09-"* ]]; then
        FILTER_MODULES="true"
        FILTER_LEVEL="8"
    #elif [[ $MODULE =~ ^0[0-9]-* ]]; then
    #    FILTER_MODULES="false"
    else
        if [ -f $SCRIPT_DIR/linux-live/container_buildconfig ]; then
            read_config $SCRIPT_DIR/linux-live/container_buildconfig FILTER_MODULES FILTER_LEVEL
        else
            read_config $SCRIPT_DIR/linux-live/buildconfig FILTER_MODULES FILTER_LEVEL
        fi
    fi
    echo -e "=====  ${YELLOW}MODULE=$MODULE${ENDCOLOR}"
    echo -e "=====  ${YELLOW}FILTER_MODULES=$FILTER_MODULES${ENDCOLOR}"
    echo -e "=====  ${YELLOW}FILTER_LEVEL=$FILTER_LEVEL${ENDCOLOR}"
    if [ $FILTER_MODULES = "true" ]; then
        MODULES_LIST=$(ls -1dr $1[0]* | egrep "0[0-$FILTER_LEVEL]" | tr '\n' ':')
    else
        MODULES_LIST=$(ls -1dr $1[0-9]* | tr '\n' ':')
    fi
}

# =================================================================
#
#
# =================================================================
function module_chroot_mount_fs() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."

    local MODULES BUNDLE FILTER

    module_check_mounted

    if [ $SCRIPT_DIR = "/usr/bin" ]; then
        mkdir -p $MODULES_DIR
        #mount -t tmpfs none $MODULES_DIR
    fi

    set +u

    if [ -z $BUILD_DKMS ] || [ $BUILD_DKMS != "true" ]; then
        if [ $UNION_BUILD_TYPE = "overlayfs" ]; then
            MODULES_LIST=""
            if [ $SCRIPT_DIR != "/usr/bin" ]; then
                MODULES=($WORK_DIR/image/$LIVEKITNAME/*.$BEXT)
                for ((i = ${#MODULES[@]} - 1; i >= 0; i--)); do
                    BUNDLE=$(basename ${MODULES[$i]} .$BEXT)
                    mkdir -p $MODULES_DIR/bundles/$BUNDLE
                    mount ${MODULES[$i]} $MODULES_DIR/bundles/$BUNDLE
                    #MODULES_LIST=$MODULES_LIST":""$MODULES_DIR/bundles/$BUNDLE"
                done
                #MODULES_LIST=${MODULES_LIST:1}
                set +e
                filter_modules $MODULES_DIR/bundles/
                #if [ $FILTER_MODULES = "true" ]; then
                #    MODULES_LIST=$(ls -1dr $MODULES_DIR/bundles/[0]* | egrep "0[0-$FILTER_LEVEL]" | tr '\n' ':')
                #else
                #    MODULES_LIST=$(ls -1dr $MODULES_DIR/bundles/[0-9]* | tr '\n' ':')
                #fi
                MODULES_LIST=${MODULES_LIST/%:/}
                set -e
            else
                MODULES=$BUNDLES/
                filter_modules $MODULES
                #if [ $FILTER_MODULES = "true" ]; then
                #    MODULES_LIST=$(ls -1dr $MODULES[0]* | egrep "0[0-$FILTER_LEVEL]" | tr '\n' ':')
                #else
                #    MODULES_LIST=$(ls -1dr $MODULES[0-9]* | tr '\n' ':')
                #fi
                MODULES_LIST=${MODULES_LIST/%:/}
                #echo $MODULES_LIST
            fi
            mkdir -p $MODULE_UPPER_DIR $MODULE_WORK_DIR $MODULE_MERGED_DIR
            mount -t overlay overlay -o lowerdir=$MODULES_LIST,upperdir=$MODULE_UPPER_DIR,workdir=$MODULE_WORK_DIR $MODULE_MERGED_DIR
        elif [ $UNION_BUILD_TYPE = "aufs" ]; then
            MODULES_LIST=""
            if [ $SCRIPT_DIR != "/usr/bin" ]; then
                MODULES=($WORK_DIR/image/$LIVEKITNAME/*.$BEXT)
                for ((i = ${#MODULES[@]} - 1; i >= 0; i--)); do
                    BUNDLE=$(basename ${MODULES[$i]} .$BEXT)
                    mkdir -p $MODULES_DIR/bundles/$BUNDLE
                    mount ${MODULES[$i]} $MODULES_DIR/bundles/$BUNDLE
                    MODULES_LIST=$MODULES_LIST":""$MODULES_DIR/bundles/$BUNDLE""=ro"
                done
                MODULES_LIST=${MODULES_LIST:1}
            else
                MODULES=$BUNDLES/
                filter_modules $MODULES
                #if [ $FILTER_MODULES = "true" ]; then
                #    MODULES_LIST=$(ls -1dr $MODULES[0-1]* | egrep "0[1-$FILTER_LEVEL]" | tr '\n' ':')
                #else
                #    MODULES_LIST=$(ls -1dr $MODULES[0-1]* | tr '\n' ':')
                #fi
                MODULES_LIST=${MODULES_LIST/%:/}
            fi
            mkdir -p $MODULE_UPPER_DIR $MODULE_WORK_DIR $MODULE_MERGED_DIR
            mount -t aufs -o br:$MODULE_UPPER_DIR=rw:$MODULES_LIST aufs $MODULE_MERGED_DIR
        fi
    else
        mkdir -p $MODULE_UPPER_DIR $MODULE_WORK_DIR $MODULE_MERGED_DIR
        if [ $UNION_BUILD_TYPE = "overlayfs" ]; then
            mount -t overlay overlay -o lowerdir=$LOWER_DIR,upperdir=$MODULE_UPPER_DIR,workdir=$MODULE_WORK_DIR $MODULE_MERGED_DIR
        elif [ $UNION_BUILD_TYPE = "aufs" ]; then
            mount -t aufs -o br:$MODULE_UPPER_DIR=rw:$LOWER_DIR aufs $MODULE_MERGED_DIR
        fi
    fi

    set -u

    if [ ! -d $MODULE_MERGED_DIR/dev ]; then
        mkdir -p $MODULE_MERGED_DIR/dev
    fi
    if [ ! -d $MODULE_MERGED_DIR/run ]; then
        mkdir -p $MODULE_MERGED_DIR/run
    fi
    if [ ! -d $MODULE_MERGED_DIR/proc ]; then
        mkdir -p $MODULE_MERGED_DIR/proc
    fi
    if [ ! -d $MODULE_MERGED_DIR/sys ]; then
        mkdir -p $MODULE_MERGED_DIR/sys
    fi
    if [ ! -d $MODULE_MERGED_DIR/tmp ]; then
        mkdir -p $MODULE_MERGED_DIR/tmp
    fi

    mount --bind /dev $MODULE_MERGED_DIR/dev

    if [ $SCRIPT_DIR = "/usr/bin" ]; then
        echo "nameserver 8.8.8.8" >$MODULE_MERGED_DIR/etc/resolv.conf
    else
        if [ -f /.dockerenv ] || [ "$container" = "podman" ] || [ $DISTRIBUTION_TYPE = "ubuntu" ]; then
            if [ -L $MODULE_MERGED_DIR/etc/resolv.conf ] || [ $DISTRIBUTION = "stretch" ] || [ $DISTRIBUTION_TYPE = "ubuntu" ]; then
                if [ -L $MODULE_MERGED_DIR/etc/resolv.conf ]; then
                    if [ $DISTRIBUTION_TYPE = "ubuntu" ]; then
                        rm $MODULE_MERGED_DIR/etc/resolv.conf
                    else
                        mv $MODULE_MERGED_DIR/etc/resolv.conf $MODULE_MERGED_DIR/etc/resolv.conf.bak
                    fi
                fi
                echo "nameserver 8.8.8.8" >>$MODULE_MERGED_DIR/etc/resolv.conf
            fi
            : 'if [ ! -d $MODULE_MERGED_DIR/run/resolvconf ]; then
            mkdir -p $MODULE_MERGED_DIR/run/resolvconf
            touch $MODULE_MERGED_DIR/run/resolvconf/resolv.conf
            mount --bind /etc/resolv.conf $MODULE_MERGED_DIR/run/resolvconf/resolv.conf
            fi'
        else
            mount --bind /run $MODULE_MERGED_DIR/run
        fi
    fi
    mount none -t proc $MODULE_MERGED_DIR/proc
    mount none -t sysfs $MODULE_MERGED_DIR/sys
    mount none -t devpts $MODULE_MERGED_DIR/dev/pts
    mount none -t tmpfs $MODULE_MERGED_DIR/tmp
}

# =================================================================
#
#
# =================================================================
function module_chroot_umount_fs() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."

    local MODULES BUNDLE

    set +e

    if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
        umount $MODULE_MERGED_DIR/proc
        umount $MODULE_MERGED_DIR/sys
        umount $MODULE_MERGED_DIR/dev/pts
        umount $MODULE_MERGED_DIR/tmp
        umount $MODULE_MERGED_DIR/dev
        if [ $SCRIPT_DIR = "/usr/bin" ]; then
            rm -f $MODULE_UPPER_DIR/etc/resolv.conf
            umount $MODULE_MERGED_DIR
            umount $MODULES_DIR/bundles/*
            umount $MODULES_DIR
        else
            if [ -f /.dockerenv ] || [ "$container" = "podman" ] || [ $DISTRIBUTION_TYPE = "ubuntu" ]; then
                if [[ -L $MODULE_MERGED_DIR/etc/resolv.conf.bak && ! -L $MODULE_MERGED_DIR/etc/resolv.conf ]] || [ $DISTRIBUTION = "stretch" ] || [ $DISTRIBUTION_TYPE = "ubuntu" ]; then
                    rm -f $MODULE_MERGED_DIR/etc/resolv.conf
                    if [ $DISTRIBUTION_TYPE = "ubuntu" ]; then
                        ln -s ../run/systemd/resolve/stub-resolv.conf $MODULE_MERGED_DIR/etc/resolv.conf
                    else
                        mv $MODULE_MERGED_DIR/etc/resolv.conf.bak $MODULE_MERGED_DIR/etc/resolv.conf
                    fi
                elif [ -L $MODULE_MERGED_DIR/etc/resolv.conf.bak ] && [ -L $MODULE_MERGED_DIR/etc/resolv.conf ]; then
                    rm -f $MODULE_MERGED_DIR/etc/resolv.conf.bak
                fi
                : 'umount $MODULE_MERGED_DIR/run/resolvconf/resolv.conf
                rm -f $MODULE_MERGED_DIR/run/resolvconf/resolv.conf
                rmdir $MODULE_MERGED_DIR/run/resolvconf'
            else
                umount $MODULE_MERGED_DIR/run
            fi

            umount $MODULE_MERGED_DIR

            if [ -f /.dockerenv ] || [ "$container" = "podman" ]; then
                rm -f $MODULE_UPPER_DIR/etc/resolv.conf
                rm -f $MODULE_UPPER_DIR/etc/resolv.conf.bak
            fi
        fi
    else
        umount $MODULE_MERGED_DIR/proc >>$OUTPUT 2>&1
        umount $MODULE_MERGED_DIR/sys >>$OUTPUT 2>&1
        umount $MODULE_MERGED_DIR/dev/pts >>$OUTPUT 2>&1
        umount $MODULE_MERGED_DIR/tmp >>$OUTPUT 2>&1
        umount $MODULE_MERGED_DIR/dev >>$OUTPUT 2>&1
        if [ $SCRIPT_DIR = "/usr/bin" ]; then
            rm -f $MODULE_UPPER_DIR/etc/resolv.conf >>$OUTPUT 2>&1

            umount $MODULE_MERGED_DIR >>$OUTPUT 2>&1

            umount $MODULES_DIR/bundles/* >>$OUTPUT 2>&1

            umount $MODULES_DIR >>$OUTPUT 2>&1
        else
            if [ -f /.dockerenv ] || [ "$container" = "podman" ]; then
                if [[ -e $MODULE_MERGED_DIR/etc/resolv.conf.bak && ! -L $MODULE_MERGED_DIR/etc/resolv.conf ]] || [ $DISTRIBUTION = "stretch" ]; then
                    rm -f $MODULE_UPPER_DIR/etc/resolv.conf
                    mv $MODULE_MERGED_DIR/etc/resolv.conf.bak $MODULE_MERGED_DIR/etc/resolv.conf
                elif [ -e $MODULE_MERGED_DIR/etc/resolv.conf.bak ] && [ -L $MODULE_MERGED_DIR/etc/resolv.conf ]; then
                    rm -f $MODULE_UPPER_DIR/etc/resolv.conf.bak
                fi
                : 'umount $MODULE_MERGED_DIR/run/resolvconf/resolv.conf >>$OUTPUT 2>&1
                rm -f $MODULE_UPPER_DIR/run/resolvconf/resolv.conf
                rmdir $MODULE_UPPER_DIR/run/resolvconf'
            else
                umount $MODULE_MERGED_DIR/run >>$OUTPUT 2>&1
            fi
            umount $MODULE_MERGED_DIR >>$OUTPUT 2>&1

            if [ -f /.dockerenv ] || [ "$container" = "podman" ]; then
                rm -f $MODULE_UPPER_DIR/etc/resolv.conf >>$OUTPUT 2>&1
                rm -f $MODULE_UPPER_DIR/etc/resolv.conf.bak >>$OUTPUT 2>&1
            fi
        fi
    fi

    set +u

    if [ -z $BUILD_DKMS ] || [ $BUILD_DKMS != "true" ]; then
        MODULES=($WORK_DIR/image/$LIVEKITNAME/*.$BEXT)
        for ((i = ${#MODULES[@]} - 1; i >= 0; i--)); do
            BUNDLE=$(basename ${MODULES[$i]} .$BEXT)
            umount $MODULES_DIR/bundles/$BUNDLE
        done
    fi

    set -eu

    module_check_mounted
}

# =================================================================
#
#
# =================================================================
function module_cleanup() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."
    if [ "$UNATTENDED" = "true" ]; then
        module_check_mounted
        rm -rf $MODULE_UPPER_DIR
        if [ -d "$MODULE_UPPER_DIR" ]; then
            module_cleanup
        fi
    else
        read -r -p "$(echo -e ""Do you want to ${BOLD}${RED}completely remove content${ENDCOLOR} of ${MAGENTA}$MODULE_UPPER_DIR${ENDCOLOR}? [y/${BOLD}${GREEN}N${ENDCOLOR}])" response
        response=${response,,}
        if [[ "$response" =~ ^(yes|y)$ ]]; then
            module_check_mounted
            rm -rf $MODULE_UPPER_DIR
            if [ -d "$MODULE_UPPER_DIR" ]; then
                module_cleanup
            fi
        else
            echo -e "${MAGENTA}$MODULE_UPPER_DIR${ENDCOLOR} should be empty to continue."
            exit 1
        fi
    fi
}

# =================================================================
#
#
# =================================================================
function module_chroot_finish_up() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."

    # truncate machine id (why??)
    chroot $MODULE_MERGED_DIR /bin/bash -x <<EOF
truncate -s 0 /etc/machine-id
EOF

    # remove diversion (why??)
    if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
        chroot $MODULE_MERGED_DIR /bin/bash -x <<EOF
    rm /sbin/initctl
    dpkg-divert --rename --remove /sbin/initctl
EOF
    else
        chroot $MODULE_MERGED_DIR /bin/bash -x <<EOF
    rm /sbin/initctl >>$OUTPUT 2>&1
    dpkg-divert --rename --remove /sbin/initctl >>$OUTPUT 2>&1
EOF
    fi

    if [ $SCRIPT_DIR = "/usr/bin" ]; then
        if [ -d $MODULE_UPPER_DIR/home/live ]; then
            chown 1000:1000 $MODULE_UPPER_DIR/home/live
            chown -R 1000:1000 $MODULE_UPPER_DIR/home/live
        fi
    fi
}

# =================================================================
#
#
# =================================================================
function module_chroot_cleanup() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."
    set +e
    # clean up useless stuff
    if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
        rm -rf $MODULE_UPPER_DIR/boot $MODULE_UPPER_DIR/dev $MODULE_UPPER_DIR/proc $MODULE_UPPER_DIR/sys $MODULE_UPPER_DIR/rmp $MODULE_UPPER_DIR/run
        rm -f $MODULE_UPPER_DIR/root/.bash_history
        rm -rf $MODULE_UPPER_DIR/.cache
        find $MODULE_UPPER_DIR/var/log/ -type f | xargs rm -f
        rm -f $MODULE_UPPER_DIR/etc/ssh/ssh_host*
        rm -f $MODULE_UPPER_DIR/var/backups/*
        rm -f $MODULE_UPPER_DIR/var/cache/ldconfig/*
        #rm -f $MODULE_UPPER_DIR/var/cache/debconf/*
        rm -f $MODULE_UPPER_DIR/var/cache/fontconfig/*
        rm -f $MODULE_UPPER_DIR/var/cache/apt/archives/*.deb
        rm -f $MODULE_UPPER_DIR/var/cache/apt/*.bin
        rm -f $MODULE_UPPER_DIR/var/cache/debconf/*-old
        rm -f $MODULE_UPPER_DIR/var/lib/apt/extended_states
        rm -f $MODULE_UPPER_DIR/var/lib/apt/lists/*Packages
        rm -f $MODULE_UPPER_DIR/var/lib/apt/lists/*Translation*
        rm -f $MODULE_UPPER_DIR/var/lib/apt/lists/*InRelease
        rm -f $MODULE_UPPER_DIR/var/lib/apt/lists/deb.*
        rm -f $MODULE_UPPER_DIR/var/lib/dpkg/*-old
        rm -f $MODULE_UPPER_DIR/preinstall
        rm -f $MODULE_UPPER_DIR/install
        rm -f $MODULE_UPPER_DIR/build
        rm -f $MODULE_UPPER_DIR/cleanup
        rm -f $MODULE_UPPER_DIR/$PACKAGE_VARIANT.list
        rm -f $MODULE_UPPER_DIR/package.list
        rm -f $MODULE_UPPER_DIR/postinstall
        rm -rf $MODULE_UPPER_DIR/rootcopy
        rm -f $MODULE_UPPER_DIR/etc/machine-id
        rm -rf $MODULE_UPPER_DIR/var/cache
        if [ $REMOVE_DPKG_DB = "true" ]; then
            rm -rf $MODULE_UPPER_DIR/var/lib/dpkg
        fi
        if [ $REMOVE_LARGE_ICONS = "true" ]; then
            if [ -d $MODULE_UPPER_DIR/usr/share/icons ]; then
                find $MODULE_UPPER_DIR/usr/share/icons/ -name 256x256 -o -name 512x512 -o -name 1024x1024 | xargs rm -rf
            fi
        fi
    else
        rm -rf $MODULE_UPPER_DIR/boot $MODULE_UPPER_DIR/dev $MODULE_UPPER_DIR/proc $MODULE_UPPER_DIR/sys $MODULE_UPPER_DIR/rmp $MODULE_UPPER_DIR/run
        rm -f $MODULE_UPPER_DIR/root/.bash_history >>$OUTPUT 2>&1
        rm -rf $MODULE_UPPER_DIR/.cache
        find $MODULE_UPPER_DIR/var/log/ -type f | xargs rm -f >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/etc/ssh/ssh_host*
        rm -f $MODULE_UPPER_DIR/var/backups/* >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/var/cache/ldconfig/* >>$OUTPUT 2>&1
        #rm -f $MODULE_UPPER_DIR/var/cache/debconf/* >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/var/cache/fontconfig/* >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/var/cache/apt/archives/*.deb >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/var/cache/apt/*.bin >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/var/cache/debconf/*-old >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/var/lib/apt/extended_states >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/var/lib/apt/lists/*Packages >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/var/lib/apt/lists/*Translation* >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/var/lib/apt/lists/*InRelease >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/var/lib/apt/lists/deb.* >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/var/lib/dpkg/*-old >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/preinstall >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/install >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/build >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/cleanup >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/$PACKAGE_VARIANT.list >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/package.list >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/postinstall >>$OUTPUT 2>&1
        rm -rf $MODULE_UPPER_DIR/rootcopy-install >>$OUTPUT 2>&1
        rm -f $MODULE_UPPER_DIR/etc/machine-id >>$OUTPUT 2>&1
        rm -rf $MODULE_UPPER_DIR/var/cache >>$OUTPUT 2>&1
        if [ $REMOVE_DPKG_DB = "true" ]; then
            rm -rf $MODULE_UPPER_DIR/var/lib/dpkg >>$OUTPUT 2>&1
        fi
        if [ $REMOVE_LARGE_ICONS = "true" ]; then
            find $MODULE_UPPER_DIR/usr/share/icons/ -name 256x256 -o -name 512x512 -o -name 1024x1024 | xargs rm -rf >>$OUTPUT 2>&1
        fi
        set -e
    fi
}

# =================================================================
#
#
# =================================================================
function module_build_cleanup() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."

    if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
        chroot_cleanup $MODULE_UPPER_DIR
    else
        chroot_cleanup $MODULE_UPPER_DIR >>$OUTPUT 2>&1
    fi
}

# =================================================================
#
#
# =================================================================
function get_kernel_version() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."
    if [ $DISTRIBUTION_ARCH = "amd64" ]; then
        KERNEL_ARCH="amd64"
    elif [ $DISTRIBUTION_ARCH = "i386-pae" ]; then
        KERNEL_ARCH="686-pae"
    elif [ $DISTRIBUTION_ARCH = "i386" ]; then
        KERNEL_ARCH="686"
    elif [ $DISTRIBUTION_ARCH = "arm64" ]; then
        KERNEL_ARCH="arm64"
    fi
    if [ $KERNEL_AUFS = "true" ] && ! { [ $DISTRIBUTION = "stretch" ] || [ $DISTRIBUTION = "buster" ] || ([ $DISTRIBUTION = "bullseye" ] && [ $KERNEL_BPO != "true" ]); }; then
        if [ $KERNEL_BPO = "true" ]; then
            KERNEL_RELEASE="5.18.16"
        else
            KERNEL_RELEASE="5.10.136"
        fi
        if [ $KERNEL_TYPE = "default" ]; then
            KERNEL="$KERNEL_RELEASE-$KERNEL_ARCH"
        else
            KERNEL="$KERNEL_RELEASE-$KERNEL_TYPE-$KERNEL_ARCH"
        fi
    elif [ $KERNEL_TYPE = "none" ]; then
        KERNEL=""
    elif [ -f /usr/bin/dpkg-query ] 2>/dev/null; then
        KERNEL=$(dpkg-query -W -f='${binary:Package}\n' linux-image-* 2>/dev/null | head -n 1 | sed 's/linux-image-//')
    else
        KERNEL=$(uname -r)
    fi
    if echo $KERNEL | grep -q 'pve'; then
        KERNEL=${KERNEL::-6}
    fi
}

# =================================================================
#
#
# =================================================================
function export_kernel() {
    if [[ $MODULE == *"kernel"* ]] || [[ $MODULE == *"linux"* ]]; then
        if [ $EXPORT_KERNEL = "true" ]; then
            echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOR} function is executing ..."
            kernel_variables
            if [ ! -d $KERNEL_DIR ]; then
                mkdir -p $KERNEL_DIR
            fi
            if [ -f $WORK_DIR/image/$LIVEKITNAME/$MODULE-$KERNEL_SUFFIX-$COMP_TYPE.$BEXT ]; then
                cp $WORK_DIR/image/$LIVEKITNAME/$MODULE-$KERNEL_SUFFIX-$COMP_TYPE.$BEXT $KERNEL_DIR
                if [ $NAMED_BOOT_FILES = "true" ]; then
                    cp $WORK_DIR/image/$LIVEKITNAME/boot/$VMLINUZNAME $KERNEL_DIR
                    cp $WORK_DIR/image/$LIVEKITNAME/boot/$INITRFSNAME $KERNEL_DIR
                else
                    cp $WORK_DIR/image/$LIVEKITNAME/boot/$VMLINUZNAME $KERNEL_DIR/vmlinuz-$KERNEL_SUFFIX
                    cp $WORK_DIR/image/$LIVEKITNAME/boot/$INITRFSNAME $KERNEL_DIR/initrfs-$KERNEL_SUFFIX-$INITRD_TYPE.img
                fi
                echo "Kernel files and initrd image have been exported to a folder $KERNEL_DIR"
            else
                echo "Kernel files could not be found."
            fi
        fi
        if [ $MOVE_KERNEL = "true" ]; then
            if [ ! -d $KERNEL_DIR ]; then
                mkdir -p $KERNEL_DIR
            fi
            if [ -f $WORK_DIR/image/$LIVEKITNAME/$MODULE-$KERNEL_SUFFIX-$COMP_TYPE.$BEXT ]; then
                mv $WORK_DIR/image/$LIVEKITNAME/$MODULE-$KERNEL_SUFFIX-$COMP_TYPE.$BEXT $KERNEL_DIR
                mv $WORK_DIR/image/$LIVEKITNAME/boot/$VMLINUZNAME $KERNEL_DIR
                mv $WORK_DIR/image/$LIVEKITNAME/boot/$INITRFSNAME $KERNEL_DIR
                echo "Kernel files and initrd image have been moved to a folder $KERNEL_DIR"
            else
                echo "Kernel files could not be found."
            fi
        fi
    fi
}

# =================================================================
#
#
# =================================================================
function kernel_variables() {
    : 'if [ $KERNEL_AUFS = "true" ]; then
        if [ $KERNEL_TYPE = "default" ] || [ $KERNEL_TYPE = "pve" ]; then
            KERNEL_SUFFIX="$KERNEL-$KERNEL_ARCH"
        else
            KERNEL_SUFFIX="$KERNEL-$KERNEL_TYPE-$KERNEL_ARCH"
        fi
    else'
    KERNEL_SUFFIX=$KERNEL
    #fi

    if [ $NAMED_BOOT_FILES = "true" ]; then
        VMLINUZNAME="vmlinuz-$KERNEL_SUFFIX"
        INITRFSNAME="initrfs-$KERNEL_SUFFIX.img"
    else
        VMLINUZNAME="vmlinuz"
        INITRFSNAME="initrfs.img"
    fi
}

# =================================================================
#
#
# =================================================================
function create_initrfs() {
    if [[ $MODULE == *"kernel"* ]] || [[ $MODULE == *"linux"* ]]; then
        if [ -f $MODULE_UPPER_DIR/miniosbuild.conf ]; then
            read_config $MODULE_UPPER_DIR/miniosbuild.conf KERNEL
        fi
        copy_build_scripts $MODULE_MERGED_DIR
        chmod +x $MODULE_MERGED_DIR/linux-live/initrfs
        chroot $MODULE_MERGED_DIR /linux-live/initrfs
        # copy boot files
        kernel_variables
        if [ ls $MODULE_MERGED_DIR/boot/vmlinuz-**-**-* ]; then
            cp $MODULE_MERGED_DIR/boot/vmlinuz-**-**-* $WORK_DIR/image/$LIVEKITNAME/boot/$VMLINUZNAME
        elif [ ls $MODULE_MERGED_DIR/boot/vmlinuz-**.**.* ]; then
            cp $MODULE_MERGED_DIR/boot/vmlinuz-**.**.* $WORK_DIR/image/$LIVEKITNAME/boot/$VMLINUZNAME
        else
            cp $MODULE_MERGED_DIR/boot/vmlinuz-* $WORK_DIR/image/$LIVEKITNAME/boot/$VMLINUZNAME
        fi
        cp $MODULE_MERGED_DIR/boot/initrfs.img $WORK_DIR/image/$LIVEKITNAME/boot/$INITRFSNAME
        sed -i "s,/boot/vmlinuz,/boot/$VMLINUZNAME,g;s,/boot/initrfs.img,/boot/$INITRFSNAME,g" $WORK_DIR/image/$LIVEKITNAME/boot/syslinux.cfg
        sed -i "s,/boot/vmlinuz,/boot/$VMLINUZNAME,g;s,/boot/initrfs.img,/boot/$INITRFSNAME,g" $WORK_DIR/image/$LIVEKITNAME/boot/grub/grub.cfg
        if [ -d $MODULE_MERGED_DIR/linux-live ]; then
            rm -rf $MODULE_MERGED_DIR/linux-live
        fi
    fi
}

# =================================================================
#
#
# =================================================================
function build_modules() {
    current_process
    if [ "${CMD[ii]}" != "build_dkms" ]; then

        local VMLINUZNAME INITRFSNAME KERNEL_SUFFIX PACKAGE VERSION BUNDLE

        if [ $CONTAINER_TYPE = "1" ]; then
            if [ ! -f /.minios-live ]; then
                setup_host
            fi
        fi

        if [ $SCRIPT_DIR = "/usr/bin" ]; then
            WORK_DIR=$CURRENT_DIR
            SOURCE_MODULES_DIR=$CURRENT_DIR/modules
            MODULES_DIR=/tmp/build

            if [ -d $SOURCE_MODULES_DIR ]; then
                cd $SOURCE_MODULES_DIR
            else
                help
            fi
        else
            SOURCE_MODULES_DIR=$SCRIPT_DIR/linux-live/modules/$DESKTOP_ENVIRONMENT
            MODULES_DIR=$WORK_DIR/modules

            cd $SOURCE_MODULES_DIR
        fi

        for MODULE in *; do
            if [ $SCRIPT_DIR != "/usr/bin" ] && (ls $WORK_DIR/image/$LIVEKITNAME/*.$BEXT | grep -q $MODULE 2>/dev/null); then
                echo -e "${RED}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!${ENDCOLOR}"
                echo -e "Please remove ${MAGENTA}$WORK_DIR/image/$LIVEKITNAME/$MODULE.$BEXT${ENDCOLOR} if you want to build ${MAGENTA}$MODULE${ENDCOLOR}."
                echo -e "${RED}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!${ENDCOLOR}"
            elif ([[ $MODULE == *"kernel"* ]] || [[ $MODULE == *"linux"* ]]) && [ $KERNEL_TYPE = "none" ]; then
                exit
            else
                MODULE_UPPER_DIR="$MODULES_DIR/$MODULE-upper"
                MODULE_WORK_DIR="$MODULES_DIR/$MODULE-work"
                MODULE_MERGED_DIR="$MODULES_DIR/$MODULE-merged"

                module_check_install_dir

                module_chroot_mount_fs

                module_add_unofficial_repository

                : 'if ([[ $MODULE == *"kernel"* ]] || [[ $MODULE == *"linux"* ]]) && ([ $KERNEL_AUFS = "true" ] && [ $KERNEL_TYPE != "default" ] && [ $KERNEL_BPO!= "true" ]) && ! { [ $DISTRIBUTION = "stretch" ] || [ $DISTRIBUTION = "buster" ]; }; then
                    #KERNEL=$(get_latest_release minios-linux/aufs-kernel)
                    kernel_variables
                    if [ $KERNEL_TYPE = "default" ]; then
                        if [ ! -f $SCRIPT_DIR/rootfs/linux-$KERNEL-$KERNEL_ARCH.tar.xz ]; then
                            wget -O $SCRIPT_DIR/rootfs/linux-$KERNEL-$KERNEL_ARCH.tar.xz https://github.com/minios-linux/aufs-kernel/releases/download/$KERNEL/linux-$KERNEL-$KERNEL_ARCH.tar.xz
                        fi
                        if [ ! -f $SCRIPT_DIR/rootfs/linux-$KERNEL-$KERNEL_ARCH.tar.xz ]; then
                            echo "$SCRIPT_DIR/rootfs/linux-$KERNEL-$KERNEL_ARCH.tar.xz does not exist. Installation cannot continue."
                            echo "Download the file https://github.com/minios-linux/aufs-kernel/releases/download/$KERNEL/linux-$KERNEL-$KERNEL_ARCH.tar.xz"
                            echo "and place it in the $SCRIPT_DIR/rootfs folder before running the installation."
                            exit 0
                        fi
                        tar -xf $SCRIPT_DIR/rootfs/linux-$KERNEL-$KERNEL_ARCH.tar.xz -C $MODULE_MERGED_DIR
                    else
                        if [ ! -f $SCRIPT_DIR/rootfs/linux-$KERNEL-$KERNEL_TYPE-$KERNEL_ARCH.tar.xz ]; then
                            wget -O $SCRIPT_DIR/rootfs/linux-$KERNEL-$KERNEL_TYPE-$KERNEL_ARCH.tar.xz https://github.com/minios-linux/aufs-kernel/releases/download/$KERNEL/linux-$KERNEL-$KERNEL_TYPE-$KERNEL_ARCH.tar.xz
                        fi
                        if [ ! -f $SCRIPT_DIR/rootfs/linux-$KERNEL-$KERNEL_TYPE-$KERNEL_ARCH.tar.xz ]; then
                            echo "$SCRIPT_DIR/rootfs/linux-$KERNEL-$KERNEL_TYPE-$KERNEL_ARCH.tar.xz does not exist. Installation cannot continue."
                            echo "Download the file https://github.com/minios-linux/aufs-kernel/releases/download/$KERNEL/linux-$KERNEL-$KERNEL_TYPE-$KERNEL_ARCH.tar.xz"
                            echo "and place it in the $SCRIPT_DIR/rootfs folder before running the installation."
                            exit 0
                        fi
                        tar -xf $SCRIPT_DIR/rootfs/linux-$KERNEL-$KERNEL_TYPE-$KERNEL_ARCH.tar.xz -C $MODULE_MERGED_DIR
                    fi
                    build_boot
                else'
                # run pre-install script
                if [ -f $SOURCE_MODULES_DIR/$MODULE/preinstall ]; then
                    if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
                        cp $SOURCE_MODULES_DIR/$MODULE/preinstall $MODULE_MERGED_DIR/preinstall
                        chmod +x $MODULE_MERGED_DIR/preinstall
                        chroot_run $MODULE_MERGED_DIR /preinstall
                    else
                        cp $SOURCE_MODULES_DIR/$MODULE/preinstall $MODULE_MERGED_DIR/preinstall
                        chmod +x $MODULE_MERGED_DIR/preinstall
                        chroot_run $MODULE_MERGED_DIR /preinstall >>$OUTPUT 2>&1
                    fi
                fi

                # copy files
                if [ ! -f $SOURCE_MODULES_DIR/$MODULE/build ]; then
                    if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
                        if [ "$(ls -A $SOURCE_MODULES_DIR/$MODULE/rootcopy-install)" != "" ]; then
                            (cd $SOURCE_MODULES_DIR/$MODULE/rootcopy-install && cp --parents -afr * $MODULE_MERGED_DIR/)
                        fi
                    else
                        if [ "$(ls -A $SOURCE_MODULES_DIR/$MODULE/rootcopy-install)" != "" ] >>$OUTPUT 2>&1; then
                            (cd $SOURCE_MODULES_DIR/$MODULE/rootcopy-install && cp --parents -afr * $MODULE_MERGED_DIR/)
                        fi
                    fi
                else
                    if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
                        if [ "$(ls -A $SOURCE_MODULES_DIR/$MODULE/rootcopy-install)" != "" ]; then
                            mkdir $MODULE_MERGED_DIR/rootcopy-install
                            (cd $SOURCE_MODULES_DIR/$MODULE/rootcopy-install && cp --parents -afr * $MODULE_MERGED_DIR/rootcopy-install/)
                        fi
                    else
                        if [ "$(ls -A $SOURCE_MODULES_DIR/$MODULE/rootcopy-install)" != "" ] >>$OUTPUT 2>&1; then
                            mkdir $MODULE_MERGED_DIR/rootcopy-install
                            (cd $SOURCE_MODULES_DIR/$MODULE/rootcopy-install && cp --parents -afr * $MODULE_MERGED_DIR/rootcopy-install/)
                        fi
                    fi
                fi

                # run install script
                if [ -f $SOURCE_MODULES_DIR/$MODULE/install ]; then
                    cp $SOURCE_MODULES_DIR/$MODULE/install $MODULE_MERGED_DIR/install
                    chmod +x $MODULE_MERGED_DIR/install
                    if [ -f $SOURCE_MODULES_DIR/$MODULE/cleanup ]; then
                        cp $SOURCE_MODULES_DIR/$MODULE/cleanup $MODULE_MERGED_DIR/cleanup
                    fi
                    if [ -f $SOURCE_MODULES_DIR/$MODULE/$PACKAGE_VARIANT.list ]; then
                        cp $SOURCE_MODULES_DIR/$MODULE/$PACKAGE_VARIANT.list $MODULE_MERGED_DIR/$PACKAGE_VARIANT.list
                    fi
                    if [ -f $SOURCE_MODULES_DIR/$MODULE/package.list ]; then
                        cp $SOURCE_MODULES_DIR/$MODULE/package.list $MODULE_MERGED_DIR/package.list
                    fi
                    if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
                        chroot_run $MODULE_MERGED_DIR /install
                    else
                        chroot_run $MODULE_MERGED_DIR /install >>$OUTPUT 2>&1
                    fi
                fi

                if [ -f $SOURCE_MODULES_DIR/$MODULE/build ]; then
                    module_chroot_umount_fs

                    module_build_cleanup

                    module_remove_unofficial_repository

                    # run external actions
                    if [ "$(ls -A $MODULE_UPPER_DIR)" != "" ]; then
                        mkdir -p $WORK_DIR/modules/tmp >>$OUTPUT 2>&1
                        mkmod_corefs $MODULE_UPPER_DIR
                        time mksquashfs $MODULE_UPPER_DIR $WORK_DIR/modules/tmp/$MODULE-stock.$BEXT -comp lz4 -b 1024K -always-use-fragments -noappend >>$OUTPUT 2>&1 || exit
                        mv $WORK_DIR/modules/tmp/$MODULE-stock.$BEXT $MODULE_UPPER_DIR/$MODULE-stock.$BEXT >>$OUTPUT 2>&1
                        cd $MODULE_UPPER_DIR >>$OUTPUT 2>&1
                        unsquashfs $MODULE-stock.$BEXT >>$OUTPUT 2>&1
                    else
                        echo -e "${MAGENTA}$MODULE_UPPER_DIR${ENDCOLOR} is empty. Nothing to do."
                    fi

                    #module_check_install_dir

                    module_chroot_mount_fs

                    module_add_unofficial_repository

                    # run build script
                    if [ -f $SOURCE_MODULES_DIR/$MODULE/build ]; then
                        cp $SOURCE_MODULES_DIR/$MODULE/build $MODULE_MERGED_DIR/build
                        chmod +x $MODULE_MERGED_DIR/build
                        if [ "$(ls -A $SOURCE_MODULES_DIR/$MODULE/patches)" != "" ] >>$OUTPUT 2>&1; then
                            mkdir $MODULE_MERGED_DIR/patches
                            (cd $SOURCE_MODULES_DIR/$MODULE/patches && cp --parents -afr * $MODULE_MERGED_DIR/patches/)
                        fi
                        if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
                            chroot_run $MODULE_MERGED_DIR /build
                        else
                            chroot_run $MODULE_MERGED_DIR /build >>$OUTPUT 2>&1
                        fi
                        build_boot
                    fi
                fi

                if [ -f $SOURCE_MODULES_DIR/$MODULE/is_dkms_build ]; then
                    read_config $MODULE_UPPER_DIR/miniosbuild.conf KERNEL
                    if [ -L $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL/build ]; then
                        rm -f $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL/build
                    fi
                    if [ -L $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL/source ]; then
                        rm -f $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL/source
                    fi
                    if [ -L $MODULE_UPPER_DIR/lib/modules/$KERNEL/build ]; then
                        rm -f $MODULE_UPPER_DIR/lib/modules/$KERNEL/build
                    fi
                    if [ -L $MODULE_UPPER_DIR/lib/modules/$KERNEL/source ]; then
                        rm -f $MODULE_UPPER_DIR/lib/modules/$KERNEL/source
                    fi
                    set +e
                    if [ -d $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL ]; then
                        if [ ! -d $MODULE_UPPER_DIR/squashfs-root/usr/lib/modules/$KERNEL ]; then
                            mkdir -p $MODULE_UPPER_DIR/squashfs-root/usr/lib/modules/$KERNEL
                        fi
                        (cd $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL && cp --parents -afr * $MODULE_UPPER_DIR/squashfs-root/usr/lib/modules/$KERNEL/)
                    fi
                    if [ -d $MODULE_UPPER_DIR/lib/modules/$KERNEL ]; then
                        if [ ! -d $MODULE_UPPER_DIR/squashfs-root/lib/modules/$KERNEL ]; then
                            mkdir -p $MODULE_UPPER_DIR/squashfs-root/lib/modules/$KERNEL
                        fi
                        (cd $MODULE_UPPER_DIR/lib/modules/$KERNEL && cp --parents -afr * $MODULE_UPPER_DIR/squashfs-root/lib/modules/$KERNEL/)
                    fi
                    set -e
                    if [ $MODULE = "01-kernel" ]; then
                        cd $MODULE_UPPER_DIR/squashfs-root
                        if ls initrd*; then
                            rm initrd*
                        fi
                        if ls vmlinuz*; then
                            rm vmlinuz*
                        fi
                        rm -Rf boot dev etc proc run sys tmp var/lib/apt
                    fi
                    if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
                        chroot_run $MODULE_MERGED_DIR time mksquashfs /squashfs-root /$MODULE.$BEXT -comp $COMP_TYPE -b 1024K -always-use-fragments -noappend
                    else
                        chroot_run $MODULE_MERGED_DIR time mksquashfs /squashfs-root /$MODULE.$BEXT -comp $COMP_TYPE -b 1024K -always-use-fragments -noappend >>$OUTPUT 2>&1
                    fi
                    rm -f $MODULE_UPPER_DIR/miniosbuild.conf
                fi

                # copy files
                if [[ $MODULE == *"$LIVEKITNAME"* ]]; then
                    cp $SCRIPT_DIR/linux-live/minioslib $MODULE_MERGED_DIR/usr/lib/minioslib
                    if [ ! -d $MODULE_MERGED_DIR/etc/minios ]; then
                        mkdir -p $MODULE_MERGED_DIR/etc/minios
                    fi
                    if [ -f $SCRIPT_DIR/linux-live/container_config ] && [ -f $SCRIPT_DIR/linux-live/container_buildconfig ]; then
                        cp $SCRIPT_DIR/linux-live/container_config $MODULE_MERGED_DIR/etc/minios/config
                        cp $SCRIPT_DIR/linux-live/container_buildconfig $MODULE_MERGED_DIR/etc/minios/buildconfig
                    else
                        cp $SCRIPT_DIR/linux-live/buildconfig $MODULE_MERGED_DIR/etc/minios/buildconfig
                        cp $SCRIPT_DIR/linux-live/config $MODULE_MERGED_DIR/etc/minios/config
                    fi
                    cp $SCRIPT_DIR/linux-live/kernelconfig $MODULE_MERGED_DIR/etc/minios/kernelconfig
                fi
                if [ ! -f $SOURCE_MODULES_DIR/$MODULE/build ]; then
                    if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
                        if [ "$(ls -A $SOURCE_MODULES_DIR/$MODULE/rootcopy-postinstall)" != "" ]; then
                            (cd $SOURCE_MODULES_DIR/$MODULE/rootcopy-postinstall && cp --parents -afr * $MODULE_MERGED_DIR/)
                        fi
                    else
                        if [ "$(ls -A $SOURCE_MODULES_DIR/$MODULE/rootcopy-postinstall)" != "" ] >>$OUTPUT 2>&1; then
                            (cd $SOURCE_MODULES_DIR/$MODULE/rootcopy-postinstall && cp --parents -afr * $MODULE_MERGED_DIR/)
                        fi
                    fi
                else
                    if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
                        if [ "$(ls -A $SOURCE_MODULES_DIR/$MODULE/rootcopy-postinstall)" != "" ]; then
                            mkdir $MODULE_MERGED_DIR/rootcopy-postinstall
                            (cd $SOURCE_MODULES_DIR/$MODULE/rootcopy-postinstall && cp --parents -afr * $MODULE_MERGED_DIR/rootcopy-postinstall/)
                        fi
                    else
                        if [ "$(ls -A $SOURCE_MODULES_DIR/$MODULE/rootcopy-postinstall)" != "" ] >>$OUTPUT 2>&1; then
                            mkdir $MODULE_MERGED_DIR/rootcopy-postinstall
                            (cd $SOURCE_MODULES_DIR/$MODULE/rootcopy-postinstall && cp --parents -afr * $MODULE_MERGED_DIR/rootcopy-postinstall/)
                        fi
                    fi
                fi

                # run post-install script
                if [ -f $SOURCE_MODULES_DIR/$MODULE/postinstall ]; then
                    cp $SOURCE_MODULES_DIR/$MODULE/postinstall $MODULE_MERGED_DIR/postinstall
                    chmod +x $MODULE_MERGED_DIR/postinstall
                    if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
                        chroot_run $MODULE_MERGED_DIR /postinstall
                    else
                        chroot_run $MODULE_MERGED_DIR /postinstall >>$OUTPUT 2>&1
                    fi
                fi

                if [ ! -f $SOURCE_MODULES_DIR/$MODULE/build ]; then
                    set +e
                    chroot_run $MODULE_MERGED_DIR uncompress_files /etc/alternatives
                    chroot_run $MODULE_MERGED_DIR uncompress_files /usr/share/man
                    chroot_run $MODULE_MERGED_DIR remove_broken_links /etc/alternatives
                    chroot_run $MODULE_MERGED_DIR remove_broken_links /usr/share/man
                    set -e
                fi

                if [ -f $MODULE_UPPER_DIR/.package ] && [ $PACKAGE_VARIANT = "frugal" ]; then
                    read_config $MODULE_UPPER_DIR/.package PACKAGE VERSION
                    MODULE_NUMBER=$(echo $MODULE | awk -F- '{ print $1 }')
                    MODULE_NAME="$MODULE_NUMBER-$PACKAGE-$VERSION"
                    rm $MODULE_UPPER_DIR/.package
                else
                    MODULE_NAME=$MODULE
                    if [ -f $MODULE_UPPER_DIR/.package ]; then
                        rm $MODULE_UPPER_DIR/.package
                    fi
                fi

                # run external actions
                if [ -f $SOURCE_MODULES_DIR/$MODULE/build ] && [ $SCRIPT_DIR != "/usr/bin" ]; then
                    if [[ $MODULE == *"kernel"* ]] || [[ $MODULE == *"linux"* ]]; then
                        cp $MODULE_UPPER_DIR/$MODULE.$BEXT $WORK_DIR/image/$LIVEKITNAME/$MODULE-$KERNEL_SUFFIX-$COMP_TYPE.$BEXT >>$OUTPUT 2>&1
                    else
                        cp $MODULE_UPPER_DIR/$MODULE.$BEXT $WORK_DIR/image/$LIVEKITNAME/$MODULE_NAME-$DISTRIBUTION_ARCH-$COMP_TYPE.$BEXT >>$OUTPUT 2>&1
                    fi
                elif [ -f $SOURCE_MODULES_DIR/$MODULE/build ] && [ $SCRIPT_DIR = "/usr/bin" ]; then
                    if [[ $MODULE == *"kernel"* ]] || [[ $MODULE == *"linux"* ]]; then
                        cp $MODULE_UPPER_DIR/$MODULE.$BEXT $CURRENT_DIR/$MODULE-$KERNEL_SUFFIX-$COMP_TYPE.$BEXT >>$OUTPUT 2>&1
                        chmod 666 $CURRENT_DIR/$MODULE-$KERNEL_SUFFIX-$COMP_TYPE.$BEXT
                    else
                        cp $MODULE_UPPER_DIR/$MODULE.$BEXT $CURRENT_DIR/$MODULE_NAME-$DISTRIBUTION_ARCH-$COMP_TYPE.$BEXT >>$OUTPUT 2>&1
                        chmod 666 $CURRENT_DIR/$MODULE_NAME-$DISTRIBUTION_ARCH-$COMP_TYPE.$BEXT
                    fi
                fi
                #fi

                module_chroot_finish_up

                module_chroot_umount_fs

                if [ ! -f $SOURCE_MODULES_DIR/$MODULE/build ]; then
                    module_build_cleanup
                fi

                module_chroot_cleanup

                module_remove_unofficial_repository

                mkmod_corefs $MODULE_UPPER_DIR

                if [ ! -f $SOURCE_MODULES_DIR/$MODULE/build ]; then #|| ( ([[ $MODULE == *"kernel"* ]] || [[ $MODULE == *"linux"* ]]) && ([ $KERNEL_AUFS = "true" ] && [ $KERNEL_BPO = "true" ])); then
                    if [ $SCRIPT_DIR = "/usr/bin" ]; then
                        if [ "$(ls -A $MODULE_UPPER_DIR)" != "" ]; then
                            if [[ $MODULE == *"kernel"* ]] || [[ $MODULE == *"linux"* ]]; then
                                if [ $COMP_TYPE = "zstd" ]; then
                                    time mksquashfs $COREFS $CURRENT_DIR/$MODULE-$KERNEL_SUFFIX-$COMP_TYPE.$BEXT -comp $COMP_TYPE -Xcompression-level 19 -b 1024K -always-use-fragments -noappend || exit
                                else
                                    time mksquashfs $COREFS $CURRENT_DIR/$MODULE-$KERNEL_SUFFIX-$COMP_TYPE.$BEXT -comp $COMP_TYPE -b 1024K -always-use-fragments -noappend || exit
                                fi
                                chmod 666 $CURRENT_DIR/$MODULE-$KERNEL_SUFFIX-$COMP_TYPE.$BEXT
                            else
                                if [ $COMP_TYPE = "zstd" ]; then
                                    time mksquashfs $COREFS $CURRENT_DIR/$MODULE_NAME-$DISTRIBUTION_ARCH-$COMP_TYPE.$BEXT -comp $COMP_TYPE -Xcompression-level 19 -b 1024K -always-use-fragments -noappend || exit
                                else
                                    time mksquashfs $COREFS $CURRENT_DIR/$MODULE_NAME-$DISTRIBUTION_ARCH-$COMP_TYPE.$BEXT -comp $COMP_TYPE -b 1024K -always-use-fragments -noappend || exit
                                fi
                                chmod 666 $CURRENT_DIR/$MODULE_NAME-$DISTRIBUTION_ARCH-$COMP_TYPE.$BEXT
                            fi
                        else
                            echo -e "${MAGENTA}$MODULE_UPPER_DIR${ENDCOLOR} ${RED}is empty${ENDCOLOR}. Nothing to do."
                        fi
                        module_chroot_umount_fs
                    else
                        if [ ! -f $WORK_DIR/image/$LIVEKITNAME/$MODULE-$COMP_TYPE.$BEXT ]; then
                            if [ "$(ls -A $MODULE_UPPER_DIR)" != "" ]; then
                                if [[ $MODULE == *"kernel"* ]] || [[ $MODULE == *"linux"* ]]; then
                                    if [ $COMP_TYPE = "zstd" ]; then
                                        time mksquashfs $COREFS $WORK_DIR/image/$LIVEKITNAME/$MODULE-$KERNEL_SUFFIX-$COMP_TYPE.$BEXT -comp $COMP_TYPE -Xcompression-level 19 -b 1024K -always-use-fragments -noappend || exit
                                    else
                                        time mksquashfs $COREFS $WORK_DIR/image/$LIVEKITNAME/$MODULE-$KERNEL_SUFFIX-$COMP_TYPE.$BEXT -comp $COMP_TYPE -b 1024K -always-use-fragments -noappend || exit
                                    fi
                                else
                                    if [ $COMP_TYPE = "zstd" ]; then
                                        time mksquashfs $COREFS $WORK_DIR/image/$LIVEKITNAME/$MODULE_NAME-$DISTRIBUTION_ARCH-$COMP_TYPE.$BEXT -comp $COMP_TYPE -Xcompression-level 19 -b 1024K -always-use-fragments -noappend || exit
                                    else
                                        time mksquashfs $COREFS $WORK_DIR/image/$LIVEKITNAME/$MODULE_NAME-$DISTRIBUTION_ARCH-$COMP_TYPE.$BEXT -comp $COMP_TYPE -b 1024K -always-use-fragments -noappend || exit
                                    fi
                                fi
                            else
                                echo -e "${MAGENTA}$MODULE_UPPER_DIR${ENDCOLOR} is empty. Nothing to do."
                            fi
                        else
                            echo -e "${RED}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!${ENDCOLOR}"
                            echo -e "Please remove ${MAGENTA}$WORK_DIR/image/$LIVEKITNAME/$MODULE.$BEXT${ENDCOLOR} if you want to build ${MAGENTA}$MODULE${ENDCOLOR}."
                            echo -e "${RED}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!${ENDCOLOR}"
                        fi
                    fi
                fi
            fi
            export_kernel
            PACKAGE=""
            VERSION=""
        done
    fi
}

# =================================================================
#
#
# =================================================================
function build_modules_live() {
    current_process
    if [ $CONTAINER_TYPE = "1" ]; then
        if [ ! -f /.minios-live ]; then
            setup_host
        fi
    fi

    MODULES_DIR=$WORK_DIR/modules

    cd $SOURCE_MODULES_DIR

    for MODULE in *; do
        if (ls $WORK_DIR/image/$LIVEKITNAME/*.$BEXT | grep -q $MODULE 2>/dev/null); then
            echo -e "${RED}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!${ENDCOLOR}"
            echo -e "Please remove ${MAGENTA}$WORK_DIR/image/$LIVEKITNAME/$MODULE.$BEXT${ENDCOLOR} if you want to build ${MAGENTA}$MODULE${ENDCOLOR}."
            echo -e "${RED}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!${ENDCOLOR}"
        else
            MODULE_UPPER_DIR="$MODULES_DIR/$MODULE-upper"
            MODULE_WORK_DIR="$MODULES_DIR/$MODULE-work"
            MODULE_MERGED_DIR="$MODULES_DIR/$MODULE-merged"
            mkmod_corefs $MODULE_UPPER_DIR
            if [ "$(ls -A $MODULE_UPPER_DIR)" != "" ]; then
                if [ $COMP_TYPE = "zstd" ]; then
                    time mksquashfs $COREFS $WORK_DIR/image/$LIVEKITNAME/$MODULE-$COMP_TYPE.$BEXT -comp $COMP_TYPE -Xcompression-level 19 -b 1024K -always-use-fragments -noappend || exit
                else
                    time mksquashfs $COREFS $WORK_DIR/image/$LIVEKITNAME/$MODULE-$COMP_TYPE.$BEXT -comp $COMP_TYPE -b 1024K -always-use-fragments -noappend || exit
                fi
            else
                echo -e "${MAGENTA}$MODULE_UPPER_DIR${ENDCOLOR} is empty. Nothing to do."
            fi
        fi
    done
}

function repack_module() {
    if [ $SCRIPT_DIR = "/usr/bin" ]; then
        cd $CURRENT_DIR
    fi
    OLD_MODULE=$MODULE
    MODULE=${MODULE%"-$OLD_COMP_TYPE.$BEXT"}
    if [ $COMP_TYPE = $OLD_COMP_TYPE ]; then
        echo "The module is already in the required compression format." && exit
    fi
    if [ $SCRIPT_DIR != "/usr/bin" ]; then
        unsquashfs $OLD_MODULE
        mkmod_corefs squashfs-root
        #mksquashfs squashfs-root $MODULE-$COMP_TYPE.$BEXT -comp $COMP_TYPE -b 1024K -always-use-fragments -noappend || exit
        if [ $COMP_TYPE = "zstd" ]; then
            time mksquashfs $COREFS $MODULE-$COMP_TYPE.$BEXT -comp $COMP_TYPE -Xcompression-level 19 -b 1024K -always-use-fragments -noappend || exit
        else
            time mksquashfs $COREFS $MODULE-$COMP_TYPE.$BEXT -comp $COMP_TYPE -b 1024K -always-use-fragments -noappend || exit
        fi

        rm -rf squashfs-root
        rm -f $OLD_MODULE
    else
        if (ls $CURRENT_DIR/*.$BEXT | grep -q $MODULE 2>/dev/null); then
            echo -e "${RED}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!${ENDCOLOR}"
            echo -e "Please remove $CURRENT_DIR/$MODULE-$COMP_TYPE.$BEXT${ENDCOLOR} if you want to build ${MAGENTA}$MODULE${ENDCOLOR}."
            echo -e "${RED}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!${ENDCOLOR}"
        else
            #mksquashfs $BUNDLES/$OLD_MODULE $CURRENT_DIR/$MODULE-$COMP_TYPE.$BEXT -comp $COMP_TYPE -b 1024K -always-use-fragments -noappend || exit
            if [ $COMP_TYPE = "zstd" ]; then
                time mksquashfs $BUNDLES/$OLD_MODULE $CURRENT_DIR/$MODULE-$COMP_TYPE.$BEXT -comp $COMP_TYPE -Xcompression-level 19 -b 1024K -always-use-fragments -noappend || exit
            else
                time mksquashfs $BUNDLES/$OLD_MODULE $CURRENT_DIR/$MODULE-$COMP_TYPE.$BEXT -comp $COMP_TYPE -b 1024K -always-use-fragments -noappend || exit
            fi
        fi
    fi
}

function repack_modules() {
    current_process

    if [ $SCRIPT_DIR != "/usr/bin" ]; then
        cd $WORK_DIR/image/$LIVEKITNAME/
        for MODULE in *; do
            if (ls ./*-xz.$BEXT 2>/dev/null | grep -q $MODULE >>/dev/null 2>&1); then
                OLD_COMP_TYPE="xz"
                repack_module
            elif (ls ./*-lz4.$BEXT 2>/dev/null | grep -q $MODULE >>/dev/null 2>&1); then
                OLD_COMP_TYPE="lz4"
                repack_module
            elif (ls ./*-zstd.$BEXT 2>/dev/null | grep -q $MODULE >>/dev/null 2>&1); then
                OLD_COMP_TYPE="zstd"
                repack_module
            elif (ls ./*-lzo.$BEXT 2>/dev/null | grep -q $MODULE >>/dev/null 2>&1); then
                OLD_COMP_TYPE="lzo"
                repack_module
            fi
        done
    else
        cd $BUNDLES/
        for MODULE in *; do
            if (ls $BUNDLES/*-xz.$BEXT | grep -q $MODULE >>/dev/null 2>&1); then
                OLD_COMP_TYPE="xz"
                repack_module
            elif (ls $BUNDLES/*-lz4.$BEXT | grep -q $MODULE >>/dev/null 2>&1); then
                OLD_COMP_TYPE="lz4"
                repack_module
            elif (ls $BUNDLES/*-zstd.$BEXT | grep -q $MODULE >>/dev/null 2>&1); then
                OLD_COMP_TYPE="zstd"
                repack_module
            elif (ls $BUNDLES/*-lzo.$BEXT | grep -q $MODULE >>/dev/null 2>&1); then
                OLD_COMP_TYPE="lzo"
                repack_module
            fi
        done
    fi
}

function download_sources() {
    current_process

    if [ ! -d /opt/minios-live ]; then
        apt-get update >>$OUTPUT 2>&1 &&
            apt-get install -y git >>$OUTPUT 2>&1
        mkdir -p /opt
        cd /opt
        git clone --depth=1 https://github.com/minios-linux/minios-live.git >>$OUTPUT 2>&1
        if [ -d /opt/minios-live/.git ]; then
            rm -rf /opt/minios-live/.git >>$OUTPUT 2>&1
        fi
        if [ -f /opt/minios-live/.gitignore ]; then
            rm -f /opt/minios-live/.gitignore >>$OUTPUT 2>&1
        fi
        # allow user to edit configs
        chmod 666 /opt/minios-live/linux-live/buildconfig
        chmod 666 /opt/minios-live/linux-live/config
        if id -nu 1000 >/dev/null && [ -d /home/$(id -nu 1000)/Desktop ]; then
            if [ ! -L /home/$(id -nu 1000)/Desktop/buildconfig ]; then
                ln -s /opt/minios-live/linux-live/buildconfig /home/$(id -nu 1000)/Desktop/buildconfig
            fi
            if [ ! -L /home/$(id -nu 1000)/Desktop/config ]; then
                ln -s /opt/minios-live/linux-live/config /home/$(id -nu 1000)/Desktop/config
            fi
        fi
        if [ $(stat -c %s /opt/minios-live/linux-live/minioslib) -ne $(stat -c %s /run/initramfs/lib/minioslib) ]; then
            cp /opt/minios-live/linux-live/minioslib /run/initramfs/lib/ >>$OUTPUT 2>&1
        fi
        /opt/minios-live/install
    fi
}

# =================================================================
# =================================================================
# ==================== BATCH BUILD FUNCTIONS ======================
# =================================================================
# =================================================================

function generate_config_files() {
    cp -f $SCRIPT_DIR/linux-live/buildconfig $SCRIPT_DIR/linux-live/container_buildconfig
    cp -f $SCRIPT_DIR/linux-live/config $SCRIPT_DIR/linux-live/container_config
    sed -i -e "/DISTRIBUTION_TYPE=/s/=.*/=\"$DISTRIBUTION_TYPE\"/" $SCRIPT_DIR/linux-live/container_buildconfig
    sed -i -e "/DISTRIBUTION=/s/=.*/=\"$DISTRIBUTION\"/" $SCRIPT_DIR/linux-live/container_buildconfig
    sed -i -e "/DISTRIBUTION_ARCH=/s/=.*/=\"$DISTRIBUTION_ARCH\"/" $SCRIPT_DIR/linux-live/container_buildconfig
    sed -i -e "/DESKTOP_ENVIRONMENT=/s/=.*/=\"$DESKTOP_ENVIRONMENT\"/" $SCRIPT_DIR/linux-live/container_buildconfig
    sed -i -e "/PACKAGE_VARIANT=/s/=.*/=\"$PACKAGE_VARIANT\"/" $SCRIPT_DIR/linux-live/container_buildconfig
    sed -i -e "/INITRD_TYPE=/s/=.*/=\"$INITRD_TYPE\"/" $SCRIPT_DIR/linux-live/container_buildconfig
    sed -i -e "/KERNEL_TYPE=/s/=.*/=\"$KERNEL_TYPE\"/" $SCRIPT_DIR/linux-live/container_buildconfig
    sed -i -e "/KERNEL_BPO=/s/=.*/=\"$KERNEL_BPO\"/" $SCRIPT_DIR/linux-live/container_buildconfig
    sed -i -e "/KERNEL_AUFS=/s/=.*/=\"$KERNEL_AUFS\"/" $SCRIPT_DIR/linux-live/container_buildconfig
    sed -i -e "/COMP_TYPE=/s/=.*/=\"$COMP_TYPE\"/" $SCRIPT_DIR/linux-live/container_buildconfig
    sed -i -e "/LOCALE=/s/=.*/=\"$LOCALE\"/" $SCRIPT_DIR/linux-live/container_buildconfig
    sed -i -e "/TIMEZONE=/s/=.*/=\"${TIMEZONE//\//\\/}\"/" $SCRIPT_DIR/linux-live/container_buildconfig
}

function container_run() {
    if [ ! "$($container_engine ps -q -f name=mlc-$DISTRIBUTION-$DESKTOP_ENVIRONMENT-$PACKAGE_VARIANT-$DISTRIBUTION_ARCH-$KERNEL_TYPE-$COMP_TYPE)" ]; then
        if [ "$($container_engine ps -aq -f status=exited -f name=mlc-$DISTRIBUTION-$DESKTOP_ENVIRONMENT-$PACKAGE_VARIANT-$DISTRIBUTION_ARCH-$KERNEL_TYPE-$COMP_TYPE)" ]; then
            # cleanup
            $container_engine rm -f $CONTAINER_NAME
        fi
        generate_config_files
        # run your container
        $container_engine run -d --log-driver=journald --name $CONTAINER_NAME --privileged -v /dev:/dev --device-cgroup-rule 'b 7:* rmw' -v /build:/build \
            -e DISTRIBUTION_TYPE="$DISTRIBUTION_TYPE" \
            -e DISTRIBUTION="$DISTRIBUTION" \
            -e DESKTOP_ENVIRONMENT="$DESKTOP_ENVIRONMENT" \
            -e PACKAGE_VARIANT="$PACKAGE_VARIANT" \
            -e DISTRIBUTION_ARCH="$DISTRIBUTION_ARCH" \
            -e COMP_TYPE="$COMP_TYPE" \
            -e LOCALE="$LOCALE" \
            -e TIMEZONE="$TIMEZONE" \
            -e USER_NAME="live" \
            -e USER_PASSWORD="evil" \
            -e ROOT_PASSWORD="toor" \
            -e DEFAULT_TARGET="graphical" \
            -e ENABLE_SERVICES="ssh" \
            -e DISABLE_SERVICES="" \
            -e SSH="true" \
            -e SSH_KEY="authorized_keys" \
            -e SCRIPTS="true" \
            -e CLOUD="false" \
            -e HIDE_CREDENTIALS="false" \
            -e DISTRIBUTION_VARIANT="minbase" \
            -e LOGPATH="/var/log" \
            -e OUTPUT="/dev/stdout" \
            -e BUILD_TEST_ISO="false" \
            -e CREATE_BACKUP="false" \
            -e DEV_SYSTEM="false" \
            -e DEBIAN_FRONTEND_TYPE="noninteractive" \
            -e APT_CMD="apt-get" \
            -e APT_OPTIONS="-y" \
            -e BOOT_TYPE="hybrid" \
            -e UNION_BUILD_TYPE="overlayfs" \
            -e SYSTEMNAME="MiniOS" \
            -e USE_BOOTSTRAP="true" \
            -e USE_ROOTFS="true" \
            -e REMOVE_OLD_ISO="true" \
            -e REMOVE_SOURCES="true" \
            -e SKIP_SETUP_HOST="true" \
            -e DOWNLOAD_SOURCES="false" \
            -e REMOVE_DPKG_DB="false" \
            -e REMOVE_LARGE_ICONS="true" \
            -e FILTER_MODULES="false" \
            -e FILTER_LEVEL="3" \
            -e INITRD_TYPE="$INITRD_TYPE" \
            -e KERNEL_TYPE="$KERNEL_TYPE" \
            -e KERNEL_BPO="$KERNEL_BPO" \
            -e KERNEL_AUFS="$KERNEL_AUFS" \
            -e KERNEL_NO_DKMS="$KERNEL_NO_DKMS" \
            -e NAMED_BOOT_FILES="false" \
            -e EXPORT_KERNEL="true" \
            -e MOVE_KERNEL="false" \
            -e USE_MX_REPO="false" \
            -e USE_ANTIX_REPO="false" \
            -e USE_UNOFFICIAL_REPOSITORY="false" \
            -e UNOFFICIAL_REPOSITORY_ADDRESS="http://10.3.0.3" \
            -e BUILD_FROM_SNAPSHOT="false" \
            -e SNAPSHOT_DATE="20220223T214737Z" \
            local/mlc /build/minios-live/install -
    fi
}

function live_run() {
    generate_config_files
    # run
    /usr/bin/env \
        DISTRIBUTION_TYPE="$DISTRIBUTION_TYPE" \
        DISTRIBUTION="$DISTRIBUTION" \
        DESKTOP_ENVIRONMENT="$DESKTOP_ENVIRONMENT" \
        PACKAGE_VARIANT="$PACKAGE_VARIANT" \
        DISTRIBUTION_ARCH="$DISTRIBUTION_ARCH" \
        COMP_TYPE="$COMP_TYPE" \
        LOCALE="$LOCALE" \
        TIMEZONE="$TIMEZONE" \
        USER_NAME="live" \
        USER_PASSWORD="evil" \
        ROOT_PASSWORD="toor" \
        DEFAULT_TARGET="graphical" \
        ENABLE_SERVICES="ssh" \
        DISABLE_SERVICES="" \
        SSH="true" \
        SSH_KEY="authorized_keys" \
        SCRIPTS="true" \
        CLOUD="false" \
        HIDE_CREDENTIALS="false" \
        DISTRIBUTION_VARIANT="minbase" \
        LOGPATH="/var/log" \
        OUTPUT="/dev/stdout" \
        BUILD_TEST_ISO="false" \
        CREATE_BACKUP="false" \
        DEV_SYSTEM="false" \
        DEBIAN_FRONTEND_TYPE="noninteractive" \
        APT_CMD="apt-get" \
        APT_OPTIONS="-y" \
        BOOT_TYPE="hybrid" \
        UNION_BUILD_TYPE="overlayfs" \
        SYSTEMNAME="MiniOS" \
        USE_BOOTSTRAP="true" \
        USE_ROOTFS="true" \
        REMOVE_OLD_ISO="true" \
        REMOVE_SOURCES="true" \
        SKIP_SETUP_HOST="true" \
        DOWNLOAD_SOURCES="false" \
        REMOVE_DPKG_DB="false" \
        REMOVE_LARGE_ICONS="true" \
        FILTER_MODULES="false" \
        FILTER_LEVEL="3" \
        INITRD_TYPE="$INITRD_TYPE" \
        KERNEL_TYPE="$KERNEL_TYPE" \
        KERNEL_BPO="$KERNEL_BPO" \
        KERNEL_AUFS="$KERNEL_AUFS" \
        KERNEL_NO_DKMS="$KERNEL_NO_DKMS" \
        NAMED_BOOT_FILES="false" \
        EXPORT_KERNEL="true" \
        MOVE_KERNEL="false" \
        USE_MX_REPO="false" \
        USE_ANTIX_REPO="false" \
        USE_UNOFFICIAL_REPOSITORY="false" \
        UNOFFICIAL_REPOSITORY_ADDRESS="http://10.3.0.3" \
        BUILD_FROM_SNAPSHOT="false" \
        SNAPSHOT_DATE="20220223T214737Z" \
        /build/minios-live/install -
}

function container_status_check() {
    RUN=$($container_engine inspect $CONTAINER_NAME --format='{{.State.Status}}')
}

function container_build_finish() {
    if [ -f $SCRIPT_DIR/linux-live/container_buildconfig ]; then
        rm -f $SCRIPT_DIR/linux-live/container_buildconfig
    fi
    if [ -f $SCRIPT_DIR/linux-live/container_config ]; then
        rm -f $SCRIPT_DIR/linux-live/container_config
    fi
    if [ ! -d $SCRIPT_DIR/logs ]; then
        mkdir -p $SCRIPT_DIR/logs
    fi
    $container_engine logs $CONTAINER_NAME >&$SCRIPT_DIR/logs/$CONTAINER_NAME.log
    START=$(docker inspect --format='{{.State.StartedAt}}' $CONTAINER_NAME)
    STOP=$(docker inspect --format='{{.State.FinishedAt}}' $CONTAINER_NAME)
    START_TIMESTAMP=$(date --date=$START +%s)
    STOP_TIMESTAMP=$(date --date=$STOP +%s)
    echo "Container runtime count: $CONTAINER_NAME $(($STOP_TIMESTAMP - $START_TIMESTAMP)) seconds"
    echo "Container runtime count: $CONTAINER_NAME $(($STOP_TIMESTAMP - $START_TIMESTAMP)) seconds" >>$SCRIPT_DIR/logs/$CONTAINER_NAME.log
    if [ "$($container_engine ps -aq -f status=exited -f name=$CONTAINER_NAME)" ]; then
        # cleanup
        $container_engine rm -f $CONTAINER_NAME
    fi
    if [ -d /build/minios-live/build/$DISTRIBUTION-$PACKAGE_VARIANT-$DISTRIBUTION_ARCH ]; then
        echo "/build/minios-live/build/$DISTRIBUTION-$PACKAGE_VARIANT-$DISTRIBUTION_ARCH exists"
    fi
}

function container_build_run() {
    local AUFS_SUFFIX BPO_SUFFIX
    DISTRIBUTION_TYPE="debian"
    DISTRIBUTION="$1"
    DESKTOP_ENVIRONMENT="$2"
    PACKAGE_VARIANT="$3"
    DISTRIBUTION_ARCH="$4"
    INITRD_TYPE="$5"
    KERNEL_TYPE="$6"
    KERNEL_BPO="$7"
    KERNEL_AUFS="$8"
    KERNEL_NO_DKMS="$9"
    COMP_TYPE="${10}"
    LOCALE="${11}"
    TIMEZONE="${12}"

    language_to_array

    if [ $1 = "trusty" ] || [ $1 = "xenial" ] || [ $1 = "bionic" ] || [ $1 = "focal" ] || [ $1 = "jammy" ]; then
        DISTRIBUTION_TYPE="ubuntu"
    fi

    if [ $KERNEL_BPO = "true" ]; then
        BPO_SUFFIX="-bpo"
    fi
    if [ $KERNEL_AUFS = "true" ]; then
        AUFS_SUFFIX="-aufs"
    fi

    CONTAINER_NAME="mlc-$DISTRIBUTION-$DESKTOP_ENVIRONMENT-$PACKAGE_VARIANT-$DISTRIBUTION_ARCH-$INITRD_TYPE-$KERNEL_TYPE$BPO_SUFFIX$AUFS_SUFFIX-${LANG[0]}-$COMP_TYPE"

    if [ ! "$($container_engine ps -q -f name=$CONTAINER_NAME)" ]; then
        if [ "$($container_engine ps -aq -f status=exited -f name=$CONTAINER_NAME)" ]; then
            # cleanup
            $container_engine rm -f $CONTAINER_NAME
        fi
        # run your container
        container_run
    fi

    container_status_check
    if [ "$RUN" = "running" ]; then
        echo "Container $CONTAINER_NAME has been started."
    fi

    while container_status_check; do
        if [ "$RUN" = "running" ]; then
            printf "."
            sleep 5
        else
            if [ "$($container_engine inspect $CONTAINER_NAME --format='{{.State.ExitCode}}')" != "0" ] 2>/dev/null; then
                printf "\nERROR: Container $CONTAINER_NAME stopped with error. Exit code $($container_engine inspect $CONTAINER_NAME --format='{{.State.ExitCode}}')\n"
                container_build_finish
            else
                printf "\nContainer $CONTAINER_NAME stopped, proceeding...\n"
                container_build_finish
            fi
            break
        fi
    done
}

function live_build_run() {
    DISTRIBUTION_TYPE="debian"
    DISTRIBUTION="$1"
    DESKTOP_ENVIRONMENT="$2"
    PACKAGE_VARIANT="$3"
    DISTRIBUTION_ARCH="$4"
    INITRD_TYPE="$5"
    KERNEL_TYPE="$6"
    KERNEL_BPO="$7"
    KERNEL_AUFS="$8"
    COMP_TYPE="$9"
    LOCALE="${10}"
    TIMEZONE="${11}"
    if [ $1 = "trusty" ] || [ $1 = "xenial" ] || [ $1 = "bionic" ] || [ $1 = "focal" ] || [ $1 = "jammy" ]; then
        DISTRIBUTION_TYPE="ubuntu"
    fi

    live_run
}
