#!/bin/bash

# Functions library :: for install scripts
# Author: crims0n. <http://minios.ru>
#

# =================================================================
# =================================================================
# ========================= VARIABLES =============================
# =================================================================
# =================================================================

function common_variables() {
	if [ $DISTRIBUTION_ARCH = "amd64" ]; then
		KERNEL_ARCH="amd64"
		#PACKAGE_VARIANT="standard"
	elif [ $DISTRIBUTION_ARCH = "i386" ]; then
		KERNEL_ARCH="686-pae"
		#PACKAGE_VARIANT="minimal"
	elif [ $DISTRIBUTION_ARCH = "arm64" ]; then
		KERNEL_ARCH="arm64"
	fi
}

# =================================================================
# =================================================================
# ===================== COMMON FUNCTIONS ==========================
# =================================================================
# =================================================================

function current_process() {
	echo -e "${LIGHTYELLOW}=====> running ${CYAN}${CMD[ii]}${ENDCOLOUR}${LIGHTYELLOW} ...${ENDCOLOUR}"
}

# =================================================================
# beautiful console
# красивая консоль
# =================================================================
function console_colours() {
	RED="\e[31m"
	GREEN="\e[32m"
	YELLOW="\e[33m"
	BLUE="\e[34m"
	MAGENTA="\e[35m"
	CYAN="\e[36m"
	LIGHTGRAY="\e[37m"
	DARKGRAY="\e[90m"
	LIGHTRED="\e[91m"
	LIGHTGREEN="\e[92m"
	LIGHTYELLOW="\e[93m"
	LIGHTBLUE="\e[94m"
	LIGHTMAGENTA="\e[95m"
	LIGHTCYAN="\e[96m"
	BOLD="\e[1m"
	DIM="\e[2m"
	UNDERLINED="\e[4m"
	BLINK="\e[5m"
	REVERSE="\e[7m"
	HIDDEN="\e[8m"
	ENDCOLOUR="\e[0m"
}

# =================================================================
# help functions
# функции помощи
# =================================================================
function help() {
	# if $1 is set, use $1 as headline message in help()
	if [ -f /etc/default/locale ]; then
		if grep -q 'LANG="ru_RU.UTF-8"' /etc/default/locale >>$OUTPUT; then
			if [ -z ${1+x} ]; then
				echo -e "${LIGHTYELLOW}Этот скрипт собирает модули для $SYSTEMNAME.${ENDCOLOUR}"
				echo -e
			else
				echo -e $1
				echo
			fi
			echo -e "Поддерживаемые команды : ${CYAN}${CMD[*]}${ENDCOLOUR}"
			echo -e
			echo -e "Синтаксис: ${MAGENTA}$0${ENDCOLOUR} [start_cmd] [-] [end_cmd]"
			if [ -L /usr/bin/$LIVEKITNAME-install ] && [ "$0" != "/usr/bin/$LIVEKITNAME-install" ]; then
				echo -e "\t${CYAN}$LIVEKITNAME-install${ENDCOLOUR} [start_cmd] [-] [end_cmd]"
			fi
			echo -e "\tзапуск от start_cmd до end_cmd"
			echo -e "\tесли start_cmd опущен, выполняются все команды, начиная с первой"
			echo -e "\tесли end_cmd опущен, выполняются все команды до последней"
			echo -e "\tвведите одну команду, чтобы запустить определенную команду"
			echo -e "\tвведите '-' как единственный аргумент для запуска всех команд"
			echo -e "\t"
			echo -e "\tСкрипты установки должны находиться в папке с именем будущего модуля."
			echo -e "\tНапример, чтобы собрать модуль с именем 06-vscode, скрипты сборки"
			echo -e "\tдолжны находиться по следующему пути: ${LIGHTYELLOW}$CURRENT_DIR/modules/06-vscode${ENDCOLOUR}"
			echo -e "\tПримеры:"
			echo -e "\t${LIGHTYELLOW}$0 build_modules${ENDCOLOUR} сборка модулей"
			echo -e "\t${LIGHTYELLOW}$0 repack_system${ENDCOLOUR} перепаковка системы с типом сжатия, указанным"
			echo -e "\tв /etc/$LIVEKITNAME/config в переменной COMP_TYPE"
			echo -e "\t${LIGHTYELLOW}$0 -${ENDCOLOUR} эта команда запустит обе функции поочерёдно"
			exit 0
		else
			if [ -z ${1+x} ]; then
				echo -e "${LIGHTYELLOW}This script builds modules for $SYSTEMNAME.${ENDCOLOUR}"
				echo -e
			else
				echo -e $1
				echo
			fi
			echo -e "Supported commands : ${CYAN}${CMD[*]}${ENDCOLOUR}"
			echo -e
			echo -e "Syntax: ${MAGENTA}$0${ENDCOLOUR} [start_cmd] [-] [end_cmd]"
			if [ -L /usr/bin/$LIVEKITNAME-install ] && [ "$0" != "/usr/bin/$LIVEKITNAME-install" ]; then
				echo -e "\t${CYAN}$LIVEKITNAME-install${ENDCOLOUR} [start_cmd] [-] [end_cmd]"
			fi
			echo -e "\trun from start_cmd to end_cmd"
			echo -e "\tif start_cmd is omitted, start from first command"
			echo -e "\tif end_cmd is omitted, end with last command"
			echo -e "\tenter single cmd to run the specific command"
			echo -e "\tenter '-' as only argument to run all commands"
			echo -e "\t"
			echo -e "\tThe installation scripts must be in the folder with the"
			echo -e "\tname of the future module. For example, to build a module"
			echo -e "\tnamed 06-vscode, build scripts should be in the following"
			echo -e "\tpath: ${LIGHTYELLOW}$CURRENT_DIR/modules/06-vscode${ENDCOLOUR}"
			echo -e "\tExamples:"
			echo -e "\t${LIGHTYELLOW}$0 build_modules ${ENDCOLOUR} build modules"
			echo -e "\t${LIGHTYELLOW}$0 repack_system ${ENDCOLOUR} repack the system with the"
			echo -e "\tcompression type specified by /etc/$LIVEKITNAME/config in COMP_TYPE variable"
			echo -e "\t${LIGHTYELLOW}$0 - ${ENDCOLOUR} this command will run both functions alternately"
			exit 0
		fi
	fi
}

# =================================================================
# parsing input commands
# разбор входных команд
# =================================================================
function find_index() {
	local ret
	local i
	for ((i = 0; i < ${#CMD[*]}; i++)); do
		if [ "${CMD[i]}" == "$1" ]; then
			index=$i
			return
		fi
	done
	help "Command not found : $1"
}

# =================================================================
# creating a symbolic link to the executable file for using
# autocompletion on the command line
# создание символической ссылки на исполняемый файл для
# использования автодополнения в командной строке
# =================================================================
function create_livekitname_install_symlink() {
	if [ -L /usr/bin/$LIVEKITNAME-install ]; then
		if [ "$(readlink /usr/bin/$LIVEKITNAME-install)" != "$SCRIPT_DIR/install" ]; then
			rm -f /usr/bin/$LIVEKITNAME-install
			ln -s $SCRIPT_DIR/install /usr/bin/$LIVEKITNAME-install
			if grep 'LANG="ru_RU.UTF-8"' /etc/default/locale >>$OUTPUT; then
				echo -e "Символическая ссылка ${MAGENTA}/usr/bin/$LIVEKITNAME-install${ENDCOLOUR} была обновлена."
				echo -e "Теперь она указывает на ${MAGENTA}$SCRIPT_DIR/install${ENDCOLOUR}."
			else
				echo -e "The ${MAGENTA}/usr/bin/$LIVEKITNAME-install${ENDCOLOUR} symbolic link has been updated."
				echo -e "It now points to ${MAGENTA}$SCRIPT_DIR/install${ENDCOLOUR}."
			fi
		fi
		if [ "$0" != "/usr/bin/$LIVEKITNAME-install" ]; then
			if grep 'LANG="ru_RU.UTF-8"' /etc/default/locale >>$OUTPUT; then
				echo -e "Вы можете использовать команду ${CYAN}$LIVEKITNAME-install${ENDCOLOUR} для запуска этой программы."
			else
				echo -e "You can use the ${CYAN}$LIVEKITNAME-install${ENDCOLOUR} command to run this program."
			fi
		fi
	else
		ln -s $SCRIPT_DIR/install /usr/bin/$LIVEKITNAME-install
		if grep 'LANG="ru_RU.UTF-8"' /etc/default/locale >>$OUTPUT; then
			echo -e "Символическая ссылка ${MAGENTA}/usr/bin/$LIVEKITNAME-install${ENDCOLOUR} была добавлена"
			echo -e "для ${MAGENTA}$SCRIPT_DIR/install${ENDCOLOUR}."

		else
			echo -e "The ${MAGENTA}/usr/bin/$LIVEKITNAME-install${ENDCOLOUR} symbolic link has been added"
			echo -e "for ${MAGENTA}$SCRIPT_DIR/install${ENDCOLOUR}."
		fi
	fi
}

# =================================================================
# creating autocompletion on the command line
# создание автодополнения в командной строке
# =================================================================
function create_completion() {
	if [ -d /etc/bash_completion.d ]; then
		if [ ! -f /etc/bash_completion.d/$LIVEKITNAME-install ] || ! grep "${CMD[*]}" /etc/bash_completion.d/$LIVEKITNAME-install >>$OUTPUT; then
			cat <<EOF >/etc/bash_completion.d/$LIVEKITNAME-install
#/usr/bin/env bash
complete -W "${CMD[*]}" $LIVEKITNAME-install
EOF
		fi
		if [ "$0" != "/usr/bin/$LIVEKITNAME-install" ]; then
			if grep 'LANG="ru_RU.UTF-8"' /etc/default/locale >>$OUTPUT; then
				echo -e "Дополнение команд работает только при использовании команды ${CYAN}$LIVEKITNAME-install${ENDCOLOUR}."
				echo -e
			else
				echo -e "Command completion only works when using the ${CYAN}$LIVEKITNAME-install${ENDCOLOUR} command."
				echo -e
			fi
		fi
	fi
}

# =================================================================
# only allow 'root' to run the script
# разрешаем запуск скрипта только пользователю 'root'
# =================================================================

function allow_root_only() {
	if [ $(id -u) -ne 0 ]; then
		echo -e "${BOLD}${RED}This script should be run as 'root'!${ENDCOLOUR}"
		exit 1
	fi

	export HOME=/root
	export LC_ALL=C
}

# =================================================================
# check that we are inside chroot
# проверяем, что мы внутри chroot
# =================================================================

function check_is_in_chroot() {
	if [ $(stat -c %i /)="2" ]; then
		echo -e "${BOLD}${RED}This script should be run inside chroot only!${ENDCOLOUR}"
		exit 1
	fi
}

# Unzip gzipped files (man pages), so LZMA can compress 2times better.
# First we fix symlinks, then uncompress files
# $1 = search directory
uncompress_files() {
	local LINK LINE

	find "$1" -type l -name "*.gz" | while read LINE; do
		LINK="$(readlink "$LINE" | sed -r 's/.gz$//')"
		FILE="$(echo "$LINE" | sed -r 's/.gz$//')"
		ln -sfn "$LINK" "$FILE"
		rm -f "$LINE"
	done
	find "$1" -type f -name "*.gz" | xargs -r gunzip
}

# remove broken links
# $1 = search directory
remove_broken_links() {
	find "$1" -type l -exec test ! -e {} \; -print | xargs rm -vf
}

function add_chroot_configuration_files() {
	set +u
	cat <<EOF >$1/$LIVEKITNAME.conf
OUTPUT=$OUTPUT
LOGPATH=$LOGPATH
BUILD_TEST_ISO=$BUILD_TEST_ISO
CREATE_BACKUP=$CREATE_BACKUP
DEBIAN_FRONTEND_TYPE=$DEBIAN_FRONTEND_TYPE
APT_CMD=$APT_CMD
APT_OPTIONS=$APT_OPTIONS
LIVE_TYPE=$LIVE_TYPE
DISTRIBUTION=$DISTRIBUTION
DISTRIBUTION_TYPE=$DISTRIBUTION_TYPE
PACKAGE_VARIANT=$PACKAGE_VARIANT
COMP_TYPE=$COMP_TYPE
KERNEL_ARCH=$KERNEL_ARCH
LIVEKITNAME=$LIVEKITNAME
SYSTEMNAME=$SYSTEMNAME
DISTRIBUTION_ARCH=$DISTRIBUTION_ARCH
EOF

	cat <<'EOF' >$1/functions
#!/bin/bash

# =================================================================
# beautiful console
# красивая консоль
# =================================================================
function console_colours() {
    RED="\e[31m"
    GREEN="\e[32m"
    YELLOW="\e[33m"
    BLUE="\e[34m"
    MAGENTA="\e[35m"
    CYAN="\e[36m"
    LIGHTGRAY="\e[37m"
    DARKGRAY="\e[90m"
    LIGHTRED="\e[91m"
    LIGHTGREEN="\e[92m"
    LIGHTYELLOW="\e[93m"
    LIGHTBLUE="\e[94m"
    LIGHTMAGENTA="\e[95m"
    LIGHTCYAN="\e[96m"
    BOLD="\e[1m"
    DIM="\e[2m"
    UNDERLINED="\e[4m"
    BLINK="\e[5m"
    REVERSE="\e[7m"
    HIDDEN="\e[8m"
    ENDCOLOUR="\e[0m"
}

# =================================================================
# reading configuration file
# чтение конфигурационного файла
# =================================================================

function read_config() { # read_config file.cfg var_name1 var_name2
    # ref: https://stackoverflow.com/a/20815951

    shopt -s extglob # needed the "one of these"-match below
    local configfile="${1?No configuration file given}"
    local keylist="${@:2}" # positional parameters 2 and following

    if [[ ! -f "$configfile" ]]; then
        echo >&2 "\"$configfile\" is not a file!"
        exit 1
    fi
    if [[ ! -r "$configfile" ]]; then
        echo >&2 "\"$configfile\" is not readable!"
        exit 1
    fi

    keylist="${keylist// /|}" # this will generate a regex 'one of these'

    # lhs : "left hand side" : Everything left of the '='
    # rhs : "right hand side": Everything right of the '='
    #
    # "lhs" will hold the name of the key you want to read.
    # The value of "rhs" will be assigned to that key.
    while IFS='= ' read -r lhs rhs; do
        # IF lhs in keylist
        # AND rhs not empty
        if [[ "$lhs" =~ ^($keylist)$ ]] && [[ -n $rhs ]]; then
            rhs="${rhs%\"*}"   # Del opening string quotes
            rhs="${rhs#\"*}"   # Del closing string quotes
            rhs="${rhs%\'*}"   # Del opening string quotes
            rhs="${rhs#\'*}"   # Del closing string quotes
            eval $lhs=\"$rhs\" # The magic happens here
        fi
        # tr used as a safeguard against dos line endings
    done <<<$(tr -d '\r' <$configfile)

    shopt -u extglob # Switching it back off after use
}

# Unzip gzipped files (man pages), so LZMA can compress 2times better.
# First we fix symlinks, then uncompress files
# $1 = search directory
uncompress_files() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."
    local LINK LINE

    find "$1" -type l -name "*.gz" | while read LINE; do
        LINK="$(readlink "$LINE" | sed -r 's/.gz$//')"
        FILE="$(echo "$LINE" | sed -r 's/.gz$//')"
        ln -sfn "$LINK" "$FILE"
        rm -f "$LINE"
    done
    find "$1" -type f -name "*.gz" | xargs -r gunzip
}

# remove broken links
# $1 = search directory
remove_broken_links() {
    echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."
    find "$1" -type l -exec test ! -e {} \; -print | xargs rm -vf
}
EOF
	set -u
}

function remove_chroot_configuration_files() {
	rm -f $1/$LIVEKITNAME.conf
	rm -f $1/functions
}

function chroot_run() {
	echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."
	add_chroot_configuration_files $1
	chroot $1 /bin/bash <<EOF
. /functions
read_config /$LIVEKITNAME.conf OUTPUT LOGPATH BUILD_TEST_ISO CREATE_BACKUP DEBIAN_FRONTEND_TYPE APT_CMD APT_OPTIONS LIVE_TYPE DISTRIBUTION DISTRIBUTION_TYPE PACKAGE_VARIANT COMP_TYPE KERNEL_ARCH LIVEKITNAME SYSTEMNAME DISTRIBUTION_ARCH
export OUTPUT LOGPATH BUILD_TEST_ISO CREATE_BACKUP DEBIAN_FRONTEND_TYPE APT_CMD APT_OPTIONS LIVE_TYPE DISTRIBUTION DISTRIBUTION_TYPE PACKAGE_VARIANT COMP_TYPE KERNEL_ARCH LIVEKITNAME SYSTEMNAME DISTRIBUTION_ARCH
${@:2}
EOF
	remove_chroot_configuration_files $1
}

# =================================================================
# =================================================================
# ======================= MODULES FUNCTIONS =======================
# =================================================================
# =================================================================

# =================================================================
#
#
# =================================================================
function module_check_mounted() {
	echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."
	if grep -qs "$MODULE_MERGED_DIR" /proc/mounts || grep -qs "$MODULE_MERGED_DIR/dev" /proc/mounts || grep -qs "$MODULE_MERGED_DIR/run" /proc/mounts || grep -qs "$MODULE_MERGED_DIR/proc" /proc/mounts || grep -qs "$MODULE_MERGED_DIR/sys" /proc/mounts || grep -qs "$MODULE_MERGED_DIR/dev/pts" /proc/mounts || grep -qs "$MODULE_MERGED_DIR/tmp" /proc/mounts; then
		echo -e "${BOLD}${LIGHTYELLOW}Chroot contains mounted filesystems.${ENDCOLOUR}"
		if [ "$UNATTENDED" = "1" ]; then
			module_chroot_umount_fs
		else
			read -r -p "$(echo -e ""Do you want to ${GREEN}unmount them${ENDCOLOUR}? [${BOLD}${GREEN}Y${ENDCOLOUR}/n])" response
			response=${response,,}
			if [[ "$response" =~ ^(no|n)$ ]]; then
				exit 1
			else
				module_chroot_umount_fs
			fi
		fi
	fi
}

# =================================================================
#
#
# =================================================================
function module_check_build_dir() {
	echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."
	if [ "$UNATTENDED" = "1" ]; then
		#echo -e "${RED}!!!Unattended installation!!!${ENDCOLOUR}"
		echo -e "The working directory is ${MAGENTA}$MODULE_UPPER_DIR${ENDCOLOUR}."
		if [ "$(ls -A $MODULE_UPPER_DIR)" != "" ]; then
			module_cleanup
			module_check_mounted
		fi
	else
		# ▼ должно быть только перенаправление ошибки!
		if [ "$(ls -A $MODULE_UPPER_DIR)" != "" ]; then
			echo -e "${MAGENTA}$MODULE_UPPER_DIR${ENDCOLOUR} is not empty."
			module_cleanup
			module_check_mounted
			echo -e "The working directory is ${MAGENTA}$MODULE_MERGED_DIR${ENDCOLOUR}."
		else
			module_check_mounted
			echo -e "The working directory is ${MAGENTA}$MODULE_MERGED_DIR${ENDCOLOUR}."
		fi
	fi
}

# =================================================================
#
#
# =================================================================
function module_chroot_mount_fs() {
	echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."

	local MODULES MODULE_LOWER_DIR

	module_check_mounted

	mkdir -p $MODULES_DIR
	mount -t tmpfs none $MODULES_DIR

	MODULES_LIST=""
	MODULES=(/run/initramfs/memory/bundles/*.$BEXT)
	for ((i = ${#MODULES[@]} - 1; i >= 0; i--)); do
		MODULE_LOWER_DIR=$(basename ${MODULES[$i]} .$BEXT)
		mkdir -p $MODULES_DIR/lower/$MODULE_LOWER_DIR-lower
		mount -o bind ${MODULES[$i]} $MODULES_DIR/lower/$MODULE_LOWER_DIR-lower
		MODULES_LIST=$MODULES_LIST":""$MODULES_DIR/lower/$MODULE_LOWER_DIR-lower"
	done
	MODULES_LIST=${MODULES_LIST:1}

	mkdir -p $MODULE_UPPER_DIR $MODULE_WORK_DIR $MODULE_MERGED_DIR

	mount -t overlay overlay -o lowerdir=$MODULES_LIST,upperdir=$MODULE_UPPER_DIR,workdir=$MODULE_WORK_DIR $MODULE_MERGED_DIR

	if [ ! -d $MODULE_MERGED_DIR/dev ]; then
		mkdir -p $MODULE_MERGED_DIR/dev
	fi
	if [ ! -d $MODULE_MERGED_DIR/run ]; then
		mkdir -p $MODULE_MERGED_DIR/run
	fi
	if [ ! -d $MODULE_MERGED_DIR/proc ]; then
		mkdir -p $MODULE_MERGED_DIR/proc
	fi
	if [ ! -d $MODULE_MERGED_DIR/sys ]; then
		mkdir -p $MODULE_MERGED_DIR/sys
	fi
	if [ ! -d $MODULE_MERGED_DIR/tmp ]; then
		mkdir -p $MODULE_MERGED_DIR/tmp
	fi

	mount --bind /dev $MODULE_MERGED_DIR/dev

	echo "nameserver 8.8.8.8" >$MODULE_MERGED_DIR/etc/resolv.conf

	mount none -t proc $MODULE_MERGED_DIR/proc
	mount none -t sysfs $MODULE_MERGED_DIR/sys
	mount none -t devpts $MODULE_MERGED_DIR/dev/pts
	mount none -t tmpfs $MODULE_MERGED_DIR/tmp
}

# =================================================================
#
#
# =================================================================
function module_chroot_umount_fs() {
	echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."

	local MODULES MODULE_LOWER_DIR

	set +e
	if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
		umount $MODULE_MERGED_DIR/proc
		umount $MODULE_MERGED_DIR/sys
		umount $MODULE_MERGED_DIR/dev/pts
		umount $MODULE_MERGED_DIR/tmp
		umount $MODULE_MERGED_DIR/dev

		rm -f $MODULE_UPPER_DIR/etc/resolv.conf

		umount $MODULE_MERGED_DIR

		umount $MODULES_DIR/lower/*

		umount $MODULES_DIR
	else
		umount $MODULE_MERGED_DIR/proc >>$OUTPUT 2>&1
		umount $MODULE_MERGED_DIR/sys >>$OUTPUT 2>&1
		umount $MODULE_MERGED_DIR/dev/pts >>$OUTPUT 2>&1
		umount $MODULE_MERGED_DIR/tmp >>$OUTPUT 2>&1
		umount $MODULE_MERGED_DIR/dev >>$OUTPUT 2>&1

		rm -f $MODULE_UPPER_DIR/etc/resolv.conf >>$OUTPUT 2>&1

		umount $MODULE_MERGED_DIR >>$OUTPUT 2>&1

		umount $MODULES_DIR/lower/* >>$OUTPUT 2>&1

		umount $MODULES_DIR >>$OUTPUT 2>&1
	fi

	set -e

	module_check_mounted
}

# =================================================================
#
#
# =================================================================
function module_cleanup() {
	echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."
	if [ "$UNATTENDED" = "1" ]; then
		module_check_mounted
		rm -rf $MODULE_UPPER_DIR
		if [ -d "$MODULE_UPPER_DIR" ]; then
			module_cleanup
		fi
	else
		read -r -p "$(echo -e ""Do you want to ${BOLD}${RED}completely remove content${ENDCOLOUR} of ${MAGENTA}$MODULE_UPPER_DIR${ENDCOLOUR}? [y/${BOLD}${GREEN}N${ENDCOLOUR}])" response
		response=${response,,}
		if [[ "$response" =~ ^(yes|y)$ ]]; then
			module_check_mounted
			rm -rf $MODULE_UPPER_DIR
			if [ -d "$MODULE_UPPER_DIR" ]; then
				module_cleanup
			fi
		else
			echo -e "${MAGENTA}$MODULE_UPPER_DIR${ENDCOLOUR} should be empty to continue."
			exit 1
		fi
	fi
}

# =================================================================
#
#
# =================================================================
function module_chroot_finish_up() {
	echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."

	chroot $MODULE_MERGED_DIR /bin/bash -x <<EOF
truncate -s 0 /etc/machine-id
EOF

	if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
		chroot $MODULE_MERGED_DIR /bin/bash -x <<EOF
    rm /sbin/initctl
    dpkg-divert --rename --remove /sbin/initctl
EOF
	else
		chroot $MODULE_MERGED_DIR /bin/bash -x <<EOF
    rm /sbin/initctl >>$OUTPUT 2>&1
    dpkg-divert --rename --remove /sbin/initctl >>$OUTPUT 2>&1
EOF
	fi

	if [ -d $MODULE_UPPER_DIR/home/live ]; then
		chown 1000:1000 $MODULE_UPPER_DIR/home/live
		chown -R 1000:1000 $MODULE_UPPER_DIR/home/live
	fi
}

function chroot_cleanup() {
	echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."

	set +eu
	rm -f $1/functions
	rm -f $1/$LIVEKITNAME.conf
	rm -f $1/preinstall
	rm -f $1/install
	rm -f $1/install2
	rm -f $1/cleanup
	rm -f $1/$PACKAGE_VARIANT.list
	rm -f $1/postinstall
	rm -rf $1/rootcopy-install
	rm -rf $1/rootcopy
	rm -rf $1/patches

	rm -f $1/etc/fstab
	rm -f $1/etc/mtab
	rm -f $1/etc/apt/sources.list~
	rm -Rf $1/etc/systemd/system/timers.target.wants
	rm -f $1/etc/systemd/system/multi-user.target.wants/ssh.service
	rm -f $1/etc/systemd/system/multi-user.target.wants/dnsmasq.service

	rm -f $1/etc/ssh/ssh_host*

	rm -f $1/var/backups/*
	rm -f $1/var/cache/ldconfig/*
	rm -f $1/var/cache/debconf/*
	rm -f $1/var/cache/fontconfig/*
	rm -f $1/var/lib/apt/extended_states
	rm -f $1/var/lib/systemd/random-seed
	rm -f $1/var/lib/apt/lists/deb.*
	rm -Rf $1/root/.local/share/mc
	rm -Rf $1/root/.cache
	rm -f $1/root/.wget-hsts

	rm -f $1/var/lib/dpkg/*-old
	rm -f $1/var/log/*
	rm -f $1/var/log/*/*
	rm -f $1/var/log/*/*/*
	rm -f $1/var/cache/apt/archives/*.deb
	rm -f $1/var/cache/apt/*.bin
	rm -f $1/var/cache/debconf/*-old
	rm -f $1/var/lib/dhcp/dhclient.leases
	rm -f $1/root/.bash_history
	rm -f $1/root/.wget-hsts
	rm -Rf $1/usr/share/doc/*
	rm -Rf $1/usr/share/info/*
	rm -f $1/usr/share/images/fluxbox/debian-squared.jpg
	rm -Rf $1/usr/share/fluxbox/nls/??*
	rm -Rf $1/usr/share/gnome/help

	rm -Rf $1/usr/share/locale/??
	rm -Rf $1/usr/share/locale/??_*
	rm -Rf $1/usr/share/locale/??@*
	rm -Rf $1/usr/share/locale/???
	rm -Rf $1/usr/share/i18n/locales/*_*
	rm -Rf $1/usr/share/man/??
	rm -Rf $1/usr/share/man/*_*

	rm -Rf $1/usr/share/icons/elementaryXubuntu-dark
	rm -Rf $1/usr/share/icons/gnome/256x256

	rm $1/usr/share/applications/compton.desktop
	rm $1/usr/share/applications/debian-uxterm.desktop
	rm $1/usr/share/applications/debian-xterm.desktop
	rm $1/usr/share/applications/htop.desktop
	rm $1/usr/share/applications/mc.desktop
	rm $1/usr/share/applications/mcedit.desktop
	rm $1/usr/share/applications/pcmanfm-desktop-pref.desktop
	rm $1/usr/share/applications/python2.7.desktop
	rm $1/usr/share/applications/python3.7.desktop
	rm $1/usr/share/applications/vim.desktop

	if [ -z $1 ]; then
		uncompress_files $1/etc/alternatives
		uncompress_files $1/usr/share/man

		remove_broken_links $1/etc/alternatives
		remove_broken_links $1/usr/share/man
	fi

	set -eu
}

# =================================================================
#
#
# =================================================================
function module_build_cleanup() {
	echo -e "=====> the ${CYAN}${FUNCNAME[0]}${ENDCOLOUR} function is executing ..."

	if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
		chroot_cleanup $MODULE_UPPER_DIR
	else
		chroot_cleanup $MODULE_UPPER_DIR >>$OUTPUT 2>&1
	fi
}

# =================================================================
#
#
# =================================================================
function build_modules() {
	current_process

	MODULES_DIR=$CURRENT_DIR/build

	if [ -d $CURRENT_DIR/modules ]; then
		cd $CURRENT_DIR/modules
	else
		help
	fi

	for MODULE in *; do
		MODULE_UPPER_DIR="$MODULES_DIR/$MODULE-upper"
		MODULE_WORK_DIR="$MODULES_DIR/$MODULE-work"
		MODULE_MERGED_DIR="$MODULES_DIR/$MODULE-merged"

		module_check_build_dir

		module_chroot_mount_fs

		if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
			chroot_run $MODULE_MERGED_DIR $APT_CMD update
		else
			chroot_run $MODULE_MERGED_DIR $APT_CMD update >>$OUTPUT 2>&1
		fi

		# run pre-install script
		if [ -f $SCRIPT_DIR/linux-live/modules/$MODULE/preinstall ]; then
			if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
				cp $SCRIPT_DIR/linux-live/modules/$MODULE/preinstall $MODULE_MERGED_DIR/preinstall
				chmod +x $MODULE_MERGED_DIR/preinstall
				chroot_run $MODULE_MERGED_DIR /preinstall
			else
				cp $SCRIPT_DIR/linux-live/modules/$MODULE/preinstall $MODULE_MERGED_DIR/preinstall
				chmod +x $MODULE_MERGED_DIR/preinstall
				chroot_run $MODULE_MERGED_DIR /preinstall >>$OUTPUT 2>&1
			fi
		fi

		# copy files
		if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
			if [ "$(ls -A $CURRENT_DIR/modules/$MODULE/rootcopy-install)" != "" ]; then
				(cd $CURRENT_DIR/modules/$MODULE/rootcopy-install && cp --parents -afr * $MODULE_MERGED_DIR/)
			fi
		else
			if [ "$(ls -A $CURRENT_DIR/modules/$MODULE/rootcopy-install)" != "" ] >>$OUTPUT 2>&1; then
				(cd $CURRENT_DIR/modules/$MODULE/rootcopy-install && cp --parents -afr * $MODULE_MERGED_DIR/)
			fi
		fi

		# run install script
		if [ -f $CURRENT_DIR/modules/$MODULE/install ]; then
			cp $CURRENT_DIR/modules/$MODULE/install $MODULE_MERGED_DIR/install
			chmod +x $MODULE_MERGED_DIR/install
			if [ -f $CURRENT_DIR/modules/$MODULE/cleanup ]; then
				cp $CURRENT_DIR/modules/$MODULE/cleanup $MODULE_MERGED_DIR/cleanup
			fi
			if [ -f $CURRENT_DIR/modules/$MODULE/$PACKAGE_VARIANT.list ]; then
				cp $CURRENT_DIR/modules/$MODULE/$PACKAGE_VARIANT.list $MODULE_MERGED_DIR/$PACKAGE_VARIANT.list
			fi
			if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
				chroot_run $MODULE_MERGED_DIR /install
			else
				chroot_run $MODULE_MERGED_DIR /install >>$OUTPUT 2>&1
			fi
		fi

		# run install2 script
		if [ -f $CURRENT_DIR/modules/$MODULE/install2 ]; then
			cp $CURRENT_DIR/modules/$MODULE/install2 $MODULE_MERGED_DIR/install2
			chmod +x $MODULE_MERGED_DIR/install2
			if [ "$(ls -A $CURRENT_DIR/modules/$MODULE/patches)" != "" ] >>$OUTPUT 2>&1; then
				mkdir $MODULE_MERGED_DIR/patches
				(cd $CURRENT_DIR/modules/$MODULE/patches && cp --parents -afr * $MODULE_MERGED_DIR/patches/)
			fi
			if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
				chroot_run $MODULE_MERGED_DIR /install2
			else
				chroot_run $MODULE_MERGED_DIR /install2 >>$OUTPUT 2>&1
			fi
		fi

		# copy files
		if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
			if [ "$(ls -A $CURRENT_DIR/modules/$MODULE/rootcopy-postinstall)" != "" ]; then
				(cd $CURRENT_DIR/modules/$MODULE/rootcopy-postinstall && cp --parents -afr * $MODULE_MERGED_DIR/)
			fi
		else
			if [ "$(ls -A $CURRENT_DIR/modules/$MODULE/rootcopy-postinstall)" != "" ] >>$OUTPUT 2>&1; then
				(cd $CURRENT_DIR/modules/$MODULE/rootcopy-postinstall && cp --parents -afr * $MODULE_MERGED_DIR/)
			fi
		fi

		# run post-install script
		if [ -f $CURRENT_DIR/modules/$MODULE/postinstall ]; then
			cp $CURRENT_DIR/modules/$MODULE/postinstall $MODULE_MERGED_DIR/postinstall
			chmod +x $MODULE_MERGED_DIR/postinstall
			if [ $OUTPUT = "/dev/stdout" ] && [ ! -f /dev/stdout ]; then
				chroot_run $MODULE_MERGED_DIR /postinstall
			else
				chroot_run $MODULE_MERGED_DIR /postinstall >>$OUTPUT 2>&1
			fi
		fi

		set +e
		chroot_run $MODULE_MERGED_DIR uncompress_files /etc/alternatives
		chroot_run $MODULE_MERGED_DIR uncompress_files /usr/share/man
		chroot_run $MODULE_MERGED_DIR remove_broken_links /etc/alternatives
		chroot_run $MODULE_MERGED_DIR remove_broken_links /usr/share/man
		set -e

		module_chroot_finish_up

		module_build_cleanup

		if [ "$(ls -A $MODULE_UPPER_DIR)" != "" ]; then
			mksquashfs $MODULE_UPPER_DIR $CURRENT_DIR/$MODULE-$COMP_TYPE.$BEXT -comp $COMP_TYPE -b 1024K -always-use-fragments -noappend || exit
		else
			echo -e "${MAGENTA}$MODULE_UPPER_DIR${ENDCOLOUR} ${RED}is empty${ENDCOLOUR}. Nothing to do."
		fi

		module_chroot_umount_fs

	done

}

function repack_module() {
	cd $CURRENT_DIR
	OLD_MODULE=$MODULE
	MODULE=${MODULE%"-$OLD_COMP_TYPE.$BEXT"}
	if [ $COMP_TYPE = $OLD_COMP_TYPE ]; then
		echo "The module is already in the required compression format." && exit
	fi

	if (ls $CURRENT_DIR/*.$BEXT | grep -q $MODULE 2>/dev/null); then
		echo -e "${RED}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!${ENDCOLOUR}"
		echo -e "Please remove $CURRENT_DIR/$MODULE-$COMP_TYPE.$BEXT${ENDCOLOUR} if you want to build ${MAGENTA}$MODULE${ENDCOLOUR}."
		echo -e "${RED}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!${ENDCOLOUR}"
	else
		mksquashfs /run/initramfs/memory/bundles/$OLD_MODULE $CURRENT_DIR/$MODULE-$COMP_TYPE.$BEXT -comp $COMP_TYPE -b 1024K -always-use-fragments -noappend || exit
	fi
}

function repack_system() {
	current_process

	cd /run/initramfs/memory/bundles/
	for MODULE in *; do
		if (ls /run/initramfs/memory/bundles/*-xz.$BEXT | grep -q $MODULE >>/dev/null 2>&1); then
			OLD_COMP_TYPE="xz"
			repack_module
		elif (ls /run/initramfs/memory/bundles/*-lz4.$BEXT | grep -q $MODULE >>/dev/null 2>&1); then
			OLD_COMP_TYPE="lz4"
			repack_module
		elif (ls /run/initramfs/memory/bundles/*-zstd.$BEXT | grep -q $MODULE >>/dev/null 2>&1); then
			OLD_COMP_TYPE="zstd"
			repack_module
		fi
	done
}
